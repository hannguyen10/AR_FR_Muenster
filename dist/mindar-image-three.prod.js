/*! For license information please see mindar-image-three.prod.js.LICENSE.txt */
(()=>{var t={2948:(t,e,n)=>{var r=n(2140),s=n(9980),i=n(1730),a=n(7405),o=n(4026),l=n(865),u=n(8721);u.alea=r,u.xor128=s,u.xorwow=i,u.xorshift7=a,u.xor4096=o,u.tychei=l,t.exports=u},2140:function(t,e,n){var r;!function(t,s,i){function a(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new a(t),r=e&&e.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.alea=l}(0,t=n.nmd(t),n.amdD)},865:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,s=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^s,e.a=s-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.tychei=l}(0,t=n.nmd(t),n.amdD)},9980:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xor128=l}(0,t=n.nmd(t),n.amdD)},4026:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this;e.next=function(){var t,n,r=e.w,s=e.X,i=e.i;return e.w=r=r+1640531527|0,n=s[i+34&127],t=s[i=i+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=s[i]=n^t,e.i=i,n+(r^r>>>16)|0},function(t,e){var n,r,s,i,a,o=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),s=0,i=-32;i<l;++i)e&&(r^=e.charCodeAt((i+32)%e.length)),0===i&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,i>=0&&(a=a+1640531527|0,s=0==(n=o[127&i]^=r+a)?s+1:0);for(s>=128&&(o[127&(e&&e.length||0)]=-1),s=127,i=512;i>0;--i)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;t.w=a,t.X=o,t.i=s}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.X&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xor4096=l}(0,t=n.nmd(t),n.amdD)},7405:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this;e.next=function(){var t,n,r=e.x,s=e.i;return t=r[s],n=(t^=t>>>7)^t<<24,n^=(t=r[s+1&7])^t>>>10,n^=(t=r[s+3&7])^t>>>3,n^=(t=r[s+4&7])^t<<7,t=r[s+7&7],n^=(t^=t<<13)^t<<9,r[s]=n,e.i=s+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.x&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xorshift7=l}(0,t=n.nmd(t),n.amdD)},1730:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xorwow=l}(0,t=n.nmd(t),n.amdD)},8721:(t,e,n)=>{var r;!function(s,i){var a,o=this,l=256,u=i.pow(l,6),c=i.pow(2,52),h=2*c,d=255;function p(t,e,n){var r=[],d=x(g((e=1==e?{entropy:!0}:e||{}).entropy?[t,y(s)]:null==t?function(){try{var t;return a&&(t=a.randomBytes)?t=t(l):(t=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(t)),y(t)}catch(t){var e=o.navigator,n=e&&e.plugins;return[+new Date,o,n,o.screen,y(s)]}}():t,3),r),p=new f(r),v=function(){for(var t=p.g(6),e=u,n=0;t<c;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,x(y(p.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&m(r,p),t.state=function(){return m(p,{})}),n?(i.random=t,e):t})(v,d,"global"in e?e.global:this==i,e.state)}function f(t){var e,n=t.length,r=this,s=0,i=r.i=r.j=0,a=r.S=[];for(n||(t=[n++]);s<l;)a[s]=s++;for(s=0;s<l;s++)a[s]=a[i=d&i+t[s%n]+(e=a[s])],a[i]=e;(r.g=function(t){for(var e,n=0,s=r.i,i=r.j,a=r.S;t--;)e=a[s=d&s+1],n=n*l+a[d&(a[s]=a[i=d&i+e])+(a[i]=e)];return r.i=s,r.j=i,n})(l)}function m(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function g(t,e){var n,r=[],s=typeof t;if(e&&"object"==s)for(n in t)try{r.push(g(t[n],e-1))}catch(t){}return r.length?r:"string"==s?t:t+"\0"}function x(t,e){for(var n,r=t+"",s=0;s<r.length;)e[d&s]=d&(n^=19*e[d&s])+r.charCodeAt(s++);return y(e)}function y(t){return String.fromCharCode.apply(0,t)}if(i.seedrandom=p,x(i.random(),s),t.exports){t.exports=p;try{a=n(914)}catch(t){}}else void 0===(r=function(){return p}.call(e,n,e,t))||(t.exports=r)}([],Math)},3129:(t,e,n)=>{var r=n(626),s=n(477),i=n(2868),a=n(8197),o=n(1954),l=n(2408),u=n(1662);u.alea=r,u.xor128=s,u.xorwow=i,u.xorshift7=a,u.xor4096=o,u.tychei=l,t.exports=u},626:function(t,e,n){var r;!function(t,s,i){function a(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new a(t),r=e&&e.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.alea=l}(0,t=n.nmd(t),n.amdD)},2408:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,s=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^s,e.a=s-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.tychei=l}(0,t=n.nmd(t),n.amdD)},477:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xor128=l}(0,t=n.nmd(t),n.amdD)},1954:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this;e.next=function(){var t,n,r=e.w,s=e.X,i=e.i;return e.w=r=r+1640531527|0,n=s[i+34&127],t=s[i=i+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=s[i]=n^t,e.i=i,n+(r^r>>>16)|0},function(t,e){var n,r,s,i,a,o=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),s=0,i=-32;i<l;++i)e&&(r^=e.charCodeAt((i+32)%e.length)),0===i&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,i>=0&&(a=a+1640531527|0,s=0==(n=o[127&i]^=r+a)?s+1:0);for(s>=128&&(o[127&(e&&e.length||0)]=-1),s=127,i=512;i>0;--i)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;t.w=a,t.X=o,t.i=s}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.X&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xor4096=l}(0,t=n.nmd(t),n.amdD)},8197:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this;e.next=function(){var t,n,r=e.x,s=e.i;return t=r[s],n=(t^=t>>>7)^t<<24,n^=(t=r[s+1&7])^t>>>10,n^=(t=r[s+3&7])^t>>>3,n^=(t=r[s+4&7])^t<<7,t=r[s+7&7],n^=(t^=t<<13)^t<<9,r[s]=n,e.i=s+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.x&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xorshift7=l}(0,t=n.nmd(t),n.amdD)},2868:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xorwow=l}(0,t=n.nmd(t),n.amdD)},1662:(t,e,n)=>{var r;!function(s,i){var a,o=this,l=256,u=i.pow(l,6),c=i.pow(2,52),h=2*c,d=255;function p(t,e,n){var r=[],d=x(g((e=1==e?{entropy:!0}:e||{}).entropy?[t,y(s)]:null==t?function(){try{var t;return a&&(t=a.randomBytes)?t=t(l):(t=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(t)),y(t)}catch(t){var e=o.navigator,n=e&&e.plugins;return[+new Date,o,n,o.screen,y(s)]}}():t,3),r),p=new f(r),v=function(){for(var t=p.g(6),e=u,n=0;t<c;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,x(y(p.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&m(r,p),t.state=function(){return m(p,{})}),n?(i.random=t,e):t})(v,d,"global"in e?e.global:this==i,e.state)}function f(t){var e,n=t.length,r=this,s=0,i=r.i=r.j=0,a=r.S=[];for(n||(t=[n++]);s<l;)a[s]=s++;for(s=0;s<l;s++)a[s]=a[i=d&i+t[s%n]+(e=a[s])],a[i]=e;(r.g=function(t){for(var e,n=0,s=r.i,i=r.j,a=r.S;t--;)e=a[s=d&s+1],n=n*l+a[d&(a[s]=a[i=d&i+e])+(a[i]=e)];return r.i=s,r.j=i,n})(l)}function m(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function g(t,e){var n,r=[],s=typeof t;if(e&&"object"==s)for(n in t)try{r.push(g(t[n],e-1))}catch(t){}return r.length?r:"string"==s?t:t+"\0"}function x(t,e){for(var n,r=t+"",s=0;s<r.length;)e[d&s]=d&(n^=19*e[d&s])+r.charCodeAt(s++);return y(e)}function y(t){return String.fromCharCode.apply(0,t)}if(i.seedrandom=p,x(i.random(),s),t.exports){t.exports=p;try{a=n(5778)}catch(t){}}else void 0===(r=function(){return p}.call(e,n,e,t))||(t.exports=r)}([],Math)},8485:(t,e,n)=>{"use strict";n.d(e,{Z:()=>o});var r=n(8081),s=n.n(r),i=n(3645),a=n.n(i)()(s());a.push([t.id,".mindar-ui-overlay{display:flex;align-items:center;justify-content:center;position:absolute;left:0;right:0;top:0;bottom:0;background:rgba(0,0,0,0);z-index:2}.mindar-ui-overlay.hidden{display:none}.mindar-ui-loading .loader{border:16px solid #222;border-top:16px solid #fff;opacity:.8;border-radius:50%;width:120px;height:120px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.mindar-ui-compatibility .content{background:#000;color:#fff;opacity:.8;text-align:center;margin:20px;padding:20px;min-height:50vh}@media(min-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:50vh;height:50vh}}@media(max-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:80vw;height:80vw}}.mindar-ui-scanning .scanning .inner{position:relative;width:100%;height:100%;opacity:.8;background:linear-gradient(to right, white 10px, transparent 10px) 0 0,linear-gradient(to right, white 10px, transparent 10px) 0 100%,linear-gradient(to left, white 10px, transparent 10px) 100% 0,linear-gradient(to left, white 10px, transparent 10px) 100% 100%,linear-gradient(to bottom, white 10px, transparent 10px) 0 0,linear-gradient(to bottom, white 10px, transparent 10px) 100% 0,linear-gradient(to top, white 10px, transparent 10px) 0 100%,linear-gradient(to top, white 10px, transparent 10px) 100% 100%;background-repeat:no-repeat;background-size:40px 40px}.mindar-ui-scanning .scanning .inner .scanline{position:absolute;width:100%;height:10px;background:#fff;animation:move 2s linear infinite}@keyframes move{0%,100%{top:0%}50%{top:calc(100% - 10px)}}",""]);const o=a},3645:t=>{"use strict";t.exports=function(t){var e=[];return e.toString=function(){return this.map((function(e){var n="",r=void 0!==e[5];return e[4]&&(n+="@supports (".concat(e[4],") {")),e[2]&&(n+="@media ".concat(e[2]," {")),r&&(n+="@layer".concat(e[5].length>0?" ".concat(e[5]):""," {")),n+=t(e),r&&(n+="}"),e[2]&&(n+="}"),e[4]&&(n+="}"),n})).join("")},e.i=function(t,n,r,s,i){"string"==typeof t&&(t=[[null,t,void 0]]);var a={};if(r)for(var o=0;o<this.length;o++){var l=this[o][0];null!=l&&(a[l]=!0)}for(var u=0;u<t.length;u++){var c=[].concat(t[u]);r&&a[c[0]]||(void 0!==i&&(void 0===c[5]||(c[1]="@layer".concat(c[5].length>0?" ".concat(c[5]):""," {").concat(c[1],"}")),c[5]=i),n&&(c[2]?(c[1]="@media ".concat(c[2]," {").concat(c[1],"}"),c[2]=n):c[2]=n),s&&(c[4]?(c[1]="@supports (".concat(c[4],") {").concat(c[1],"}"),c[4]=s):c[4]="".concat(s)),e.push(c))}},e}},8081:t=>{"use strict";t.exports=function(t){return t[1]}},3720:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},i={};function a(t,e){var n,r,a;return e?(a=0<=(t>>>=0)&&t<256)&&(r=i[t])?r:(n=l(t,(0|t)<0?-1:0,!0),a&&(i[t]=n),n):(a=-128<=(t|=0)&&t<128)&&(r=s[t])?r:(n=l(t,t<0?-1:0,!1),a&&(s[t]=n),n)}function o(t,e){if(isNaN(t))return e?x:g;if(e){if(t<0)return x;if(t>=p)return S}else{if(t<=-f)return _;if(t+1>=f)return w}return t<0?o(-t,e).neg():l(t%d|0,t/d|0,e)}function l(t,e,r){return new n(t,e,r)}n.fromInt=a,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return g;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(t.substring(1),e,n).neg();for(var s=o(u(n,8)),i=g,a=0;a<t.length;a+=8){var l=Math.min(8,t.length-a),h=parseInt(t.substring(a,a+l),n);if(l<8){var d=o(u(n,l));i=i.mul(d).add(o(h))}else i=(i=i.mul(s)).add(o(h))}return i.unsigned=e,i}function h(t,e){return"number"==typeof t?o(t,e):"string"==typeof t?c(t,e):l(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=a(1<<24),g=a(0);n.ZERO=g;var x=a(0,!0);n.UZERO=x;var y=a(1);n.ONE=y;var v=a(1,!0);n.UONE=v;var b=a(-1);n.NEG_ONE=b;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var S=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=S;var _=l(0,-2147483648,!1);n.MIN_VALUE=_;var T=n.prototype;T.toInt=function(){return this.unsigned?this.low>>>0:this.low},T.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},T.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(_)){var e=o(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var s=o(u(t,6),this.unsigned),i=this,a="";;){var l=i.div(s),c=(i.sub(l.mul(s)).toInt()>>>0).toString(t);if((i=l).isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}},T.getHighBits=function(){return this.high},T.getHighBitsUnsigned=function(){return this.high>>>0},T.getLowBits=function(){return this.low},T.getLowBitsUnsigned=function(){return this.low>>>0},T.getNumBitsAbs=function(){if(this.isNegative())return this.eq(_)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&0==(t&1<<e);e--);return 0!=this.high?e+33:e+1},T.isZero=function(){return 0===this.high&&0===this.low},T.eqz=T.isZero,T.isNegative=function(){return!this.unsigned&&this.high<0},T.isPositive=function(){return this.unsigned||this.high>=0},T.isOdd=function(){return 1==(1&this.low)},T.isEven=function(){return 0==(1&this.low)},T.equals=function(t){return r(t)||(t=h(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},T.eq=T.equals,T.notEquals=function(t){return!this.eq(t)},T.neq=T.notEquals,T.ne=T.notEquals,T.lessThan=function(t){return this.comp(t)<0},T.lt=T.lessThan,T.lessThanOrEqual=function(t){return this.comp(t)<=0},T.lte=T.lessThanOrEqual,T.le=T.lessThanOrEqual,T.greaterThan=function(t){return this.comp(t)>0},T.gt=T.greaterThan,T.greaterThanOrEqual=function(t){return this.comp(t)>=0},T.gte=T.greaterThanOrEqual,T.ge=T.greaterThanOrEqual,T.compare=function(t){if(r(t)||(t=h(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},T.comp=T.compare,T.negate=function(){return!this.unsigned&&this.eq(_)?_:this.not().add(y)},T.neg=T.negate,T.add=function(t){r(t)||(t=h(t));var e=this.high>>>16,n=65535&this.high,s=this.low>>>16,i=65535&this.low,a=t.high>>>16,o=65535&t.high,u=t.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=i+(65535&t.low))>>>16,d+=(p+=s+u)>>>16,c+=(d+=n+o)>>>16,c+=e+a,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},T.subtract=function(t){return r(t)||(t=h(t)),this.add(t.neg())},T.sub=T.subtract,T.multiply=function(t){if(this.isZero())return g;if(r(t)||(t=h(t)),e)return l(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return g;if(this.eq(_))return t.isOdd()?_:g;if(t.eq(_))return this.isOdd()?_:g;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(m)&&t.lt(m))return o(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,i=this.low>>>16,a=65535&this.low,u=t.high>>>16,c=65535&t.high,d=t.low>>>16,p=65535&t.low,f=0,x=0,y=0,v=0;return y+=(v+=a*p)>>>16,x+=(y+=i*p)>>>16,y&=65535,x+=(y+=a*d)>>>16,f+=(x+=s*p)>>>16,x&=65535,f+=(x+=i*d)>>>16,x&=65535,f+=(x+=a*c)>>>16,f+=n*p+s*d+i*c+a*u,l((y&=65535)<<16|(v&=65535),(f&=65535)<<16|(x&=65535),this.unsigned)},T.mul=T.multiply,T.divide=function(t){if(r(t)||(t=h(t)),t.isZero())throw Error("division by zero");var n,s,i;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?l((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?x:g;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return x;if(t.gt(this.shru(1)))return v;i=x}else{if(this.eq(_))return t.eq(y)||t.eq(b)?_:t.eq(_)?y:(n=this.shr(1).div(t).shl(1)).eq(g)?t.isNegative()?y:b:(s=this.sub(t.mul(n)),i=n.add(s.div(t)));if(t.eq(_))return this.unsigned?x:g;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();i=g}for(s=this;s.gte(t);){n=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),c=a<=48?1:u(2,a-48),d=o(n),p=d.mul(t);p.isNegative()||p.gt(s);)p=(d=o(n-=c,this.unsigned)).mul(t);d.isZero()&&(d=y),i=i.add(d),s=s.sub(p)}return i},T.div=T.divide,T.modulo=function(t){return r(t)||(t=h(t)),e?l((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},T.mod=T.modulo,T.rem=T.modulo,T.not=function(){return l(~this.low,~this.high,this.unsigned)},T.and=function(t){return r(t)||(t=h(t)),l(this.low&t.low,this.high&t.high,this.unsigned)},T.or=function(t){return r(t)||(t=h(t)),l(this.low|t.low,this.high|t.high,this.unsigned)},T.xor=function(t){return r(t)||(t=h(t)),l(this.low^t.low,this.high^t.high,this.unsigned)},T.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?l(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):l(0,this.low<<t-32,this.unsigned)},T.shl=T.shiftLeft,T.shiftRight=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?l(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):l(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},T.shr=T.shiftRight,T.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?l(this.low>>>t|e<<32-t,e>>>t,this.unsigned):l(32===t?e:e>>>t-32,0,this.unsigned)},T.shru=T.shiftRightUnsigned,T.shr_u=T.shiftRightUnsigned,T.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},T.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},T.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},T.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},T.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},6377:(t,e,n)=>{var r=n(4832),s=n(8652),i=n(801),a=n(2030),o=n(3618),l=n(9049),u=n(1971);u.alea=r,u.xor128=s,u.xorwow=i,u.xorshift7=a,u.xor4096=o,u.tychei=l,t.exports=u},4832:function(t,e,n){var r;!function(t,s,i){function a(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function o(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function l(t,e){var n=new a(t),r=e&&e.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.alea=l}(0,t=n.nmd(t),n.amdD)},9049:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,s=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^s,e.a=s-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function l(t,e){var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.tychei=l}(0,t=n.nmd(t),n.amdD)},8652:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function l(t,e){var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xor128=l}(0,t=n.nmd(t),n.amdD)},3618:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this;e.next=function(){var t,n,r=e.w,s=e.X,i=e.i;return e.w=r=r+1640531527|0,n=s[i+34&127],t=s[i=i+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=s[i]=n^t,e.i=i,n+(r^r>>>16)|0},function(t,e){var n,r,s,i,a,o=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),s=0,i=-32;i<l;++i)e&&(r^=e.charCodeAt((i+32)%e.length)),0===i&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,i>=0&&(a=a+1640531527|0,s=0==(n=o[127&i]^=r+a)?s+1:0);for(s>=128&&(o[127&(e&&e.length||0)]=-1),s=127,i=512;i>0;--i)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;t.w=a,t.X=o,t.i=s}(e,t)}function o(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.X&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xor4096=l}(0,t=n.nmd(t),n.amdD)},2030:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this;e.next=function(){var t,n,r=e.x,s=e.i;return t=r[s],n=(t^=t>>>7)^t<<24,n^=(t=r[s+1&7])^t>>>10,n^=(t=r[s+3&7])^t>>>3,n^=(t=r[s+4&7])^t<<7,t=r[s+7&7],n^=(t^=t<<13)^t<<9,r[s]=n,e.i=s+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function o(t,e){return e.x=t.x.slice(),e.i=t.i,e}function l(t,e){null==t&&(t=+new Date);var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.x&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xorshift7=l}(0,t=n.nmd(t),n.amdD)},801:function(t,e,n){var r;!function(t,s,i){function a(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function o(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function l(t,e){var n=new a(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&o(r,n),s.state=function(){return o(n,{})}),s}s&&s.exports?s.exports=l:n.amdD&&n.amdO?void 0===(r=function(){return l}.call(e,n,e,s))||(s.exports=r):this.xorwow=l}(0,t=n.nmd(t),n.amdD)},1971:(t,e,n)=>{var r;!function(s,i){var a,o=(0,eval)("this"),l=256,u=i.pow(l,6),c=i.pow(2,52),h=2*c,d=255;function p(t,e,n){var r=[],d=x(g((e=1==e?{entropy:!0}:e||{}).entropy?[t,y(s)]:null==t?function(){try{var t;return a&&(t=a.randomBytes)?t=t(l):(t=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(t)),y(t)}catch(t){var e=o.navigator,n=e&&e.plugins;return[+new Date,o,n,o.screen,y(s)]}}():t,3),r),p=new f(r),v=function(){for(var t=p.g(6),e=u,n=0;t<c;)t=(t+n)*l,e*=l,n=p.g(1);for(;t>=h;)t/=2,e/=2,n>>>=1;return(t+n)/e};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,x(y(p.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&m(r,p),t.state=function(){return m(p,{})}),n?(i.random=t,e):t})(v,d,"global"in e?e.global:this==i,e.state)}function f(t){var e,n=t.length,r=this,s=0,i=r.i=r.j=0,a=r.S=[];for(n||(t=[n++]);s<l;)a[s]=s++;for(s=0;s<l;s++)a[s]=a[i=d&i+t[s%n]+(e=a[s])],a[i]=e;(r.g=function(t){for(var e,n=0,s=r.i,i=r.j,a=r.S;t--;)e=a[s=d&s+1],n=n*l+a[d&(a[s]=a[i=d&i+e])+(a[i]=e)];return r.i=s,r.j=i,n})(l)}function m(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function g(t,e){var n,r=[],s=typeof t;if(e&&"object"==s)for(n in t)try{r.push(g(t[n],e-1))}catch(t){}return r.length?r:"string"==s?t:t+"\0"}function x(t,e){for(var n,r=t+"",s=0;s<r.length;)e[d&s]=d&(n^=19*e[d&s])+r.charCodeAt(s++);return y(e)}function y(t){return String.fromCharCode.apply(0,t)}if(i.seedrandom=p,x(i.random(),s),t.exports){t.exports=p;try{a=n(5042)}catch(t){}}else void 0===(r=function(){return p}.call(e,n,e,t))||(t.exports=r)}([],Math)},3379:t=>{"use strict";var e=[];function n(t){for(var n=-1,r=0;r<e.length;r++)if(e[r].identifier===t){n=r;break}return n}function r(t,r){for(var i={},a=[],o=0;o<t.length;o++){var l=t[o],u=r.base?l[0]+r.base:l[0],c=i[u]||0,h="".concat(u," ").concat(c);i[u]=c+1;var d=n(h),p={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==d)e[d].references++,e[d].updater(p);else{var f=s(p,r);r.byIndex=o,e.splice(o,0,{identifier:h,updater:f,references:1})}a.push(h)}return a}function s(t,e){var n=e.domAPI(e);return n.update(t),function(e){if(e){if(e.css===t.css&&e.media===t.media&&e.sourceMap===t.sourceMap&&e.supports===t.supports&&e.layer===t.layer)return;n.update(t=e)}else n.remove()}}t.exports=function(t,s){var i=r(t=t||[],s=s||{});return function(t){t=t||[];for(var a=0;a<i.length;a++){var o=n(i[a]);e[o].references--}for(var l=r(t,s),u=0;u<i.length;u++){var c=n(i[u]);0===e[c].references&&(e[c].updater(),e.splice(c,1))}i=l}}},569:t=>{"use strict";var e={};t.exports=function(t,n){var r=function(t){if(void 0===e[t]){var n=document.querySelector(t);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(t){n=null}e[t]=n}return e[t]}(t);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},9216:t=>{"use strict";t.exports=function(t){var e=document.createElement("style");return t.setAttributes(e,t.attributes),t.insert(e,t.options),e}},3565:(t,e,n)=>{"use strict";t.exports=function(t){var e=n.nc;e&&t.setAttribute("nonce",e)}},7795:t=>{"use strict";t.exports=function(t){var e=t.insertStyleElement(t);return{update:function(n){!function(t,e,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var s=void 0!==n.layer;s&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,s&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var i=n.sourceMap;i&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i))))," */")),e.styleTagTransform(r,t,e.options)}(e,t,n)},remove:function(){!function(t){if(null===t.parentNode)return!1;t.parentNode.removeChild(t)}(e)}}}},4589:t=>{"use strict";t.exports=function(t,e){if(e.styleSheet)e.styleSheet.cssText=t;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(t))}}},6072:t=>{"use strict";t.exports=function(t,e,n,r){var s=self||window;try{try{var i;try{i=new s.Blob([t])}catch(e){(i=new(s.BlobBuilder||s.WebKitBlobBuilder||s.MozBlobBuilder||s.MSBlobBuilder)).append(t),i=i.getBlob()}var a=s.URL||s.webkitURL,o=a.createObjectURL(i),l=new s[e](o,n);return a.revokeObjectURL(o),l}catch(r){return new s[e]("data:application/javascript,".concat(encodeURIComponent(t)),n)}}catch(t){if(!r)throw Error("Inline worker is not supported");return new s[e](r,n)}}},914:()=>{},5410:()=>{},8628:()=>{},5778:()=>{},1601:()=>{},7792:()=>{},4977:()=>{},5042:()=>{}},e={};function n(r){var s=e[r];if(void 0!==s)return s.exports;var i=e[r]={id:r,loaded:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.nmd=t=>(t.paths=[],t.children||(t.children=[]),t),n.nc=void 0,(()=>{"use strict";var t={};n.r(t),n.d(t,{ACESFilmicToneMapping:()=>it,AddEquation:()=>I,AddOperation:()=>tt,AdditiveAnimationBlendMode:()=>Re,AdditiveBlending:()=>T,AlphaFormat:()=>$t,AlwaysDepth:()=>H,AlwaysStencilFunc:()=>an,AmbientLight:()=>Uh,AmbientLightProbe:()=>sd,AnimationClip:()=>dh,AnimationLoader:()=>bh,AnimationMixer:()=>Pd,AnimationObjectGroup:()=>Ld,AnimationUtils:()=>Qc,ArcCurve:()=>Su,ArrayCamera:()=>el,ArrowHelper:()=>Mp,Audio:()=>gd,AudioAnalyser:()=>Sd,AudioContext:()=>ed,AudioListener:()=>md,AudioLoader:()=>nd,AxesHelper:()=>Ep,AxisHelper:()=>lf,BackSide:()=>y,BasicDepthPacking:()=>$e,BasicShadowMap:()=>p,BinaryTextureLoader:()=>pf,Bone:()=>Ul,BooleanKeyframeTrack:()=>ih,BoundingBoxHelper:()=>uf,Box2:()=>jd,Box3:()=>dr,Box3Helper:()=>bp,BoxBufferGeometry:()=>di,BoxGeometry:()=>di,BoxHelper:()=>vp,BufferAttribute:()=>Is,BufferGeometry:()=>js,BufferGeometryLoader:()=>Xh,ByteType:()=>kt,Cache:()=>fh,Camera:()=>xi,CameraHelper:()=>gp,CanvasRenderer:()=>mf,CanvasTexture:()=>vu,CapsuleBufferGeometry:()=>Vu,CapsuleGeometry:()=>Vu,CatmullRomCurve3:()=>Iu,CineonToneMapping:()=>st,CircleBufferGeometry:()=>Gu,CircleGeometry:()=>Gu,ClampToEdgeWrapping:()=>ft,Clock:()=>ud,Color:()=>Xn,ColorKeyframeTrack:()=>ah,ColorManagement:()=>Un,CompressedTexture:()=>yu,CompressedTextureLoader:()=>wh,ConeBufferGeometry:()=>ju,ConeGeometry:()=>ju,CubeCamera:()=>bi,CubeReflectionMapping:()=>lt,CubeRefractionMapping:()=>ut,CubeTexture:()=>wi,CubeTextureLoader:()=>_h,CubeUVReflectionMapping:()=>dt,CubicBezierCurve:()=>Nu,CubicBezierCurve3:()=>Du,CubicInterpolant:()=>eh,CullFaceBack:()=>c,CullFaceFront:()=>h,CullFaceFrontBack:()=>d,CullFaceNone:()=>u,Curve:()=>bu,CurvePath:()=>Bu,CustomBlending:()=>k,CustomToneMapping:()=>at,CylinderBufferGeometry:()=>Hu,CylinderGeometry:()=>Hu,Cylindrical:()=>Gd,Data3DTexture:()=>ir,DataArrayTexture:()=>rr,DataTexture:()=>Wl,DataTexture2DArray:()=>Mf,DataTexture3D:()=>Ef,DataTextureLoader:()=>Th,DataUtils:()=>Ip,DecrementStencilOp:()=>Xe,DecrementWrapStencilOp:()=>Ye,DefaultLoadingManager:()=>gh,DepthFormat:()=>Wt,DepthStencilFormat:()=>Vt,DepthTexture:()=>il,DirectionalLight:()=>Bh,DirectionalLightHelper:()=>pp,DiscreteInterpolant:()=>rh,DodecahedronBufferGeometry:()=>Xu,DodecahedronGeometry:()=>Xu,DoubleSide:()=>v,DstAlphaFactor:()=>z,DstColorFactor:()=>U,DynamicBufferAttribute:()=>Jp,DynamicCopyUsage:()=>fn,DynamicDrawUsage:()=>ln,DynamicReadUsage:()=>hn,EdgesGeometry:()=>Qu,EdgesHelper:()=>cf,EllipseCurve:()=>wu,EqualDepth:()=>X,EqualStencilFunc:()=>tn,EquirectangularReflectionMapping:()=>ct,EquirectangularRefractionMapping:()=>ht,Euler:()=>Yr,EventDispatcher:()=>vn,ExtrudeBufferGeometry:()=>Ic,ExtrudeGeometry:()=>Ic,FaceColors:()=>Bp,FileLoader:()=>vh,FlatShading:()=>b,Float16BufferAttribute:()=>Ps,Float32Attribute:()=>af,Float32BufferAttribute:()=>$s,Float64Attribute:()=>of,Float64BufferAttribute:()=>Os,FloatType:()=>Nt,Fog:()=>hl,FogExp2:()=>cl,Font:()=>Sf,FontLoader:()=>wf,FramebufferTexture:()=>xu,FrontSide:()=>x,Frustum:()=>Ci,GLBufferAttribute:()=>zd,GLSL1:()=>gn,GLSL3:()=>xn,GreaterDepth:()=>Y,GreaterEqualDepth:()=>K,GreaterEqualStencilFunc:()=>sn,GreaterStencilFunc:()=>nn,GridHelper:()=>lp,Group:()=>nl,HalfFloatType:()=>Dt,HemisphereLight:()=>kh,HemisphereLightHelper:()=>op,HemisphereLightProbe:()=>rd,IcosahedronBufferGeometry:()=>Ac,IcosahedronGeometry:()=>Ac,ImageBitmapLoader:()=>Qh,ImageLoader:()=>Sh,ImageUtils:()=>Yn,ImmediateRenderObject:()=>_f,IncrementStencilOp:()=>qe,IncrementWrapStencilOp:()=>Ke,InstancedBufferAttribute:()=>jl,InstancedBufferGeometry:()=>qh,InstancedInterleavedBuffer:()=>Od,InstancedMesh:()=>Jl,Int16Attribute:()=>ef,Int16BufferAttribute:()=>Ns,Int32Attribute:()=>rf,Int32BufferAttribute:()=>Ls,Int8Attribute:()=>Zp,Int8BufferAttribute:()=>Cs,IntType:()=>At,InterleavedBuffer:()=>pl,InterleavedBufferAttribute:()=>ml,Interpolant:()=>th,InterpolateDiscrete:()=>Te,InterpolateLinear:()=>Me,InterpolateSmooth:()=>Ee,InvertStencilOp:()=>Je,JSONLoader:()=>gf,KeepStencilOp:()=>He,KeyframeTrack:()=>sh,LOD:()=>Ll,LatheBufferGeometry:()=>Wu,LatheGeometry:()=>Wu,Layers:()=>Jr,LensFlare:()=>yf,LessDepth:()=>j,LessEqualDepth:()=>q,LessEqualStencilFunc:()=>en,LessStencilFunc:()=>Qe,Light:()=>Eh,LightProbe:()=>Gh,Line:()=>su,Line3:()=>Kd,LineBasicMaterial:()=>Zl,LineCurve:()=>Lu,LineCurve3:()=>Fu,LineDashedMaterial:()=>Jc,LineLoop:()=>lu,LinePieces:()=>Op,LineSegments:()=>ou,LineStrip:()=>$p,LinearEncoding:()=>Fe,LinearFilter:()=>wt,LinearInterpolant:()=>nh,LinearMipMapLinearFilter:()=>Mt,LinearMipMapNearestFilter:()=>_t,LinearMipmapLinearFilter:()=>Tt,LinearMipmapNearestFilter:()=>St,LinearSRGBColorSpace:()=>Ve,LinearToneMapping:()=>nt,Loader:()=>xh,LoaderUtils:()=>jh,LoadingManager:()=>mh,LoopOnce:()=>we,LoopPingPong:()=>_e,LoopRepeat:()=>Se,LuminanceAlphaFormat:()=>Ut,LuminanceFormat:()=>Bt,MOUSE:()=>o,Material:()=>Ts,MaterialLoader:()=>Hh,Math:()=>Rn,MathUtils:()=>Rn,Matrix3:()=>Dn,Matrix4:()=>Br,MaxEquation:()=>N,Mesh:()=>ci,MeshBasicMaterial:()=>Ms,MeshDepthMaterial:()=>Ko,MeshDistanceMaterial:()=>Yo,MeshFaceMaterial:()=>Wp,MeshLambertMaterial:()=>Kc,MeshMatcapMaterial:()=>Yc,MeshNormalMaterial:()=>Xc,MeshPhongMaterial:()=>jc,MeshPhysicalMaterial:()=>Hc,MeshStandardMaterial:()=>Gc,MeshToonMaterial:()=>qc,MinEquation:()=>R,MirroredRepeatWrapping:()=>mt,MixOperation:()=>Q,MultiMaterial:()=>Vp,MultiplyBlending:()=>E,MultiplyOperation:()=>Z,NearestFilter:()=>gt,NearestMipMapLinearFilter:()=>bt,NearestMipMapNearestFilter:()=>yt,NearestMipmapLinearFilter:()=>vt,NearestMipmapNearestFilter:()=>xt,NeverDepth:()=>G,NeverStencilFunc:()=>Ze,NoBlending:()=>S,NoColorSpace:()=>Ue,NoColors:()=>zp,NoToneMapping:()=>et,NormalAnimationBlendMode:()=>Ae,NormalBlending:()=>_,NotEqualDepth:()=>J,NotEqualStencilFunc:()=>rn,NumberKeyframeTrack:()=>oh,Object3D:()=>hs,ObjectLoader:()=>Kh,ObjectSpaceNormalMap:()=>Be,OctahedronBufferGeometry:()=>Rc,OctahedronGeometry:()=>Rc,OneFactor:()=>L,OneMinusDstAlphaFactor:()=>B,OneMinusDstColorFactor:()=>W,OneMinusSrcAlphaFactor:()=>O,OneMinusSrcColorFactor:()=>P,OrthographicCamera:()=>Wi,PCFShadowMap:()=>f,PCFSoftShadowMap:()=>m,PMREMGenerator:()=>Yi,ParametricGeometry:()=>vf,Particle:()=>Hp,ParticleBasicMaterial:()=>Xp,ParticleSystem:()=>jp,ParticleSystemMaterial:()=>Kp,Path:()=>Uu,PerspectiveCamera:()=>yi,Plane:()=>Ei,PlaneBufferGeometry:()=>Ni,PlaneGeometry:()=>Ni,PlaneHelper:()=>wp,PointCloud:()=>Gp,PointCloudMaterial:()=>qp,PointLight:()=>Oh,PointLightHelper:()=>rp,Points:()=>fu,PointsMaterial:()=>uu,PolarGridHelper:()=>up,PolyhedronBufferGeometry:()=>qu,PolyhedronGeometry:()=>qu,PositionalAudio:()=>wd,PropertyBinding:()=>Dd,PropertyMixer:()=>_d,QuadraticBezierCurve:()=>Pu,QuadraticBezierCurve3:()=>$u,Quaternion:()=>lr,QuaternionKeyframeTrack:()=>uh,QuaternionLinearInterpolant:()=>lh,REVISION:()=>a,RGBADepthPacking:()=>Oe,RGBAFormat:()=>zt,RGBAIntegerFormat:()=>Xt,RGBA_ASTC_10x10_Format:()=>xe,RGBA_ASTC_10x5_Format:()=>fe,RGBA_ASTC_10x6_Format:()=>me,RGBA_ASTC_10x8_Format:()=>ge,RGBA_ASTC_12x10_Format:()=>ye,RGBA_ASTC_12x12_Format:()=>ve,RGBA_ASTC_4x4_Format:()=>ae,RGBA_ASTC_5x4_Format:()=>oe,RGBA_ASTC_5x5_Format:()=>le,RGBA_ASTC_6x5_Format:()=>ue,RGBA_ASTC_6x6_Format:()=>ce,RGBA_ASTC_8x5_Format:()=>he,RGBA_ASTC_8x6_Format:()=>de,RGBA_ASTC_8x8_Format:()=>pe,RGBA_BPTC_Format:()=>be,RGBA_ETC2_EAC_Format:()=>ie,RGBA_PVRTC_2BPPV1_Format:()=>ne,RGBA_PVRTC_4BPPV1_Format:()=>ee,RGBA_S3TC_DXT1_Format:()=>Yt,RGBA_S3TC_DXT3_Format:()=>Jt,RGBA_S3TC_DXT5_Format:()=>Zt,RGBFormat:()=>Ot,RGB_ETC1_Format:()=>re,RGB_ETC2_Format:()=>se,RGB_PVRTC_2BPPV1_Format:()=>te,RGB_PVRTC_4BPPV1_Format:()=>Qt,RGB_S3TC_DXT1_Format:()=>Kt,RGFormat:()=>jt,RGIntegerFormat:()=>qt,RawShaderMaterial:()=>Vc,Ray:()=>zr,Raycaster:()=>Bd,RectAreaLight:()=>Wh,RedFormat:()=>Gt,RedIntegerFormat:()=>Ht,ReinhardToneMapping:()=>rt,RepeatWrapping:()=>pt,ReplaceStencilOp:()=>je,ReverseSubtractEquation:()=>A,RingBufferGeometry:()=>Nc,RingGeometry:()=>Nc,SRGBColorSpace:()=>We,Scene:()=>dl,SceneUtils:()=>xf,ShaderChunk:()=>Di,ShaderLib:()=>Fi,ShaderMaterial:()=>gi,ShadowMaterial:()=>Wc,Shape:()=>tc,ShapeBufferGeometry:()=>Dc,ShapeGeometry:()=>Dc,ShapePath:()=>kp,ShapeUtils:()=>Mc,ShortType:()=>It,Skeleton:()=>Hl,SkeletonHelper:()=>ep,SkinnedMesh:()=>Bl,SmoothShading:()=>w,Source:()=>Jn,Sphere:()=>Rr,SphereBufferGeometry:()=>Lc,SphereGeometry:()=>Lc,Spherical:()=>Vd,SphericalHarmonics3:()=>Vh,SplineCurve:()=>Ou,SpotLight:()=>Dh,SpotLightHelper:()=>Jd,Sprite:()=>Al,SpriteMaterial:()=>gl,SrcAlphaFactor:()=>$,SrcAlphaSaturateFactor:()=>V,SrcColorFactor:()=>F,StaticCopyUsage:()=>pn,StaticDrawUsage:()=>on,StaticReadUsage:()=>cn,StereoCamera:()=>ld,StreamCopyUsage:()=>mn,StreamDrawUsage:()=>un,StreamReadUsage:()=>dn,StringKeyframeTrack:()=>ch,SubtractEquation:()=>C,SubtractiveBlending:()=>M,TOUCH:()=>l,TangentSpaceNormalMap:()=>ze,TetrahedronBufferGeometry:()=>Fc,TetrahedronGeometry:()=>Fc,TextGeometry:()=>bf,Texture:()=>tr,TextureLoader:()=>Mh,TorusBufferGeometry:()=>Pc,TorusGeometry:()=>Pc,TorusKnotBufferGeometry:()=>$c,TorusKnotGeometry:()=>$c,Triangle:()=>Ss,TriangleFanDrawMode:()=>Le,TriangleStripDrawMode:()=>De,TrianglesDrawMode:()=>Ne,TubeBufferGeometry:()=>Oc,TubeGeometry:()=>Oc,UVMapping:()=>ot,Uint16Attribute:()=>nf,Uint16BufferAttribute:()=>Ds,Uint32Attribute:()=>sf,Uint32BufferAttribute:()=>Fs,Uint8Attribute:()=>Qp,Uint8BufferAttribute:()=>As,Uint8ClampedAttribute:()=>tf,Uint8ClampedBufferAttribute:()=>Rs,Uniform:()=>$d,UniformsLib:()=>Li,UniformsUtils:()=>mi,UnsignedByteType:()=>Et,UnsignedInt248Type:()=>Pt,UnsignedIntType:()=>Rt,UnsignedShort4444Type:()=>Lt,UnsignedShort5551Type:()=>Ft,UnsignedShortType:()=>Ct,VSMShadowMap:()=>g,Vector2:()=>Nn,Vector3:()=>ur,Vector4:()=>er,VectorKeyframeTrack:()=>hh,Vertex:()=>Yp,VertexColors:()=>Up,VideoTexture:()=>gu,WebGL1Renderer:()=>ul,WebGL3DRenderTarget:()=>ar,WebGLArrayRenderTarget:()=>sr,WebGLCubeRenderTarget:()=>Si,WebGLMultipleRenderTargets:()=>or,WebGLMultisampleRenderTarget:()=>Tf,WebGLRenderTarget:()=>nr,WebGLRenderTargetCube:()=>ff,WebGLRenderer:()=>ll,WebGLUtils:()=>tl,WireframeGeometry:()=>zc,WireframeHelper:()=>hf,WrapAroundEnding:()=>Ce,XHRLoader:()=>df,ZeroCurvatureEnding:()=>ke,ZeroFactor:()=>D,ZeroSlopeEnding:()=>Ie,ZeroStencilOp:()=>Ge,_SRGBAFormat:()=>yn,sRGBEncoding:()=>Pe});var e={};n.r(e),n.d(e,{assertParamsValid:()=>Ub,computeFlatOffset:()=>tw,computeOutShape:()=>Vb,getNormalizedAxes:()=>qb,isSliceContinous:()=>Qb,maskToAxes:()=>Wb,parseSliceParams:()=>ew,sliceInfo:()=>nw,startForAxis:()=>Jb,startIndicesWithElidedDims:()=>Xb,stopForAxis:()=>Zb,stopIndicesWithElidedDims:()=>Kb,stridesForAxis:()=>Yb,stridesWithElidedDims:()=>Gb});var r={};n.r(r),n.d(r,{collectGatherOpShapeInfo:()=>BM,computeOutShape:()=>zM,segOpComputeOptimalWindowSize:()=>OM});var s={};n.r(s),n.d(s,{ERF_A1:()=>iM,ERF_A2:()=>aM,ERF_A3:()=>oM,ERF_A4:()=>lM,ERF_A5:()=>uM,ERF_P:()=>sM,PARALLELIZE_THRESHOLD:()=>GT,SELU_SCALE:()=>rM,SELU_SCALEALPHA:()=>nM,applyActivation:()=>P_,assertAndGetBroadcastShape:()=>Bb,assertAxesAreInnerMostDims:()=>FS,assertParamsConsistent:()=>WT,assignToTypedArray:()=>mM,axesAreInnerMostDims:()=>RS,calculateShapes:()=>eM,checkEinsumDimSizes:()=>wM,checkPadOnDimRoundingMode:()=>Fw,combineLocations:()=>NS,complexWithEvenIndex:()=>dM,complexWithOddIndex:()=>pM,computeConv2DInfo:()=>Mw,computeConv3DInfo:()=>Ew,computeDefaultPad:()=>kw,computeDilation2DInfo:()=>Sw,computeOptimalWindowSize:()=>HT,computeOutAndReduceShapes:()=>DS,computeOutShape:()=>VT,computePool2DInfo:()=>_w,computePool3DInfo:()=>Tw,convertConv2DDataFormat:()=>Lw,decodeEinsumEquation:()=>vM,eitherStridesOrDilationsAreOne:()=>Dw,expandShapeToKeepDim:()=>LS,exponent:()=>xM,exponents:()=>gM,fromStringArrayToUint8:()=>WM,fromUint8ToStringArray:()=>UM,getAxesPermutation:()=>PS,getBroadcastDims:()=>Ob,getComplexWithIndex:()=>fM,getEinsumComputePath:()=>SM,getEinsumPermutation:()=>bM,getFusedBiasGradient:()=>F_,getFusedDyActivation:()=>L_,getImageCenter:()=>jT,getInnerMostAxes:()=>OS,getPermuted:()=>XT,getReductionAxes:()=>zb,getReshaped:()=>qT,getReshapedPermuted:()=>KT,getSliceBeginCoords:()=>YT,getSliceSize:()=>JT,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>EM,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>kM,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>IM,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>RM,getSparseReshapeInputOutputMismatchErrorMessage:()=>DM,getSparseReshapeInputOutputMultipleErrorMessage:()=>NM,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>CM,getSparseReshapeNegativeOutputDimErrorMessage:()=>AM,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>$M,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>LM,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>FM,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>PM,getUndoAxesPermutation:()=>$S,isIdentityPermutation:()=>_M,log:()=>Ry,mergeRealAndImagArrays:()=>cM,prepareAndValidate:()=>ZT,prepareSplitSize:()=>MM,segment_util:()=>r,shouldFuse:()=>$_,slice_util:()=>e,splitRealAndImagArrays:()=>hM,tupleValuesAreOne:()=>Nw,upcastType:()=>Ev,validateInput:()=>tM,validateUpdateShape:()=>QT,warn:()=>Ay});var i={};n.r(i),n.d(i,{addImpl:()=>nF,bincountImpl:()=>XF,bincountReduceImpl:()=>KF,ceilImpl:()=>ZF,concatImpl:()=>sP,equalImpl:()=>UP,expImpl:()=>ZP,expm1Impl:()=>r$,floorImpl:()=>b$,gatherNdImpl:()=>I$,gatherV2Impl:()=>A$,greaterEqualImpl:()=>F$,greaterImpl:()=>N$,lessEqualImpl:()=>X$,lessImpl:()=>H$,linSpaceImpl:()=>J$,logImpl:()=>Q$,maxImpl:()=>fO,maximumImpl:()=>xO,minimumImpl:()=>kO,multiplyImpl:()=>DP,negImpl:()=>OO,notEqualImpl:()=>jO,prodImpl:()=>iz,rangeImpl:()=>oz,rsqrtImpl:()=>vz,scatterImpl:()=>Sz,sigmoidImpl:()=>VL,simpleAbsImpl:()=>hF,sliceImpl:()=>GF,sparseFillEmptyRowsImpl:()=>Wz,sparseReshapeImpl:()=>Gz,sparseSegmentReductionImpl:()=>jz,sqrtImpl:()=>Jz,squaredDifferenceImpl:()=>eB,stridedSliceImpl:()=>aB,stringNGramsImpl:()=>uB,stringSplitImpl:()=>dB,stringToHashBucketFastImpl:()=>fB,subImpl:()=>u$,tileImpl:()=>vB,topKImpl:()=>SB,transposeImpl:()=>yF,uniqueImpl:()=>IB});const a="140",o={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},l={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},u=0,c=1,h=2,d=3,p=0,f=1,m=2,g=3,x=0,y=1,v=2,b=1,w=2,S=0,_=1,T=2,M=3,E=4,k=5,I=100,C=101,A=102,R=103,N=104,D=200,L=201,F=202,P=203,$=204,O=205,z=206,B=207,U=208,W=209,V=210,G=0,H=1,j=2,q=3,X=4,K=5,Y=6,J=7,Z=0,Q=1,tt=2,et=0,nt=1,rt=2,st=3,it=4,at=5,ot=300,lt=301,ut=302,ct=303,ht=304,dt=306,pt=1e3,ft=1001,mt=1002,gt=1003,xt=1004,yt=1004,vt=1005,bt=1005,wt=1006,St=1007,_t=1007,Tt=1008,Mt=1008,Et=1009,kt=1010,It=1011,Ct=1012,At=1013,Rt=1014,Nt=1015,Dt=1016,Lt=1017,Ft=1018,Pt=1020,$t=1021,Ot=1022,zt=1023,Bt=1024,Ut=1025,Wt=1026,Vt=1027,Gt=1028,Ht=1029,jt=1030,qt=1031,Xt=1033,Kt=33776,Yt=33777,Jt=33778,Zt=33779,Qt=35840,te=35841,ee=35842,ne=35843,re=36196,se=37492,ie=37496,ae=37808,oe=37809,le=37810,ue=37811,ce=37812,he=37813,de=37814,pe=37815,fe=37816,me=37817,ge=37818,xe=37819,ye=37820,ve=37821,be=36492,we=2200,Se=2201,_e=2202,Te=2300,Me=2301,Ee=2302,ke=2400,Ie=2401,Ce=2402,Ae=2500,Re=2501,Ne=0,De=1,Le=2,Fe=3e3,Pe=3001,$e=3200,Oe=3201,ze=0,Be=1,Ue="",We="srgb",Ve="srgb-linear",Ge=0,He=7680,je=7681,qe=7682,Xe=7683,Ke=34055,Ye=34056,Je=5386,Ze=512,Qe=513,tn=514,en=515,nn=516,rn=517,sn=518,an=519,on=35044,ln=35048,un=35040,cn=35045,hn=35049,dn=35041,pn=35046,fn=35050,mn=35042,gn="100",xn="300 es",yn=1035;class vn{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}hasEventListener(t,e){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[t]&&-1!==n[t].indexOf(e)}removeEventListener(t,e){if(void 0===this._listeners)return;const n=this._listeners[t];if(void 0!==n){const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}dispatchEvent(t){if(void 0===this._listeners)return;const e=this._listeners[t.type];if(void 0!==e){t.target=this;const n=e.slice(0);for(let e=0,r=n.length;e<r;e++)n[e].call(this,t);t.target=null}}}const bn=[];for(let t=0;t<256;t++)bn[t]=(t<16?"0":"")+t.toString(16);let wn=1234567;const Sn=Math.PI/180,_n=180/Math.PI;function Tn(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(bn[255&t]+bn[t>>8&255]+bn[t>>16&255]+bn[t>>24&255]+"-"+bn[255&e]+bn[e>>8&255]+"-"+bn[e>>16&15|64]+bn[e>>24&255]+"-"+bn[63&n|128]+bn[n>>8&255]+"-"+bn[n>>16&255]+bn[n>>24&255]+bn[255&r]+bn[r>>8&255]+bn[r>>16&255]+bn[r>>24&255]).toLowerCase()}function Mn(t,e,n){return Math.max(e,Math.min(n,t))}function En(t,e){return(t%e+e)%e}function kn(t,e,n){return(1-n)*t+n*e}function In(t){return 0==(t&t-1)&&0!==t}function Cn(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function An(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}var Rn=Object.freeze({__proto__:null,DEG2RAD:Sn,RAD2DEG:_n,generateUUID:Tn,clamp:Mn,euclideanModulo:En,mapLinear:function(t,e,n,r,s){return r+(t-e)*(s-r)/(n-e)},inverseLerp:function(t,e,n){return t!==e?(n-t)/(e-t):0},lerp:kn,damp:function(t,e,n,r){return kn(t,e,1-Math.exp(-n*r))},pingpong:function(t,e=1){return e-Math.abs(En(t,2*e)-e)},smoothstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*(3-2*t)},smootherstep:function(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},seededRandom:function(t){void 0!==t&&(wn=t);let e=wn+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},degToRad:function(t){return t*Sn},radToDeg:function(t){return t*_n},isPowerOfTwo:In,ceilPowerOfTwo:Cn,floorPowerOfTwo:An,setQuaternionFromProperEuler:function(t,e,n,r,s){const i=Math.cos,a=Math.sin,o=i(n/2),l=a(n/2),u=i((e+r)/2),c=a((e+r)/2),h=i((e-r)/2),d=a((e-r)/2),p=i((r-e)/2),f=a((r-e)/2);switch(s){case"XYX":t.set(o*c,l*h,l*d,o*u);break;case"YZY":t.set(l*d,o*c,l*h,o*u);break;case"ZXZ":t.set(l*h,l*d,o*c,o*u);break;case"XZX":t.set(o*c,l*f,l*p,o*u);break;case"YXY":t.set(l*p,o*c,l*f,o*u);break;case"ZYZ":t.set(l*f,l*p,o*c,o*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}},normalize:function(t,e){switch(e.constructor){case Float32Array:return t;case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}},denormalize:function(t,e){switch(e.constructor){case Float32Array:return t;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}});class Nn{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),s=this.x-t.x,i=this.y-t.y;return this.x=s*n-i*r+t.x,this.y=s*r+i*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}Nn.prototype.isVector2=!0;class Dn{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,i,a,o,l){const u=this.elements;return u[0]=t,u[1]=r,u[2]=a,u[3]=e,u[4]=s,u[5]=o,u[6]=n,u[7]=i,u[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,i=n[0],a=n[3],o=n[6],l=n[1],u=n[4],c=n[7],h=n[2],d=n[5],p=n[8],f=r[0],m=r[3],g=r[6],x=r[1],y=r[4],v=r[7],b=r[2],w=r[5],S=r[8];return s[0]=i*f+a*x+o*b,s[3]=i*m+a*y+o*w,s[6]=i*g+a*v+o*S,s[1]=l*f+u*x+c*b,s[4]=l*m+u*y+c*w,s[7]=l*g+u*v+c*S,s[2]=h*f+d*x+p*b,s[5]=h*m+d*y+p*w,s[8]=h*g+d*v+p*S,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],i=t[4],a=t[5],o=t[6],l=t[7],u=t[8];return e*i*u-e*a*l-n*s*u+n*a*o+r*s*l-r*i*o}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],i=t[4],a=t[5],o=t[6],l=t[7],u=t[8],c=u*i-a*l,h=a*o-u*s,d=l*s-i*o,p=e*c+n*h+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const f=1/p;return t[0]=c*f,t[1]=(r*l-u*n)*f,t[2]=(a*n-r*i)*f,t[3]=h*f,t[4]=(u*e-r*o)*f,t[5]=(r*s-a*e)*f,t[6]=d*f,t[7]=(n*o-l*e)*f,t[8]=(i*e-n*s)*f,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,s,i,a){const o=Math.cos(s),l=Math.sin(s);return this.set(n*o,n*l,-n*(o*i+l*a)+i+t,-r*l,r*o,-r*(-l*i+o*a)+a+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),r=this.elements,s=r[0],i=r[3],a=r[6],o=r[1],l=r[4],u=r[7];return r[0]=e*s+n*o,r[3]=e*i+n*l,r[6]=e*a+n*u,r[1]=-n*s+e*o,r[4]=-n*i+e*l,r[7]=-n*a+e*u,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new this.constructor).fromArray(this.elements)}}function Ln(t){for(let e=t.length-1;e>=0;--e)if(t[e]>65535)return!0;return!1}Dn.prototype.isMatrix3=!0;const Fn={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Pn(t,e){return new Fn[t](e)}function $n(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function On(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function zn(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}const Bn={[We]:{[Ve]:On},[Ve]:{[We]:zn}},Un={legacyMode:!0,get workingColorSpace(){return Ve},set workingColorSpace(t){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(t,e,n){if(this.legacyMode||e===n||!e||!n)return t;if(Bn[e]&&void 0!==Bn[e][n]){const r=Bn[e][n];return t.r=r(t.r),t.g=r(t.g),t.b=r(t.b),t}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(t,e){return this.convert(t,this.workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this.workingColorSpace)}},Wn={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Vn={r:0,g:0,b:0},Gn={h:0,s:0,l:0},Hn={h:0,s:0,l:0};function jn(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function qn(t,e){return e.r=t.r,e.g=t.g,e.b=t.b,e}class Xn{constructor(t,e,n){return void 0===e&&void 0===n?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):"number"==typeof t?this.setHex(t):"string"==typeof t&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=We){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,Un.toWorkingColorSpace(this,e),this}setRGB(t,e,n,r=Ve){return this.r=t,this.g=e,this.b=n,Un.toWorkingColorSpace(this,r),this}setHSL(t,e,n,r=Ve){if(t=En(t,1),e=Mn(e,0,1),n=Mn(n,0,1),0===e)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+e):n+e-n*e,s=2*n-r;this.r=jn(s,r,t+1/3),this.g=jn(s,r,t),this.b=jn(s,r,t-1/3)}return Un.toWorkingColorSpace(this,r),this}setStyle(t,e=We){function n(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let t;const s=r[1],i=r[2];switch(s){case"rgb":case"rgba":if(t=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(255,parseInt(t[1],10))/255,this.g=Math.min(255,parseInt(t[2],10))/255,this.b=Math.min(255,parseInt(t[3],10))/255,Un.toWorkingColorSpace(this,e),n(t[4]),this;if(t=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(100,parseInt(t[1],10))/100,this.g=Math.min(100,parseInt(t[2],10))/100,this.b=Math.min(100,parseInt(t[3],10))/100,Un.toWorkingColorSpace(this,e),n(t[4]),this;break;case"hsl":case"hsla":if(t=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)){const r=parseFloat(t[1])/360,s=parseInt(t[2],10)/100,i=parseInt(t[3],10)/100;return n(t[4]),this.setHSL(r,s,i,e)}}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(t)){const t=r[1],n=t.length;if(3===n)return this.r=parseInt(t.charAt(0)+t.charAt(0),16)/255,this.g=parseInt(t.charAt(1)+t.charAt(1),16)/255,this.b=parseInt(t.charAt(2)+t.charAt(2),16)/255,Un.toWorkingColorSpace(this,e),this;if(6===n)return this.r=parseInt(t.charAt(0)+t.charAt(1),16)/255,this.g=parseInt(t.charAt(2)+t.charAt(3),16)/255,this.b=parseInt(t.charAt(4)+t.charAt(5),16)/255,Un.toWorkingColorSpace(this,e),this}return t&&t.length>0?this.setColorName(t,e):this}setColorName(t,e=We){const n=Wn[t.toLowerCase()];return void 0!==n?this.setHex(n,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=On(t.r),this.g=On(t.g),this.b=On(t.b),this}copyLinearToSRGB(t){return this.r=zn(t.r),this.g=zn(t.g),this.b=zn(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=We){return Un.fromWorkingColorSpace(qn(this,Vn),t),Mn(255*Vn.r,0,255)<<16^Mn(255*Vn.g,0,255)<<8^Mn(255*Vn.b,0,255)<<0}getHexString(t=We){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=Ve){Un.fromWorkingColorSpace(qn(this,Vn),e);const n=Vn.r,r=Vn.g,s=Vn.b,i=Math.max(n,r,s),a=Math.min(n,r,s);let o,l;const u=(a+i)/2;if(a===i)o=0,l=0;else{const t=i-a;switch(l=u<=.5?t/(i+a):t/(2-i-a),i){case n:o=(r-s)/t+(r<s?6:0);break;case r:o=(s-n)/t+2;break;case s:o=(n-r)/t+4}o/=6}return t.h=o,t.s=l,t.l=u,t}getRGB(t,e=Ve){return Un.fromWorkingColorSpace(qn(this,Vn),e),t.r=Vn.r,t.g=Vn.g,t.b=Vn.b,t}getStyle(t=We){return Un.fromWorkingColorSpace(qn(this,Vn),t),t!==We?`color(${t} ${Vn.r} ${Vn.g} ${Vn.b})`:`rgb(${255*Vn.r|0},${255*Vn.g|0},${255*Vn.b|0})`}offsetHSL(t,e,n){return this.getHSL(Gn),Gn.h+=t,Gn.s+=e,Gn.l+=n,this.setHSL(Gn.h,Gn.s,Gn.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(Gn),t.getHSL(Hn);const n=kn(Gn.h,Hn.h,e),r=kn(Gn.s,Hn.s,e),s=kn(Gn.l,Hn.l,e);return this.setHSL(n,r,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),!0===t.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let Kn;Xn.NAMES=Wn,Xn.prototype.isColor=!0,Xn.prototype.r=1,Xn.prototype.g=1,Xn.prototype.b=1;class Yn{static getDataURL(t){if(/^data:/i.test(t.src))return t.src;if("undefined"==typeof HTMLCanvasElement)return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{void 0===Kn&&(Kn=$n("canvas")),Kn.width=t.width,Kn.height=t.height;const n=Kn.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Kn}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const e=$n("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");n.drawImage(t,0,0,t.width,t.height);const r=n.getImageData(0,0,t.width,t.height),s=r.data;for(let t=0;t<s.length;t++)s[t]=255*On(s[t]/255);return n.putImageData(r,0,0),e}if(t.data){const e=t.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(255*On(e[t]/255)):e[t]=On(e[t]);return{data:e,width:t.width,height:t.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}class Jn{constructor(t=null){this.uuid=Tn(),this.data=t,this.version=0}set needsUpdate(t){!0===t&&this.version++}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.images[this.uuid])return t.images[this.uuid];const n={uuid:this.uuid,url:""},r=this.data;if(null!==r){let t;if(Array.isArray(r)){t=[];for(let e=0,n=r.length;e<n;e++)r[e].isDataTexture?t.push(Zn(r[e].image)):t.push(Zn(r[e]))}else t=Zn(r);n.url=t}return e||(t.images[this.uuid]=n),n}}function Zn(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap?Yn.getDataURL(t):t.data?{data:Array.prototype.slice.call(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}Jn.prototype.isSource=!0;let Qn=0;class tr extends vn{constructor(t=tr.DEFAULT_IMAGE,e=tr.DEFAULT_MAPPING,n=ft,r=ft,s=wt,i=Tt,a=zt,o=Et,l=1,u=Fe){super(),Object.defineProperty(this,"id",{value:Qn++}),this.uuid=Tn(),this.name="",this.source=new Jn(t),this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=r,this.magFilter=s,this.minFilter=i,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new Nn(0,0),this.repeat=new Nn(1,1),this.center=new Nn(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Dn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(t){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==ot)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case pt:t.x=t.x-Math.floor(t.x);break;case ft:t.x=t.x<0?0:1;break;case mt:1===Math.abs(Math.floor(t.x)%2)?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case pt:t.y=t.y-Math.floor(t.y);break;case ft:t.y=t.y<0?0:1;break;case mt:1===Math.abs(Math.floor(t.y)%2)?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){!0===t&&(this.version++,this.source.needsUpdate=!0)}}tr.DEFAULT_IMAGE=null,tr.DEFAULT_MAPPING=ot,tr.prototype.isTexture=!0;class er{constructor(t=0,e=0,n=0,r=1){this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=this.w,i=t.elements;return this.x=i[0]*e+i[4]*n+i[8]*r+i[12]*s,this.y=i[1]*e+i[5]*n+i[9]*r+i[13]*s,this.z=i[2]*e+i[6]*n+i[10]*r+i[14]*s,this.w=i[3]*e+i[7]*n+i[11]*r+i[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,s;const i=.01,a=.1,o=t.elements,l=o[0],u=o[4],c=o[8],h=o[1],d=o[5],p=o[9],f=o[2],m=o[6],g=o[10];if(Math.abs(u-h)<i&&Math.abs(c-f)<i&&Math.abs(p-m)<i){if(Math.abs(u+h)<a&&Math.abs(c+f)<a&&Math.abs(p+m)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(l+1)/2,o=(d+1)/2,x=(g+1)/2,y=(u+h)/4,v=(c+f)/4,b=(p+m)/4;return t>o&&t>x?t<i?(n=0,r=.707106781,s=.707106781):(n=Math.sqrt(t),r=y/n,s=v/n):o>x?o<i?(n=.707106781,r=0,s=.707106781):(r=Math.sqrt(o),n=y/r,s=b/r):x<i?(n=.707106781,r=.707106781,s=0):(s=Math.sqrt(x),n=v/s,r=b/s),this.set(n,r,s,e),this}let x=Math.sqrt((m-p)*(m-p)+(c-f)*(c-f)+(h-u)*(h-u));return Math.abs(x)<.001&&(x=1),this.x=(m-p)/x,this.y=(c-f)/x,this.z=(h-u)/x,this.w=Math.acos((l+d+g-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}er.prototype.isVector4=!0;class nr extends vn{constructor(t,e,n={}){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new er(0,0,t,e),this.scissorTest=!1,this.viewport=new er(0,0,t,e);const r={width:t,height:e,depth:1};this.texture=new tr(r,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.internalFormat=void 0!==n.internalFormat?n.internalFormat:null,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:wt,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null,this.samples=void 0!==n.samples?n.samples:0}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return(new this.constructor).copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new Jn(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}nr.prototype.isWebGLRenderTarget=!0;class rr extends tr{constructor(t=null,e=1,n=1,r=1){super(null),this.image={data:t,width:e,height:n,depth:r},this.magFilter=gt,this.minFilter=gt,this.wrapR=ft,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}rr.prototype.isDataArrayTexture=!0;class sr extends nr{constructor(t,e,n){super(t,e),this.depth=n,this.texture=new rr(null,t,e,n),this.texture.isRenderTargetTexture=!0}}sr.prototype.isWebGLArrayRenderTarget=!0;class ir extends tr{constructor(t=null,e=1,n=1,r=1){super(null),this.image={data:t,width:e,height:n,depth:r},this.magFilter=gt,this.minFilter=gt,this.wrapR=ft,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}ir.prototype.isData3DTexture=!0;class ar extends nr{constructor(t,e,n){super(t,e),this.depth=n,this.texture=new ir(null,t,e,n),this.texture.isRenderTargetTexture=!0}}ar.prototype.isWebGL3DRenderTarget=!0;class or extends nr{constructor(t,e,n,r={}){super(t,e,r);const s=this.texture;this.texture=[];for(let t=0;t<n;t++)this.texture[t]=s.clone(),this.texture[t].isRenderTargetTexture=!0}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let r=0,s=this.texture.length;r<s;r++)this.texture[r].image.width=t,this.texture[r].image.height=e,this.texture[r].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,null!==t.depthTexture&&(this.depthTexture=t.depthTexture.clone()),this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone(),this.texture[e].isRenderTargetTexture=!0;return this}}or.prototype.isWebGLMultipleRenderTargets=!0;class lr{constructor(t=0,e=0,n=0,r=1){this._x=t,this._y=e,this._z=n,this._w=r}static slerp(t,e,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,r)}static slerpFlat(t,e,n,r,s,i,a){let o=n[r+0],l=n[r+1],u=n[r+2],c=n[r+3];const h=s[i+0],d=s[i+1],p=s[i+2],f=s[i+3];if(0===a)return t[e+0]=o,t[e+1]=l,t[e+2]=u,void(t[e+3]=c);if(1===a)return t[e+0]=h,t[e+1]=d,t[e+2]=p,void(t[e+3]=f);if(c!==f||o!==h||l!==d||u!==p){let t=1-a;const e=o*h+l*d+u*p+c*f,n=e>=0?1:-1,r=1-e*e;if(r>Number.EPSILON){const s=Math.sqrt(r),i=Math.atan2(s,e*n);t=Math.sin(t*i)/s,a=Math.sin(a*i)/s}const s=a*n;if(o=o*t+h*s,l=l*t+d*s,u=u*t+p*s,c=c*t+f*s,t===1-a){const t=1/Math.sqrt(o*o+l*l+u*u+c*c);o*=t,l*=t,u*=t,c*=t}}t[e]=o,t[e+1]=l,t[e+2]=u,t[e+3]=c}static multiplyQuaternionsFlat(t,e,n,r,s,i){const a=n[r],o=n[r+1],l=n[r+2],u=n[r+3],c=s[i],h=s[i+1],d=s[i+2],p=s[i+3];return t[e]=a*p+u*c+o*d-l*h,t[e+1]=o*p+u*h+l*c-a*d,t[e+2]=l*p+u*d+a*h-o*c,t[e+3]=u*p-a*c-o*h-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,r=t._y,s=t._z,i=t._order,a=Math.cos,o=Math.sin,l=a(n/2),u=a(r/2),c=a(s/2),h=o(n/2),d=o(r/2),p=o(s/2);switch(i){case"XYZ":this._x=h*u*c+l*d*p,this._y=l*d*c-h*u*p,this._z=l*u*p+h*d*c,this._w=l*u*c-h*d*p;break;case"YXZ":this._x=h*u*c+l*d*p,this._y=l*d*c-h*u*p,this._z=l*u*p-h*d*c,this._w=l*u*c+h*d*p;break;case"ZXY":this._x=h*u*c-l*d*p,this._y=l*d*c+h*u*p,this._z=l*u*p+h*d*c,this._w=l*u*c-h*d*p;break;case"ZYX":this._x=h*u*c-l*d*p,this._y=l*d*c+h*u*p,this._z=l*u*p-h*d*c,this._w=l*u*c+h*d*p;break;case"YZX":this._x=h*u*c+l*d*p,this._y=l*d*c+h*u*p,this._z=l*u*p-h*d*c,this._w=l*u*c-h*d*p;break;case"XZY":this._x=h*u*c-l*d*p,this._y=l*d*c-h*u*p,this._z=l*u*p+h*d*c,this._w=l*u*c+h*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+i)}return!1!==e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],s=e[8],i=e[1],a=e[5],o=e[9],l=e[2],u=e[6],c=e[10],h=n+a+c;if(h>0){const t=.5/Math.sqrt(h+1);this._w=.25/t,this._x=(u-o)*t,this._y=(s-l)*t,this._z=(i-r)*t}else if(n>a&&n>c){const t=2*Math.sqrt(1+n-a-c);this._w=(u-o)/t,this._x=.25*t,this._y=(r+i)/t,this._z=(s+l)/t}else if(a>c){const t=2*Math.sqrt(1+a-n-c);this._w=(s-l)/t,this._x=(r+i)/t,this._y=.25*t,this._z=(o+u)/t}else{const t=2*Math.sqrt(1+c-n-a);this._w=(i-r)/t,this._x=(s+l)/t,this._y=(o+u)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Mn(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(0===n)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return void 0!==e?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,s=t._z,i=t._w,a=e._x,o=e._y,l=e._z,u=e._w;return this._x=n*u+i*a+r*l-s*o,this._y=r*u+i*o+s*a-n*l,this._z=s*u+i*l+n*o-r*a,this._w=i*u-n*a-r*o-s*l,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const n=this._x,r=this._y,s=this._z,i=this._w;let a=i*t._w+n*t._x+r*t._y+s*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=i,this._x=n,this._y=r,this._z=s,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*i+e*this._w,this._x=t*n+e*this._x,this._y=t*r+e*this._y,this._z=t*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(o),u=Math.atan2(l,a),c=Math.sin((1-e)*u)/l,h=Math.sin(e*u)/l;return this._w=i*c+this._w*h,this._x=n*c+this._x*h,this._y=r*c+this._y*h,this._z=s*c+this._z*h,this._onChangeCallback(),this}slerpQuaternions(t,e,n){return this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(e*Math.cos(r),n*Math.sin(s),n*Math.cos(s),e*Math.sin(r))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}lr.prototype.isQuaternion=!0;class ur{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return void 0===n&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return void 0!==e?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return void 0!==e?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(hr.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(hr.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*r,this.y=s[1]*e+s[4]*n+s[7]*r,this.z=s[2]*e+s[5]*n+s[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=t.elements,i=1/(s[3]*e+s[7]*n+s[11]*r+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*r+s[12])*i,this.y=(s[1]*e+s[5]*n+s[9]*r+s[13])*i,this.z=(s[2]*e+s[6]*n+s[10]*r+s[14])*i,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,s=t.x,i=t.y,a=t.z,o=t.w,l=o*e+i*r-a*n,u=o*n+a*e-s*r,c=o*r+s*n-i*e,h=-s*e-i*n-a*r;return this.x=l*o+h*-s+u*-a-c*-i,this.y=u*o+h*-i+c*-s-l*-a,this.z=c*o+h*-a+l*-i-u*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*r,this.y=s[1]*e+s[5]*n+s[9]*r,this.z=s[2]*e+s[6]*n+s[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return void 0!==e?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,s=t.z,i=e.x,a=e.y,o=e.z;return this.x=r*o-s*a,this.y=s*i-n*o,this.z=n*a-r*i,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return cr.copy(this).projectOnVector(t),this.sub(cr)}reflect(t){return this.sub(cr.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Mn(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}ur.prototype.isVector3=!0;const cr=new ur,hr=new lr;class dr{constructor(t=new ur(1/0,1/0,1/0),e=new ur(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,r=1/0,s=-1/0,i=-1/0,a=-1/0;for(let o=0,l=t.length;o<l;o+=3){const l=t[o],u=t[o+1],c=t[o+2];l<e&&(e=l),u<n&&(n=u),c<r&&(r=c),l>s&&(s=l),u>i&&(i=u),c>a&&(a=c)}return this.min.set(e,n,r),this.max.set(s,i,a),this}setFromBufferAttribute(t){let e=1/0,n=1/0,r=1/0,s=-1/0,i=-1/0,a=-1/0;for(let o=0,l=t.count;o<l;o++){const l=t.getX(o),u=t.getY(o),c=t.getZ(o);l<e&&(e=l),u<n&&(n=u),c<r&&(r=c),l>s&&(s=l),u>i&&(i=u),c>a&&(a=c)}return this.min.set(e,n,r),this.max.set(s,i,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=fr.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const n=t.geometry;if(void 0!==n)if(e&&null!=n.attributes&&void 0!==n.attributes.position){const e=n.attributes.position;for(let n=0,r=e.count;n<r;n++)fr.fromBufferAttribute(e,n).applyMatrix4(t.matrixWorld),this.expandByPoint(fr)}else null===n.boundingBox&&n.computeBoundingBox(),mr.copy(n.boundingBox),mr.applyMatrix4(t.matrixWorld),this.union(mr);const r=t.children;for(let t=0,n=r.length;t<n;t++)this.expandByObject(r[t],e);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,fr),fr.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Sr),_r.subVectors(this.max,Sr),gr.subVectors(t.a,Sr),xr.subVectors(t.b,Sr),yr.subVectors(t.c,Sr),vr.subVectors(xr,gr),br.subVectors(yr,xr),wr.subVectors(gr,yr);let e=[0,-vr.z,vr.y,0,-br.z,br.y,0,-wr.z,wr.y,vr.z,0,-vr.x,br.z,0,-br.x,wr.z,0,-wr.x,-vr.y,vr.x,0,-br.y,br.x,0,-wr.y,wr.x,0];return!!Er(e,gr,xr,yr,_r)&&(e=[1,0,0,0,1,0,0,0,1],!!Er(e,gr,xr,yr,_r)&&(Tr.crossVectors(vr,br),e=[Tr.x,Tr.y,Tr.z],Er(e,gr,xr,yr,_r)))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return fr.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(fr).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(pr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),pr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),pr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),pr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),pr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),pr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),pr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),pr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(pr)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}dr.prototype.isBox3=!0;const pr=[new ur,new ur,new ur,new ur,new ur,new ur,new ur,new ur],fr=new ur,mr=new dr,gr=new ur,xr=new ur,yr=new ur,vr=new ur,br=new ur,wr=new ur,Sr=new ur,_r=new ur,Tr=new ur,Mr=new ur;function Er(t,e,n,r,s){for(let i=0,a=t.length-3;i<=a;i+=3){Mr.fromArray(t,i);const a=s.x*Math.abs(Mr.x)+s.y*Math.abs(Mr.y)+s.z*Math.abs(Mr.z),o=e.dot(Mr),l=n.dot(Mr),u=r.dot(Mr);if(Math.max(-Math.max(o,l,u),Math.min(o,l,u))>a)return!1}return!0}const kr=new dr,Ir=new ur,Cr=new ur,Ar=new ur;class Rr{constructor(t=new ur,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):kr.setFromPoints(t).getCenter(n);let r=0;for(let e=0,s=t.length;e<s;e++)r=Math.max(r,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Ar.subVectors(t,this.center);const e=Ar.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.add(Ar.multiplyScalar(n/t)),this.radius+=n}return this}union(t){return!0===this.center.equals(t.center)?Cr.set(0,0,1).multiplyScalar(t.radius):Cr.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Ir.copy(t.center).add(Cr)),this.expandByPoint(Ir.copy(t.center).sub(Cr)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Nr=new ur,Dr=new ur,Lr=new ur,Fr=new ur,Pr=new ur,$r=new ur,Or=new ur;class zr{constructor(t=new ur,e=new ur(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Nr)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Nr.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Nr.copy(this.direction).multiplyScalar(e).add(this.origin),Nr.distanceToSquared(t))}distanceSqToSegment(t,e,n,r){Dr.copy(t).add(e).multiplyScalar(.5),Lr.copy(e).sub(t).normalize(),Fr.copy(this.origin).sub(Dr);const s=.5*t.distanceTo(e),i=-this.direction.dot(Lr),a=Fr.dot(this.direction),o=-Fr.dot(Lr),l=Fr.lengthSq(),u=Math.abs(1-i*i);let c,h,d,p;if(u>0)if(c=i*o-a,h=i*a-o,p=s*u,c>=0)if(h>=-p)if(h<=p){const t=1/u;c*=t,h*=t,d=c*(c+i*h+2*a)+h*(i*c+h+2*o)+l}else h=s,c=Math.max(0,-(i*h+a)),d=-c*c+h*(h+2*o)+l;else h=-s,c=Math.max(0,-(i*h+a)),d=-c*c+h*(h+2*o)+l;else h<=-p?(c=Math.max(0,-(-i*s+a)),h=c>0?-s:Math.min(Math.max(-s,-o),s),d=-c*c+h*(h+2*o)+l):h<=p?(c=0,h=Math.min(Math.max(-s,-o),s),d=h*(h+2*o)+l):(c=Math.max(0,-(i*s+a)),h=c>0?s:Math.min(Math.max(-s,-o),s),d=-c*c+h*(h+2*o)+l);else h=i>0?-s:s,c=Math.max(0,-(i*h+a)),d=-c*c+h*(h+2*o)+l;return n&&n.copy(this.direction).multiplyScalar(c).add(this.origin),r&&r.copy(Lr).multiplyScalar(h).add(Dr),d}intersectSphere(t,e){Nr.subVectors(t.center,this.origin);const n=Nr.dot(this.direction),r=Nr.dot(Nr)-n*n,s=t.radius*t.radius;if(r>s)return null;const i=Math.sqrt(s-r),a=n-i,o=n+i;return a<0&&o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return 0===e||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,r,s,i,a,o;const l=1/this.direction.x,u=1/this.direction.y,c=1/this.direction.z,h=this.origin;return l>=0?(n=(t.min.x-h.x)*l,r=(t.max.x-h.x)*l):(n=(t.max.x-h.x)*l,r=(t.min.x-h.x)*l),u>=0?(s=(t.min.y-h.y)*u,i=(t.max.y-h.y)*u):(s=(t.max.y-h.y)*u,i=(t.min.y-h.y)*u),n>i||s>r?null:((s>n||n!=n)&&(n=s),(i<r||r!=r)&&(r=i),c>=0?(a=(t.min.z-h.z)*c,o=(t.max.z-h.z)*c):(a=(t.max.z-h.z)*c,o=(t.min.z-h.z)*c),n>o||a>r?null:((a>n||n!=n)&&(n=a),(o<r||r!=r)&&(r=o),r<0?null:this.at(n>=0?n:r,e)))}intersectsBox(t){return null!==this.intersectBox(t,Nr)}intersectTriangle(t,e,n,r,s){Pr.subVectors(e,t),$r.subVectors(n,t),Or.crossVectors(Pr,$r);let i,a=this.direction.dot(Or);if(a>0){if(r)return null;i=1}else{if(!(a<0))return null;i=-1,a=-a}Fr.subVectors(this.origin,t);const o=i*this.direction.dot($r.crossVectors(Fr,$r));if(o<0)return null;const l=i*this.direction.dot(Pr.cross(Fr));if(l<0)return null;if(o+l>a)return null;const u=-i*Fr.dot(Or);return u<0?null:this.at(u/a,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Br{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,i,a,o,l,u,c,h,d,p,f,m){const g=this.elements;return g[0]=t,g[4]=e,g[8]=n,g[12]=r,g[1]=s,g[5]=i,g[9]=a,g[13]=o,g[2]=l,g[6]=u,g[10]=c,g[14]=h,g[3]=d,g[7]=p,g[11]=f,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Br).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,r=1/Ur.setFromMatrixColumn(t,0).length(),s=1/Ur.setFromMatrixColumn(t,1).length(),i=1/Ur.setFromMatrixColumn(t,2).length();return e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*i,e[9]=n[9]*i,e[10]=n[10]*i,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,r=t.y,s=t.z,i=Math.cos(n),a=Math.sin(n),o=Math.cos(r),l=Math.sin(r),u=Math.cos(s),c=Math.sin(s);if("XYZ"===t.order){const t=i*u,n=i*c,r=a*u,s=a*c;e[0]=o*u,e[4]=-o*c,e[8]=l,e[1]=n+r*l,e[5]=t-s*l,e[9]=-a*o,e[2]=s-t*l,e[6]=r+n*l,e[10]=i*o}else if("YXZ"===t.order){const t=o*u,n=o*c,r=l*u,s=l*c;e[0]=t+s*a,e[4]=r*a-n,e[8]=i*l,e[1]=i*c,e[5]=i*u,e[9]=-a,e[2]=n*a-r,e[6]=s+t*a,e[10]=i*o}else if("ZXY"===t.order){const t=o*u,n=o*c,r=l*u,s=l*c;e[0]=t-s*a,e[4]=-i*c,e[8]=r+n*a,e[1]=n+r*a,e[5]=i*u,e[9]=s-t*a,e[2]=-i*l,e[6]=a,e[10]=i*o}else if("ZYX"===t.order){const t=i*u,n=i*c,r=a*u,s=a*c;e[0]=o*u,e[4]=r*l-n,e[8]=t*l+s,e[1]=o*c,e[5]=s*l+t,e[9]=n*l-r,e[2]=-l,e[6]=a*o,e[10]=i*o}else if("YZX"===t.order){const t=i*o,n=i*l,r=a*o,s=a*l;e[0]=o*u,e[4]=s-t*c,e[8]=r*c+n,e[1]=c,e[5]=i*u,e[9]=-a*u,e[2]=-l*u,e[6]=n*c+r,e[10]=t-s*c}else if("XZY"===t.order){const t=i*o,n=i*l,r=a*o,s=a*l;e[0]=o*u,e[4]=-c,e[8]=l*u,e[1]=t*c+s,e[5]=i*u,e[9]=n*c-r,e[2]=r*c-n,e[6]=a*u,e[10]=s*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Vr,t,Gr)}lookAt(t,e,n){const r=this.elements;return qr.subVectors(t,e),0===qr.lengthSq()&&(qr.z=1),qr.normalize(),Hr.crossVectors(n,qr),0===Hr.lengthSq()&&(1===Math.abs(n.z)?qr.x+=1e-4:qr.z+=1e-4,qr.normalize(),Hr.crossVectors(n,qr)),Hr.normalize(),jr.crossVectors(qr,Hr),r[0]=Hr.x,r[4]=jr.x,r[8]=qr.x,r[1]=Hr.y,r[5]=jr.y,r[9]=qr.y,r[2]=Hr.z,r[6]=jr.z,r[10]=qr.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,i=n[0],a=n[4],o=n[8],l=n[12],u=n[1],c=n[5],h=n[9],d=n[13],p=n[2],f=n[6],m=n[10],g=n[14],x=n[3],y=n[7],v=n[11],b=n[15],w=r[0],S=r[4],_=r[8],T=r[12],M=r[1],E=r[5],k=r[9],I=r[13],C=r[2],A=r[6],R=r[10],N=r[14],D=r[3],L=r[7],F=r[11],P=r[15];return s[0]=i*w+a*M+o*C+l*D,s[4]=i*S+a*E+o*A+l*L,s[8]=i*_+a*k+o*R+l*F,s[12]=i*T+a*I+o*N+l*P,s[1]=u*w+c*M+h*C+d*D,s[5]=u*S+c*E+h*A+d*L,s[9]=u*_+c*k+h*R+d*F,s[13]=u*T+c*I+h*N+d*P,s[2]=p*w+f*M+m*C+g*D,s[6]=p*S+f*E+m*A+g*L,s[10]=p*_+f*k+m*R+g*F,s[14]=p*T+f*I+m*N+g*P,s[3]=x*w+y*M+v*C+b*D,s[7]=x*S+y*E+v*A+b*L,s[11]=x*_+y*k+v*R+b*F,s[15]=x*T+y*I+v*N+b*P,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],r=t[8],s=t[12],i=t[1],a=t[5],o=t[9],l=t[13],u=t[2],c=t[6],h=t[10],d=t[14];return t[3]*(+s*o*c-r*l*c-s*a*h+n*l*h+r*a*d-n*o*d)+t[7]*(+e*o*d-e*l*h+s*i*h-r*i*d+r*l*u-s*o*u)+t[11]*(+e*l*c-e*a*d-s*i*c+n*i*d+s*a*u-n*l*u)+t[15]*(-r*a*u-e*o*c+e*a*h+r*i*c-n*i*h+n*o*u)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],i=t[4],a=t[5],o=t[6],l=t[7],u=t[8],c=t[9],h=t[10],d=t[11],p=t[12],f=t[13],m=t[14],g=t[15],x=c*m*l-f*h*l+f*o*d-a*m*d-c*o*g+a*h*g,y=p*h*l-u*m*l-p*o*d+i*m*d+u*o*g-i*h*g,v=u*f*l-p*c*l+p*a*d-i*f*d-u*a*g+i*c*g,b=p*c*o-u*f*o-p*a*h+i*f*h+u*a*m-i*c*m,w=e*x+n*y+r*v+s*b;if(0===w)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/w;return t[0]=x*S,t[1]=(f*h*s-c*m*s-f*r*d+n*m*d+c*r*g-n*h*g)*S,t[2]=(a*m*s-f*o*s+f*r*l-n*m*l-a*r*g+n*o*g)*S,t[3]=(c*o*s-a*h*s-c*r*l+n*h*l+a*r*d-n*o*d)*S,t[4]=y*S,t[5]=(u*m*s-p*h*s+p*r*d-e*m*d-u*r*g+e*h*g)*S,t[6]=(p*o*s-i*m*s-p*r*l+e*m*l+i*r*g-e*o*g)*S,t[7]=(i*h*s-u*o*s+u*r*l-e*h*l-i*r*d+e*o*d)*S,t[8]=v*S,t[9]=(p*c*s-u*f*s-p*n*d+e*f*d+u*n*g-e*c*g)*S,t[10]=(i*f*s-p*a*s+p*n*l-e*f*l-i*n*g+e*a*g)*S,t[11]=(u*a*s-i*c*s-u*n*l+e*c*l+i*n*d-e*a*d)*S,t[12]=b*S,t[13]=(u*f*r-p*c*r+p*n*h-e*f*h-u*n*m+e*c*m)*S,t[14]=(p*a*r-i*f*r-p*n*o+e*f*o+i*n*m-e*a*m)*S,t[15]=(i*c*r-u*a*r+u*n*o-e*c*o-i*n*h+e*a*h)*S,this}scale(t){const e=this.elements,n=t.x,r=t.y,s=t.z;return e[0]*=n,e[4]*=r,e[8]*=s,e[1]*=n,e[5]*=r,e[9]*=s,e[2]*=n,e[6]*=r,e[10]*=s,e[3]*=n,e[7]*=r,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,r))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),r=Math.sin(e),s=1-n,i=t.x,a=t.y,o=t.z,l=s*i,u=s*a;return this.set(l*i+n,l*a-r*o,l*o+r*a,0,l*a+r*o,u*a+n,u*o-r*i,0,l*o-r*a,u*o+r*i,s*o*o+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,r,s,i){return this.set(1,n,s,0,t,1,i,0,e,r,1,0,0,0,0,1),this}compose(t,e,n){const r=this.elements,s=e._x,i=e._y,a=e._z,o=e._w,l=s+s,u=i+i,c=a+a,h=s*l,d=s*u,p=s*c,f=i*u,m=i*c,g=a*c,x=o*l,y=o*u,v=o*c,b=n.x,w=n.y,S=n.z;return r[0]=(1-(f+g))*b,r[1]=(d+v)*b,r[2]=(p-y)*b,r[3]=0,r[4]=(d-v)*w,r[5]=(1-(h+g))*w,r[6]=(m+x)*w,r[7]=0,r[8]=(p+y)*S,r[9]=(m-x)*S,r[10]=(1-(h+f))*S,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,n){const r=this.elements;let s=Ur.set(r[0],r[1],r[2]).length();const i=Ur.set(r[4],r[5],r[6]).length(),a=Ur.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),t.x=r[12],t.y=r[13],t.z=r[14],Wr.copy(this);const o=1/s,l=1/i,u=1/a;return Wr.elements[0]*=o,Wr.elements[1]*=o,Wr.elements[2]*=o,Wr.elements[4]*=l,Wr.elements[5]*=l,Wr.elements[6]*=l,Wr.elements[8]*=u,Wr.elements[9]*=u,Wr.elements[10]*=u,e.setFromRotationMatrix(Wr),n.x=s,n.y=i,n.z=a,this}makePerspective(t,e,n,r,s,i){void 0===i&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,o=2*s/(e-t),l=2*s/(n-r),u=(e+t)/(e-t),c=(n+r)/(n-r),h=-(i+s)/(i-s),d=-2*i*s/(i-s);return a[0]=o,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=l,a[9]=c,a[13]=0,a[2]=0,a[6]=0,a[10]=h,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,r,s,i){const a=this.elements,o=1/(e-t),l=1/(n-r),u=1/(i-s),c=(e+t)*o,h=(n+r)*l,d=(i+s)*u;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-c,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-h,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}Br.prototype.isMatrix4=!0;const Ur=new ur,Wr=new Br,Vr=new ur(0,0,0),Gr=new ur(1,1,1),Hr=new ur,jr=new ur,qr=new ur,Xr=new Br,Kr=new lr;class Yr{constructor(t=0,e=0,n=0,r=Yr.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,r=this._order){return this._x=t,this._y=e,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const r=t.elements,s=r[0],i=r[4],a=r[8],o=r[1],l=r[5],u=r[9],c=r[2],h=r[6],d=r[10];switch(e){case"XYZ":this._y=Math.asin(Mn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,d),this._z=Math.atan2(-i,s)):(this._x=Math.atan2(h,l),this._z=0);break;case"YXZ":this._x=Math.asin(-Mn(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-c,s),this._z=0);break;case"ZXY":this._x=Math.asin(Mn(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-c,d),this._z=Math.atan2(-i,l)):(this._y=0,this._z=Math.atan2(o,s));break;case"ZYX":this._y=Math.asin(-Mn(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(h,d),this._z=Math.atan2(o,s)):(this._x=0,this._z=Math.atan2(-i,l));break;case"YZX":this._z=Math.asin(Mn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-u,l),this._y=Math.atan2(-c,s)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-Mn(i,-1,1)),Math.abs(i)<.9999999?(this._x=Math.atan2(h,l),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-u,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===n&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Xr.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Xr,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Kr.setFromEuler(this),this.setFromQuaternion(Kr,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Yr.prototype.isEuler=!0,Yr.DefaultOrder="XYZ",Yr.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Jr{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}isEnabled(t){return 0!=(this.mask&(1<<t|0))}}let Zr=0;const Qr=new ur,ts=new lr,es=new Br,ns=new ur,rs=new ur,ss=new ur,is=new lr,as=new ur(1,0,0),os=new ur(0,1,0),ls=new ur(0,0,1),us={type:"added"},cs={type:"removed"};class hs extends vn{constructor(){super(),Object.defineProperty(this,"id",{value:Zr++}),this.uuid=Tn(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=hs.DefaultUp.clone();const t=new ur,e=new Yr,n=new lr,r=new ur(1,1,1);e._onChange((function(){n.setFromEuler(e,!1)})),n._onChange((function(){e.setFromQuaternion(n,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Br},normalMatrix:{value:new Dn}}),this.matrix=new Br,this.matrixWorld=new Br,this.matrixAutoUpdate=hs.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Jr,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return ts.setFromAxisAngle(t,e),this.quaternion.multiply(ts),this}rotateOnWorldAxis(t,e){return ts.setFromAxisAngle(t,e),this.quaternion.premultiply(ts),this}rotateX(t){return this.rotateOnAxis(as,t)}rotateY(t){return this.rotateOnAxis(os,t)}rotateZ(t){return this.rotateOnAxis(ls,t)}translateOnAxis(t,e){return Qr.copy(t).applyQuaternion(this.quaternion),this.position.add(Qr.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(as,t)}translateY(t){return this.translateOnAxis(os,t)}translateZ(t){return this.translateOnAxis(ls,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(es.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?ns.copy(t):ns.set(t,e,n);const r=this.parent;this.updateWorldMatrix(!0,!1),rs.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?es.lookAt(rs,ns,this.up):es.lookAt(ns,rs,this.up),this.quaternion.setFromRotationMatrix(es),r&&(es.extractRotation(r.matrixWorld),ts.setFromRotationMatrix(es),this.quaternion.premultiply(ts.invert()))}add(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(us)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(t);return-1!==e&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(cs)),this}removeFromParent(){const t=this.parent;return null!==t&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(cs)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),es.copy(this.matrixWorld).invert(),null!==t.parent&&(t.parent.updateWorldMatrix(!0,!1),es.multiply(t.parent.matrixWorld)),t.applyMatrix4(es),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,r=this.children.length;n<r;n++){const r=this.children[n].getObjectByProperty(t,e);if(void 0!==r)return r}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(rs,t,ss),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(rs,is,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverse(t)}traverseVisible(t){if(!1===this.visible)return;t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;null!==e&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(!0===t&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e){const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].updateWorldMatrix(!1,!0)}}toJSON(t){const e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};function s(e,n){return void 0===e[n.uuid]&&(e[n.uuid]=n.toJSON(t)),n.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(t.geometries,this.geometry);const e=this.geometry.parameters;if(void 0!==e&&void 0!==e.shapes){const n=e.shapes;if(Array.isArray(n))for(let e=0,r=n.length;e<r;e++){const r=n[e];s(t.shapes,r)}else s(t.shapes,n)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(s(t.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const e=[];for(let n=0,r=this.material.length;n<r;n++)e.push(s(t.materials,this.material[n]));r.material=e}else r.material=s(t.materials,this.material);if(this.children.length>0){r.children=[];for(let e=0;e<this.children.length;e++)r.children.push(this.children[e].toJSON(t).object)}if(this.animations.length>0){r.animations=[];for(let e=0;e<this.animations.length;e++){const n=this.animations[e];r.animations.push(s(t.animations,n))}}if(e){const e=i(t.geometries),r=i(t.materials),s=i(t.textures),a=i(t.images),o=i(t.shapes),l=i(t.skeletons),u=i(t.animations),c=i(t.nodes);e.length>0&&(n.geometries=e),r.length>0&&(n.materials=r),s.length>0&&(n.textures=s),a.length>0&&(n.images=a),o.length>0&&(n.shapes=o),l.length>0&&(n.skeletons=l),u.length>0&&(n.animations=u),c.length>0&&(n.nodes=c)}return n.object=r,n;function i(t){const e=[];for(const n in t){const r=t[n];delete r.metadata,e.push(r)}return e}}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}hs.DefaultUp=new ur(0,1,0),hs.DefaultMatrixAutoUpdate=!0,hs.prototype.isObject3D=!0;const ds=new ur,ps=new ur,fs=new ur,ms=new ur,gs=new ur,xs=new ur,ys=new ur,vs=new ur,bs=new ur,ws=new ur;class Ss{constructor(t=new ur,e=new ur,n=new ur){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,r){r.subVectors(n,e),ds.subVectors(t,e),r.cross(ds);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(t,e,n,r,s){ds.subVectors(r,e),ps.subVectors(n,e),fs.subVectors(t,e);const i=ds.dot(ds),a=ds.dot(ps),o=ds.dot(fs),l=ps.dot(ps),u=ps.dot(fs),c=i*l-a*a;if(0===c)return s.set(-2,-1,-1);const h=1/c,d=(l*o-a*u)*h,p=(i*u-a*o)*h;return s.set(1-d-p,p,d)}static containsPoint(t,e,n,r){return this.getBarycoord(t,e,n,r,ms),ms.x>=0&&ms.y>=0&&ms.x+ms.y<=1}static getUV(t,e,n,r,s,i,a,o){return this.getBarycoord(t,e,n,r,ms),o.set(0,0),o.addScaledVector(s,ms.x),o.addScaledVector(i,ms.y),o.addScaledVector(a,ms.z),o}static isFrontFacing(t,e,n,r){return ds.subVectors(n,e),ps.subVectors(t,e),ds.cross(ps).dot(r)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,r){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[r]),this}setFromAttributeAndIndices(t,e,n,r){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,r),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ds.subVectors(this.c,this.b),ps.subVectors(this.a,this.b),.5*ds.cross(ps).length()}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Ss.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Ss.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,r,s){return Ss.getUV(t,this.a,this.b,this.c,e,n,r,s)}containsPoint(t){return Ss.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Ss.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,r=this.b,s=this.c;let i,a;gs.subVectors(r,n),xs.subVectors(s,n),vs.subVectors(t,n);const o=gs.dot(vs),l=xs.dot(vs);if(o<=0&&l<=0)return e.copy(n);bs.subVectors(t,r);const u=gs.dot(bs),c=xs.dot(bs);if(u>=0&&c<=u)return e.copy(r);const h=o*c-u*l;if(h<=0&&o>=0&&u<=0)return i=o/(o-u),e.copy(n).addScaledVector(gs,i);ws.subVectors(t,s);const d=gs.dot(ws),p=xs.dot(ws);if(p>=0&&d<=p)return e.copy(s);const f=d*l-o*p;if(f<=0&&l>=0&&p<=0)return a=l/(l-p),e.copy(n).addScaledVector(xs,a);const m=u*p-d*c;if(m<=0&&c-u>=0&&d-p>=0)return ys.subVectors(s,r),a=(c-u)/(c-u+(d-p)),e.copy(r).addScaledVector(ys,a);const g=1/(m+f+h);return i=f*g,a=h*g,e.copy(n).addScaledVector(gs,i).addScaledVector(xs,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let _s=0;class Ts extends vn{constructor(){super(),Object.defineProperty(this,"id",{value:_s++}),this.uuid=Tn(),this.name="",this.type="Material",this.blending=_,this.side=x,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=$,this.blendDst=O,this.blendEquation=I,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=q,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=an,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=He,this.stencilZFail=He,this.stencilZPass=He,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(void 0!==t)for(const e in t){const n=t[e];if(void 0===n){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if("shading"===e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===b;continue}const r=this[e];void 0!==r?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[e]=n:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}}toJSON(t){const e=void 0===t||"string"==typeof t;e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(t){const e=[];for(const n in t){const r=t[n];delete r.metadata,e.push(r)}return e}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),void 0!==this.sheen&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),void 0!==this.transmission&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),void 0!==this.thickness&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),void 0!==this.attenuationDistance&&(n.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(n.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==_&&(n.blending=this.blending),this.side!==x&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),!1===this.fog&&(n.fog=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),e){const e=r(t.textures),s=r(t.images);e.length>0&&(n.textures=e),s.length>0&&(n.images=s)}return n}clone(){return(new this.constructor).copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(null!==e){const t=e.length;n=new Array(t);for(let r=0;r!==t;++r)n[r]=e[r].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){!0===t&&this.version++}}Ts.prototype.isMaterial=!0,Ts.fromType=function(){return null};class Ms extends Ts{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new Xn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Z,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}Ms.prototype.isMeshBasicMaterial=!0;const Es=new ur,ks=new Nn;class Is{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===n,this.usage=on,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[t+r]=e.array[n+r];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let s=t[r];void 0===s&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),s=new Xn),e[n++]=s.r,e[n++]=s.g,e[n++]=s.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let s=t[r];void 0===s&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),s=new Nn),e[n++]=s.x,e[n++]=s.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let s=t[r];void 0===s&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),s=new ur),e[n++]=s.x,e[n++]=s.y,e[n++]=s.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let s=t[r];void 0===s&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),s=new er),e[n++]=s.x,e[n++]=s.y,e[n++]=s.z,e[n++]=s.w}return this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,n=this.count;e<n;e++)ks.fromBufferAttribute(this,e),ks.applyMatrix3(t),this.setXY(e,ks.x,ks.y);else if(3===this.itemSize)for(let e=0,n=this.count;e<n;e++)Es.fromBufferAttribute(this,e),Es.applyMatrix3(t),this.setXYZ(e,Es.x,Es.y,Es.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)Es.fromBufferAttribute(this,e),Es.applyMatrix4(t),this.setXYZ(e,Es.x,Es.y,Es.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)Es.fromBufferAttribute(this,e),Es.applyNormalMatrix(t),this.setXYZ(e,Es.x,Es.y,Es.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)Es.fromBufferAttribute(this,e),Es.transformDirection(t),this.setXYZ(e,Es.x,Es.y,Es.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this}setXYZW(t,e,n,r,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==on&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}}Is.prototype.isBufferAttribute=!0;class Cs extends Is{constructor(t,e,n){super(new Int8Array(t),e,n)}}class As extends Is{constructor(t,e,n){super(new Uint8Array(t),e,n)}}class Rs extends Is{constructor(t,e,n){super(new Uint8ClampedArray(t),e,n)}}class Ns extends Is{constructor(t,e,n){super(new Int16Array(t),e,n)}}class Ds extends Is{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Ls extends Is{constructor(t,e,n){super(new Int32Array(t),e,n)}}class Fs extends Is{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Ps extends Is{constructor(t,e,n){super(new Uint16Array(t),e,n)}}Ps.prototype.isFloat16BufferAttribute=!0;class $s extends Is{constructor(t,e,n){super(new Float32Array(t),e,n)}}class Os extends Is{constructor(t,e,n){super(new Float64Array(t),e,n)}}let zs=0;const Bs=new Br,Us=new hs,Ws=new ur,Vs=new dr,Gs=new dr,Hs=new ur;class js extends vn{constructor(){super(),Object.defineProperty(this,"id",{value:zs++}),this.uuid=Tn(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Ln(t)?Fs:Ds)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const e=(new Dn).getNormalMatrix(t);n.applyNormalMatrix(e),n.needsUpdate=!0}const r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(t),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return Bs.makeRotationFromQuaternion(t),this.applyMatrix4(Bs),this}rotateX(t){return Bs.makeRotationX(t),this.applyMatrix4(Bs),this}rotateY(t){return Bs.makeRotationY(t),this.applyMatrix4(Bs),this}rotateZ(t){return Bs.makeRotationZ(t),this.applyMatrix4(Bs),this}translate(t,e,n){return Bs.makeTranslation(t,e,n),this.applyMatrix4(Bs),this}scale(t,e,n){return Bs.makeScale(t,e,n),this.applyMatrix4(Bs),this}lookAt(t){return Us.lookAt(t),Us.updateMatrix(),this.applyMatrix4(Us.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ws).negate(),this.translate(Ws.x,Ws.y,Ws.z),this}setFromPoints(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new $s(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new dr);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new ur(-1/0,-1/0,-1/0),new ur(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Vs.setFromBufferAttribute(n),this.morphTargetsRelative?(Hs.addVectors(this.boundingBox.min,Vs.min),this.boundingBox.expandByPoint(Hs),Hs.addVectors(this.boundingBox.max,Vs.max),this.boundingBox.expandByPoint(Hs)):(this.boundingBox.expandByPoint(Vs.min),this.boundingBox.expandByPoint(Vs.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Rr);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new ur,1/0);if(t){const n=this.boundingSphere.center;if(Vs.setFromBufferAttribute(t),e)for(let t=0,n=e.length;t<n;t++){const n=e[t];Gs.setFromBufferAttribute(n),this.morphTargetsRelative?(Hs.addVectors(Vs.min,Gs.min),Vs.expandByPoint(Hs),Hs.addVectors(Vs.max,Gs.max),Vs.expandByPoint(Hs)):(Vs.expandByPoint(Gs.min),Vs.expandByPoint(Gs.max))}Vs.getCenter(n);let r=0;for(let e=0,s=t.count;e<s;e++)Hs.fromBufferAttribute(t,e),r=Math.max(r,n.distanceToSquared(Hs));if(e)for(let s=0,i=e.length;s<i;s++){const i=e[s],a=this.morphTargetsRelative;for(let e=0,s=i.count;e<s;e++)Hs.fromBufferAttribute(i,e),a&&(Ws.fromBufferAttribute(t,e),Hs.add(Ws)),r=Math.max(r,n.distanceToSquared(Hs))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,r=e.position.array,s=e.normal.array,i=e.uv.array,a=r.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new Is(new Float32Array(4*a),4));const o=this.getAttribute("tangent").array,l=[],u=[];for(let t=0;t<a;t++)l[t]=new ur,u[t]=new ur;const c=new ur,h=new ur,d=new ur,p=new Nn,f=new Nn,m=new Nn,g=new ur,x=new ur;function y(t,e,n){c.fromArray(r,3*t),h.fromArray(r,3*e),d.fromArray(r,3*n),p.fromArray(i,2*t),f.fromArray(i,2*e),m.fromArray(i,2*n),h.sub(c),d.sub(c),f.sub(p),m.sub(p);const s=1/(f.x*m.y-m.x*f.y);isFinite(s)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(d,-f.y).multiplyScalar(s),x.copy(d).multiplyScalar(f.x).addScaledVector(h,-m.x).multiplyScalar(s),l[t].add(g),l[e].add(g),l[n].add(g),u[t].add(x),u[e].add(x),u[n].add(x))}let v=this.groups;0===v.length&&(v=[{start:0,count:n.length}]);for(let t=0,e=v.length;t<e;++t){const e=v[t],r=e.start;for(let t=r,s=r+e.count;t<s;t+=3)y(n[t+0],n[t+1],n[t+2])}const b=new ur,w=new ur,S=new ur,_=new ur;function T(t){S.fromArray(s,3*t),_.copy(S);const e=l[t];b.copy(e),b.sub(S.multiplyScalar(S.dot(e))).normalize(),w.crossVectors(_,e);const n=w.dot(u[t])<0?-1:1;o[4*t]=b.x,o[4*t+1]=b.y,o[4*t+2]=b.z,o[4*t+3]=n}for(let t=0,e=v.length;t<e;++t){const e=v[t],r=e.start;for(let t=r,s=r+e.count;t<s;t+=3)T(n[t+0]),T(n[t+1]),T(n[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let n=this.getAttribute("normal");if(void 0===n)n=new Is(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let t=0,e=n.count;t<e;t++)n.setXYZ(t,0,0,0);const r=new ur,s=new ur,i=new ur,a=new ur,o=new ur,l=new ur,u=new ur,c=new ur;if(t)for(let h=0,d=t.count;h<d;h+=3){const d=t.getX(h+0),p=t.getX(h+1),f=t.getX(h+2);r.fromBufferAttribute(e,d),s.fromBufferAttribute(e,p),i.fromBufferAttribute(e,f),u.subVectors(i,s),c.subVectors(r,s),u.cross(c),a.fromBufferAttribute(n,d),o.fromBufferAttribute(n,p),l.fromBufferAttribute(n,f),a.add(u),o.add(u),l.add(u),n.setXYZ(d,a.x,a.y,a.z),n.setXYZ(p,o.x,o.y,o.z),n.setXYZ(f,l.x,l.y,l.z)}else for(let t=0,a=e.count;t<a;t+=3)r.fromBufferAttribute(e,t+0),s.fromBufferAttribute(e,t+1),i.fromBufferAttribute(e,t+2),u.subVectors(i,s),c.subVectors(r,s),u.cross(c),n.setXYZ(t+0,u.x,u.y,u.z),n.setXYZ(t+1,u.x,u.y,u.z),n.setXYZ(t+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(void 0===t.attributes[r])continue;const s=n[r].array,i=t.attributes[r],a=i.array,o=i.itemSize*e,l=Math.min(a.length,s.length-o);for(let t=0,e=o;t<l;t++,e++)s[e]=a[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Hs.fromBufferAttribute(t,e),Hs.normalize(),t.setXYZ(e,Hs.x,Hs.y,Hs.z)}toNonIndexed(){function t(t,e){const n=t.array,r=t.itemSize,s=t.normalized,i=new n.constructor(e.length*r);let a=0,o=0;for(let s=0,l=e.length;s<l;s++){a=t.isInterleavedBufferAttribute?e[s]*t.data.stride+t.offset:e[s]*r;for(let t=0;t<r;t++)i[o++]=n[a++]}return new Is(i,r,s)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new js,n=this.index.array,r=this.attributes;for(const s in r){const i=t(r[s],n);e.setAttribute(s,i)}const s=this.morphAttributes;for(const r in s){const i=[],a=s[r];for(let e=0,r=a.length;e<r;e++){const r=t(a[e],n);i.push(r)}e.morphAttributes[r]=i}e.morphTargetsRelative=this.morphTargetsRelative;const i=this.groups;for(let t=0,n=i.length;t<n;t++){const n=i[t];e.addGroup(n.start,n.count,n.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const n in e)void 0!==e[n]&&(t[n]=e[n]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const e in n){const r=n[e];t.data.attributes[e]=r.toJSON(t.data)}const r={};let s=!1;for(const e in this.morphAttributes){const n=this.morphAttributes[e],i=[];for(let e=0,r=n.length;e<r;e++){const r=n[e];i.push(r.toJSON(t.data))}i.length>0&&(r[e]=i,s=!0)}s&&(t.data.morphAttributes=r,t.data.morphTargetsRelative=this.morphTargetsRelative);const i=this.groups;i.length>0&&(t.data.groups=JSON.parse(JSON.stringify(i)));const a=this.boundingSphere;return null!==a&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;null!==n&&this.setIndex(n.clone(e));const r=t.attributes;for(const t in r){const n=r[t];this.setAttribute(t,n.clone(e))}const s=t.morphAttributes;for(const t in s){const n=[],r=s[t];for(let t=0,s=r.length;t<s;t++)n.push(r[t].clone(e));this.morphAttributes[t]=n}this.morphTargetsRelative=t.morphTargetsRelative;const i=t.groups;for(let t=0,e=i.length;t<e;t++){const e=i[t];this.addGroup(e.start,e.count,e.materialIndex)}const a=t.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=t.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}js.prototype.isBufferGeometry=!0;const qs=new Br,Xs=new zr,Ks=new Rr,Ys=new ur,Js=new ur,Zs=new ur,Qs=new ur,ti=new ur,ei=new ur,ni=new ur,ri=new ur,si=new ur,ii=new Nn,ai=new Nn,oi=new Nn,li=new ur,ui=new ur;class ci extends hs{constructor(t=new js,e=new Ms){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),void 0!==t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),void 0!==t.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,r=this.material,s=this.matrixWorld;if(void 0===r)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),Ks.copy(n.boundingSphere),Ks.applyMatrix4(s),!1===t.ray.intersectsSphere(Ks))return;if(qs.copy(s).invert(),Xs.copy(t.ray).applyMatrix4(qs),null!==n.boundingBox&&!1===Xs.intersectsBox(n.boundingBox))return;let i;if(n.isBufferGeometry){const s=n.index,a=n.attributes.position,o=n.morphAttributes.position,l=n.morphTargetsRelative,u=n.attributes.uv,c=n.attributes.uv2,h=n.groups,d=n.drawRange;if(null!==s)if(Array.isArray(r))for(let n=0,p=h.length;n<p;n++){const p=h[n],f=r[p.materialIndex];for(let n=Math.max(p.start,d.start),r=Math.min(s.count,Math.min(p.start+p.count,d.start+d.count));n<r;n+=3){const r=s.getX(n),h=s.getX(n+1),d=s.getX(n+2);i=hi(this,f,t,Xs,a,o,l,u,c,r,h,d),i&&(i.faceIndex=Math.floor(n/3),i.face.materialIndex=p.materialIndex,e.push(i))}}else for(let n=Math.max(0,d.start),h=Math.min(s.count,d.start+d.count);n<h;n+=3){const h=s.getX(n),d=s.getX(n+1),p=s.getX(n+2);i=hi(this,r,t,Xs,a,o,l,u,c,h,d,p),i&&(i.faceIndex=Math.floor(n/3),e.push(i))}else if(void 0!==a)if(Array.isArray(r))for(let n=0,s=h.length;n<s;n++){const s=h[n],p=r[s.materialIndex];for(let n=Math.max(s.start,d.start),r=Math.min(a.count,Math.min(s.start+s.count,d.start+d.count));n<r;n+=3)i=hi(this,p,t,Xs,a,o,l,u,c,n,n+1,n+2),i&&(i.faceIndex=Math.floor(n/3),i.face.materialIndex=s.materialIndex,e.push(i))}else for(let n=Math.max(0,d.start),s=Math.min(a.count,d.start+d.count);n<s;n+=3)i=hi(this,r,t,Xs,a,o,l,u,c,n,n+1,n+2),i&&(i.faceIndex=Math.floor(n/3),e.push(i))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function hi(t,e,n,r,s,i,a,o,l,u,c,h){Ys.fromBufferAttribute(s,u),Js.fromBufferAttribute(s,c),Zs.fromBufferAttribute(s,h);const d=t.morphTargetInfluences;if(i&&d){ni.set(0,0,0),ri.set(0,0,0),si.set(0,0,0);for(let t=0,e=i.length;t<e;t++){const e=d[t],n=i[t];0!==e&&(Qs.fromBufferAttribute(n,u),ti.fromBufferAttribute(n,c),ei.fromBufferAttribute(n,h),a?(ni.addScaledVector(Qs,e),ri.addScaledVector(ti,e),si.addScaledVector(ei,e)):(ni.addScaledVector(Qs.sub(Ys),e),ri.addScaledVector(ti.sub(Js),e),si.addScaledVector(ei.sub(Zs),e)))}Ys.add(ni),Js.add(ri),Zs.add(si)}t.isSkinnedMesh&&(t.boneTransform(u,Ys),t.boneTransform(c,Js),t.boneTransform(h,Zs));const p=function(t,e,n,r,s,i,a,o){let l;if(l=e.side===y?r.intersectTriangle(a,i,s,!0,o):r.intersectTriangle(s,i,a,e.side!==v,o),null===l)return null;ui.copy(o),ui.applyMatrix4(t.matrixWorld);const u=n.ray.origin.distanceTo(ui);return u<n.near||u>n.far?null:{distance:u,point:ui.clone(),object:t}}(t,e,n,r,Ys,Js,Zs,li);if(p){o&&(ii.fromBufferAttribute(o,u),ai.fromBufferAttribute(o,c),oi.fromBufferAttribute(o,h),p.uv=Ss.getUV(li,Ys,Js,Zs,ii,ai,oi,new Nn)),l&&(ii.fromBufferAttribute(l,u),ai.fromBufferAttribute(l,c),oi.fromBufferAttribute(l,h),p.uv2=Ss.getUV(li,Ys,Js,Zs,ii,ai,oi,new Nn));const t={a:u,b:c,c:h,normal:new ur,materialIndex:0};Ss.getNormal(Ys,Js,Zs,t.normal),p.face=t}return p}ci.prototype.isMesh=!0;class di extends js{constructor(t=1,e=1,n=1,r=1,s=1,i=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:r,heightSegments:s,depthSegments:i};const a=this;r=Math.floor(r),s=Math.floor(s),i=Math.floor(i);const o=[],l=[],u=[],c=[];let h=0,d=0;function p(t,e,n,r,s,i,p,f,m,g,x){const y=i/m,v=p/g,b=i/2,w=p/2,S=f/2,_=m+1,T=g+1;let M=0,E=0;const k=new ur;for(let i=0;i<T;i++){const a=i*v-w;for(let o=0;o<_;o++){const h=o*y-b;k[t]=h*r,k[e]=a*s,k[n]=S,l.push(k.x,k.y,k.z),k[t]=0,k[e]=0,k[n]=f>0?1:-1,u.push(k.x,k.y,k.z),c.push(o/m),c.push(1-i/g),M+=1}}for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=h+e+_*t,r=h+e+_*(t+1),s=h+(e+1)+_*(t+1),i=h+(e+1)+_*t;o.push(n,r,i),o.push(r,s,i),E+=6}a.addGroup(d,E,x),d+=E,h+=M}p("z","y","x",-1,-1,n,e,t,i,s,0),p("z","y","x",1,-1,n,e,-t,i,s,1),p("x","z","y",1,1,t,n,e,r,i,2),p("x","z","y",1,-1,t,n,-e,r,i,3),p("x","y","z",1,-1,t,e,n,r,s,4),p("x","y","z",-1,-1,t,e,-n,r,s,5),this.setIndex(o),this.setAttribute("position",new $s(l,3)),this.setAttribute("normal",new $s(u,3)),this.setAttribute("uv",new $s(c,2))}static fromJSON(t){return new di(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function pi(t){const e={};for(const n in t){e[n]={};for(const r in t[n]){const s=t[n][r];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?e[n][r]=s.clone():Array.isArray(s)?e[n][r]=s.slice():e[n][r]=s}}return e}function fi(t){const e={};for(let n=0;n<t.length;n++){const r=pi(t[n]);for(const t in r)e[t]=r[t]}return e}const mi={clone:pi,merge:fi};class gi extends Ts{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==t&&(void 0!==t.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=pi(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n].value;r&&r.isTexture?e.uniforms[n]={type:"t",value:r.toJSON(t).uuid}:r&&r.isColor?e.uniforms[n]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[n]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[n]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[n]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[n]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[n]={type:"m4",value:r.toArray()}:e.uniforms[n]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const t in this.extensions)!0===this.extensions[t]&&(n[t]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}gi.prototype.isShaderMaterial=!0;class xi extends hs{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Br,this.projectionMatrix=new Br,this.projectionMatrixInverse=new Br}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}xi.prototype.isCamera=!0;class yi extends xi{constructor(t=50,e=1,n=.1,r=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=null===t.view?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*_n*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*Sn*this.fov);return.5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*_n*Math.atan(Math.tan(.5*Sn*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,r,s,i){this.aspect=t/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=i,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*Sn*this.fov)/this.zoom,n=2*e,r=this.aspect*n,s=-.5*r;const i=this.view;if(null!==this.view&&this.view.enabled){const t=i.fullWidth,a=i.fullHeight;s+=i.offsetX*r/t,e-=i.offsetY*n/a,r*=i.width/t,n*=i.height/a}const a=this.filmOffset;0!==a&&(s+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}yi.prototype.isPerspectiveCamera=!0;const vi=90;class bi extends hs{constructor(t,e,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const r=new yi(vi,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new ur(1,0,0)),this.add(r);const s=new yi(vi,1,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new ur(-1,0,0)),this.add(s);const i=new yi(vi,1,t,e);i.layers=this.layers,i.up.set(0,0,1),i.lookAt(new ur(0,1,0)),this.add(i);const a=new yi(vi,1,t,e);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new ur(0,-1,0)),this.add(a);const o=new yi(vi,1,t,e);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new ur(0,0,1)),this.add(o);const l=new yi(vi,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new ur(0,0,-1)),this.add(l)}update(t,e){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[r,s,i,a,o,l]=this.children,u=t.getRenderTarget(),c=t.toneMapping,h=t.xr.enabled;t.toneMapping=et,t.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,r),t.setRenderTarget(n,1),t.render(e,s),t.setRenderTarget(n,2),t.render(e,i),t.setRenderTarget(n,3),t.render(e,a),t.setRenderTarget(n,4),t.render(e,o),n.texture.generateMipmaps=d,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(u),t.toneMapping=c,t.xr.enabled=h,n.texture.needsPMREMUpdate=!0}}class wi extends tr{constructor(t,e,n,r,s,i,a,o,l,u){super(t=void 0!==t?t:[],e=void 0!==e?e:lt,n,r,s,i,a,o,l,u),this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}wi.prototype.isCubeTexture=!0;class Si extends nr{constructor(t,e={}){super(t,t,e);const n={width:t,height:t,depth:1},r=[n,n,n,n,n,n];this.texture=new wi(r,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==e.generateMipmaps&&e.generateMipmaps,this.texture.minFilter=void 0!==e.minFilter?e.minFilter:wt}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={tEquirect:{value:null}},r="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",s="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",i=new di(5,5,5),a=new gi({name:"CubemapFromEquirect",uniforms:pi(n),vertexShader:r,fragmentShader:s,side:y,blending:S});a.uniforms.tEquirect.value=e;const o=new ci(i,a),l=e.minFilter;return e.minFilter===Tt&&(e.minFilter=wt),new bi(1,10,this).update(t,o),e.minFilter=l,o.geometry.dispose(),o.material.dispose(),this}clear(t,e,n,r){const s=t.getRenderTarget();for(let s=0;s<6;s++)t.setRenderTarget(this,s),t.clear(e,n,r);t.setRenderTarget(s)}}Si.prototype.isWebGLCubeRenderTarget=!0;const _i=new ur,Ti=new ur,Mi=new Dn;class Ei{constructor(t=new ur(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,r){return this.normal.set(t,e,n),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const r=_i.subVectors(n,e).cross(Ti.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(_i),r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(t.start)?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:e.copy(n).multiplyScalar(s).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||Mi.getNormalMatrix(t),r=this.coplanarPoint(_i).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return(new this.constructor).copy(this)}}Ei.prototype.isPlane=!0;const ki=new Rr,Ii=new ur;class Ci{constructor(t=new Ei,e=new Ei,n=new Ei,r=new Ei,s=new Ei,i=new Ei){this.planes=[t,e,n,r,s,i]}set(t,e,n,r,s,i){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(n),a[3].copy(r),a[4].copy(s),a[5].copy(i),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,r=n[0],s=n[1],i=n[2],a=n[3],o=n[4],l=n[5],u=n[6],c=n[7],h=n[8],d=n[9],p=n[10],f=n[11],m=n[12],g=n[13],x=n[14],y=n[15];return e[0].setComponents(a-r,c-o,f-h,y-m).normalize(),e[1].setComponents(a+r,c+o,f+h,y+m).normalize(),e[2].setComponents(a+s,c+l,f+d,y+g).normalize(),e[3].setComponents(a-s,c-l,f-d,y-g).normalize(),e[4].setComponents(a-i,c-u,f-p,y-x).normalize(),e[5].setComponents(a+i,c+u,f+p,y+x).normalize(),this}intersectsObject(t){const e=t.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),ki.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(ki)}intersectsSprite(t){return ki.center.set(0,0,0),ki.radius=.7071067811865476,ki.applyMatrix4(t.matrixWorld),this.intersectsSphere(ki)}intersectsSphere(t){const e=this.planes,n=t.center,r=-t.radius;for(let t=0;t<6;t++)if(e[t].distanceToPoint(n)<r)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const r=e[n];if(Ii.x=r.normal.x>0?t.max.x:t.min.x,Ii.y=r.normal.y>0?t.max.y:t.min.y,Ii.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint(Ii)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function Ai(){let t=null,e=!1,n=null,r=null;function s(e,i){n(e,i),r=t.requestAnimationFrame(s)}return{start:function(){!0!==e&&null!==n&&(r=t.requestAnimationFrame(s),e=!0)},stop:function(){t.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(t){n=t},setContext:function(e){t=e}}}function Ri(t,e){const n=e.isWebGL2,r=new WeakMap;return{get:function(t){return t.isInterleavedBufferAttribute&&(t=t.data),r.get(t)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);const n=r.get(e);n&&(t.deleteBuffer(n.buffer),r.delete(e))},update:function(e,s){if(e.isGLBufferAttribute){const t=r.get(e);return void((!t||t.version<e.version)&&r.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const i=r.get(e);void 0===i?r.set(e,function(e,r){const s=e.array,i=e.usage,a=t.createBuffer();let o;if(t.bindBuffer(r,a),t.bufferData(r,s,i),e.onUploadCallback(),s instanceof Float32Array)o=5126;else if(s instanceof Uint16Array)if(e.isFloat16BufferAttribute){if(!n)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");o=5131}else o=5123;else if(s instanceof Int16Array)o=5122;else if(s instanceof Uint32Array)o=5125;else if(s instanceof Int32Array)o=5124;else if(s instanceof Int8Array)o=5120;else if(s instanceof Uint8Array)o=5121;else{if(!(s instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+s);o=5121}return{buffer:a,type:o,bytesPerElement:s.BYTES_PER_ELEMENT,version:e.version}}(e,s)):i.version<e.version&&(function(e,r,s){const i=r.array,a=r.updateRange;t.bindBuffer(s,e),-1===a.count?t.bufferSubData(s,0,i):(n?t.bufferSubData(s,a.offset*i.BYTES_PER_ELEMENT,i,a.offset,a.count):t.bufferSubData(s,a.offset*i.BYTES_PER_ELEMENT,i.subarray(a.offset,a.offset+a.count)),a.count=-1)}(i.buffer,e,s),i.version=e.version)}}}class Ni extends js{constructor(t=1,e=1,n=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:r};const s=t/2,i=e/2,a=Math.floor(n),o=Math.floor(r),l=a+1,u=o+1,c=t/a,h=e/o,d=[],p=[],f=[],m=[];for(let t=0;t<u;t++){const e=t*h-i;for(let n=0;n<l;n++){const r=n*c-s;p.push(r,-e,0),f.push(0,0,1),m.push(n/a),m.push(1-t/o)}}for(let t=0;t<o;t++)for(let e=0;e<a;e++){const n=e+l*t,r=e+l*(t+1),s=e+1+l*(t+1),i=e+1+l*t;d.push(n,r,i),d.push(r,s,i)}this.setIndex(d),this.setAttribute("position",new $s(p,3)),this.setAttribute("normal",new $s(f,3)),this.setAttribute("uv",new $s(m,2))}static fromJSON(t){return new Ni(t.width,t.height,t.widthSegments,t.heightSegments)}}const Di={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},Li={common:{diffuse:{value:new Xn(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Dn},uv2Transform:{value:new Dn},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Nn(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Xn(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Xn(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Dn}},sprite:{diffuse:{value:new Xn(16777215)},opacity:{value:1},center:{value:new Nn(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Dn}}},Fi={basic:{uniforms:fi([Li.common,Li.specularmap,Li.envmap,Li.aomap,Li.lightmap,Li.fog]),vertexShader:Di.meshbasic_vert,fragmentShader:Di.meshbasic_frag},lambert:{uniforms:fi([Li.common,Li.specularmap,Li.envmap,Li.aomap,Li.lightmap,Li.emissivemap,Li.fog,Li.lights,{emissive:{value:new Xn(0)}}]),vertexShader:Di.meshlambert_vert,fragmentShader:Di.meshlambert_frag},phong:{uniforms:fi([Li.common,Li.specularmap,Li.envmap,Li.aomap,Li.lightmap,Li.emissivemap,Li.bumpmap,Li.normalmap,Li.displacementmap,Li.fog,Li.lights,{emissive:{value:new Xn(0)},specular:{value:new Xn(1118481)},shininess:{value:30}}]),vertexShader:Di.meshphong_vert,fragmentShader:Di.meshphong_frag},standard:{uniforms:fi([Li.common,Li.envmap,Li.aomap,Li.lightmap,Li.emissivemap,Li.bumpmap,Li.normalmap,Li.displacementmap,Li.roughnessmap,Li.metalnessmap,Li.fog,Li.lights,{emissive:{value:new Xn(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Di.meshphysical_vert,fragmentShader:Di.meshphysical_frag},toon:{uniforms:fi([Li.common,Li.aomap,Li.lightmap,Li.emissivemap,Li.bumpmap,Li.normalmap,Li.displacementmap,Li.gradientmap,Li.fog,Li.lights,{emissive:{value:new Xn(0)}}]),vertexShader:Di.meshtoon_vert,fragmentShader:Di.meshtoon_frag},matcap:{uniforms:fi([Li.common,Li.bumpmap,Li.normalmap,Li.displacementmap,Li.fog,{matcap:{value:null}}]),vertexShader:Di.meshmatcap_vert,fragmentShader:Di.meshmatcap_frag},points:{uniforms:fi([Li.points,Li.fog]),vertexShader:Di.points_vert,fragmentShader:Di.points_frag},dashed:{uniforms:fi([Li.common,Li.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Di.linedashed_vert,fragmentShader:Di.linedashed_frag},depth:{uniforms:fi([Li.common,Li.displacementmap]),vertexShader:Di.depth_vert,fragmentShader:Di.depth_frag},normal:{uniforms:fi([Li.common,Li.bumpmap,Li.normalmap,Li.displacementmap,{opacity:{value:1}}]),vertexShader:Di.meshnormal_vert,fragmentShader:Di.meshnormal_frag},sprite:{uniforms:fi([Li.sprite,Li.fog]),vertexShader:Di.sprite_vert,fragmentShader:Di.sprite_frag},background:{uniforms:{uvTransform:{value:new Dn},t2D:{value:null}},vertexShader:Di.background_vert,fragmentShader:Di.background_frag},cube:{uniforms:fi([Li.envmap,{opacity:{value:1}}]),vertexShader:Di.cube_vert,fragmentShader:Di.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Di.equirect_vert,fragmentShader:Di.equirect_frag},distanceRGBA:{uniforms:fi([Li.common,Li.displacementmap,{referencePosition:{value:new ur},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Di.distanceRGBA_vert,fragmentShader:Di.distanceRGBA_frag},shadow:{uniforms:fi([Li.lights,Li.fog,{color:{value:new Xn(0)},opacity:{value:1}}]),vertexShader:Di.shadow_vert,fragmentShader:Di.shadow_frag}};function Pi(t,e,n,r,s,i){const a=new Xn(0);let o,l,u=!0===s?0:1,c=null,h=0,d=null;function p(t,e){n.buffers.color.setClear(t.r,t.g,t.b,e,i)}return{getClearColor:function(){return a},setClearColor:function(t,e=1){a.set(t),u=e,p(a,u)},getClearAlpha:function(){return u},setClearAlpha:function(t){u=t,p(a,u)},render:function(n,s){let i=!1,f=!0===s.isScene?s.background:null;f&&f.isTexture&&(f=e.get(f));const m=t.xr,g=m.getSession&&m.getSession();g&&"additive"===g.environmentBlendMode&&(f=null),null===f?p(a,u):f&&f.isColor&&(p(f,1),i=!0),(t.autoClear||i)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),f&&(f.isCubeTexture||f.mapping===dt)?(void 0===l&&(l=new ci(new di(1,1,1),new gi({name:"BackgroundCubeMaterial",uniforms:pi(Fi.cube.uniforms),vertexShader:Fi.cube.vertexShader,fragmentShader:Fi.cube.fragmentShader,side:y,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(t,e,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(l)),l.material.uniforms.envMap.value=f,l.material.uniforms.flipEnvMap.value=f.isCubeTexture&&!1===f.isRenderTargetTexture?-1:1,c===f&&h===f.version&&d===t.toneMapping||(l.material.needsUpdate=!0,c=f,h=f.version,d=t.toneMapping),l.layers.enableAll(),n.unshift(l,l.geometry,l.material,0,0,null)):f&&f.isTexture&&(void 0===o&&(o=new ci(new Ni(2,2),new gi({name:"BackgroundMaterial",uniforms:pi(Fi.background.uniforms),vertexShader:Fi.background.vertexShader,fragmentShader:Fi.background.fragmentShader,side:x,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(o)),o.material.uniforms.t2D.value=f,!0===f.matrixAutoUpdate&&f.updateMatrix(),o.material.uniforms.uvTransform.value.copy(f.matrix),c===f&&h===f.version&&d===t.toneMapping||(o.material.needsUpdate=!0,c=f,h=f.version,d=t.toneMapping),o.layers.enableAll(),n.unshift(o,o.geometry,o.material,0,0,null))}}}function $i(t,e,n,r){const s=t.getParameter(34921),i=r.isWebGL2?null:e.get("OES_vertex_array_object"),a=r.isWebGL2||null!==i,o={},l=p(null);let u=l,c=!1;function h(e){return r.isWebGL2?t.bindVertexArray(e):i.bindVertexArrayOES(e)}function d(e){return r.isWebGL2?t.deleteVertexArray(e):i.deleteVertexArrayOES(e)}function p(t){const e=[],n=[],r=[];for(let t=0;t<s;t++)e[t]=0,n[t]=0,r[t]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:n,attributeDivisors:r,object:t,attributes:{},index:null}}function f(){const t=u.newAttributes;for(let e=0,n=t.length;e<n;e++)t[e]=0}function m(t){g(t,0)}function g(n,s){const i=u.newAttributes,a=u.enabledAttributes,o=u.attributeDivisors;i[n]=1,0===a[n]&&(t.enableVertexAttribArray(n),a[n]=1),o[n]!==s&&((r.isWebGL2?t:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,s),o[n]=s)}function x(){const e=u.newAttributes,n=u.enabledAttributes;for(let r=0,s=n.length;r<s;r++)n[r]!==e[r]&&(t.disableVertexAttribArray(r),n[r]=0)}function y(e,n,s,i,a,o){!0!==r.isWebGL2||5124!==s&&5125!==s?t.vertexAttribPointer(e,n,s,i,a,o):t.vertexAttribIPointer(e,n,s,a,o)}function v(){b(),c=!0,u!==l&&(u=l,h(u.object))}function b(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(s,l,d,v,b){let w=!1;if(a){const e=function(e,n,s){const a=!0===s.wireframe;let l=o[e.id];void 0===l&&(l={},o[e.id]=l);let u=l[n.id];void 0===u&&(u={},l[n.id]=u);let c=u[a];return void 0===c&&(c=p(r.isWebGL2?t.createVertexArray():i.createVertexArrayOES()),u[a]=c),c}(v,d,l);u!==e&&(u=e,h(u.object)),w=function(t,e,n,r){const s=u.attributes,i=e.attributes;let a=0;const o=n.getAttributes();for(const e in o)if(o[e].location>=0){const n=s[e];let r=i[e];if(void 0===r&&("instanceMatrix"===e&&t.instanceMatrix&&(r=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(r=t.instanceColor)),void 0===n)return!0;if(n.attribute!==r)return!0;if(r&&n.data!==r.data)return!0;a++}return u.attributesNum!==a||u.index!==r}(s,v,d,b),w&&function(t,e,n,r){const s={},i=e.attributes;let a=0;const o=n.getAttributes();for(const e in o)if(o[e].location>=0){let n=i[e];void 0===n&&("instanceMatrix"===e&&t.instanceMatrix&&(n=t.instanceMatrix),"instanceColor"===e&&t.instanceColor&&(n=t.instanceColor));const r={};r.attribute=n,n&&n.data&&(r.data=n.data),s[e]=r,a++}u.attributes=s,u.attributesNum=a,u.index=r}(s,v,d,b)}else{const t=!0===l.wireframe;u.geometry===v.id&&u.program===d.id&&u.wireframe===t||(u.geometry=v.id,u.program=d.id,u.wireframe=t,w=!0)}null!==b&&n.update(b,34963),(w||c)&&(c=!1,function(s,i,a,o){if(!1===r.isWebGL2&&(s.isInstancedMesh||o.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;f();const l=o.attributes,u=a.getAttributes(),c=i.defaultAttributeValues;for(const e in u){const r=u[e];if(r.location>=0){let i=l[e];if(void 0===i&&("instanceMatrix"===e&&s.instanceMatrix&&(i=s.instanceMatrix),"instanceColor"===e&&s.instanceColor&&(i=s.instanceColor)),void 0!==i){const e=i.normalized,a=i.itemSize,l=n.get(i);if(void 0===l)continue;const u=l.buffer,c=l.type,h=l.bytesPerElement;if(i.isInterleavedBufferAttribute){const n=i.data,l=n.stride,d=i.offset;if(n.isInstancedInterleavedBuffer){for(let t=0;t<r.locationSize;t++)g(r.location+t,n.meshPerAttribute);!0!==s.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=n.meshPerAttribute*n.count)}else for(let t=0;t<r.locationSize;t++)m(r.location+t);t.bindBuffer(34962,u);for(let t=0;t<r.locationSize;t++)y(r.location+t,a/r.locationSize,c,e,l*h,(d+a/r.locationSize*t)*h)}else{if(i.isInstancedBufferAttribute){for(let t=0;t<r.locationSize;t++)g(r.location+t,i.meshPerAttribute);!0!==s.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=i.meshPerAttribute*i.count)}else for(let t=0;t<r.locationSize;t++)m(r.location+t);t.bindBuffer(34962,u);for(let t=0;t<r.locationSize;t++)y(r.location+t,a/r.locationSize,c,e,a*h,a/r.locationSize*t*h)}}else if(void 0!==c){const n=c[e];if(void 0!==n)switch(n.length){case 2:t.vertexAttrib2fv(r.location,n);break;case 3:t.vertexAttrib3fv(r.location,n);break;case 4:t.vertexAttrib4fv(r.location,n);break;default:t.vertexAttrib1fv(r.location,n)}}}}x()}(s,l,d,v),null!==b&&t.bindBuffer(34963,n.get(b).buffer))},reset:v,resetDefaultState:b,dispose:function(){v();for(const t in o){const e=o[t];for(const t in e){const n=e[t];for(const t in n)d(n[t].object),delete n[t];delete e[t]}delete o[t]}},releaseStatesOfGeometry:function(t){if(void 0===o[t.id])return;const e=o[t.id];for(const t in e){const n=e[t];for(const t in n)d(n[t].object),delete n[t];delete e[t]}delete o[t.id]},releaseStatesOfProgram:function(t){for(const e in o){const n=o[e];if(void 0===n[t.id])continue;const r=n[t.id];for(const t in r)d(r[t].object),delete r[t];delete n[t.id]}},initAttributes:f,enableAttribute:m,disableUnusedAttributes:x}}function Oi(t,e,n,r){const s=r.isWebGL2;let i;this.setMode=function(t){i=t},this.render=function(e,r){t.drawArrays(i,e,r),n.update(r,i,1)},this.renderInstances=function(r,a,o){if(0===o)return;let l,u;if(s)l=t,u="drawArraysInstanced";else if(l=e.get("ANGLE_instanced_arrays"),u="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[u](i,r,a,o),n.update(a,i,o)}}function zi(t,e,n){let r;function s(e){if("highp"===e){if(t.getShaderPrecisionFormat(35633,36338).precision>0&&t.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&t.getShaderPrecisionFormat(35633,36337).precision>0&&t.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const i="undefined"!=typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&t instanceof WebGL2ComputeRenderingContext;let a=void 0!==n.precision?n.precision:"highp";const o=s(a);o!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",o,"instead."),a=o);const l=i||e.has("WEBGL_draw_buffers"),u=!0===n.logarithmicDepthBuffer,c=t.getParameter(34930),h=t.getParameter(35660),d=t.getParameter(3379),p=t.getParameter(34076),f=t.getParameter(34921),m=t.getParameter(36347),g=t.getParameter(36348),x=t.getParameter(36349),y=h>0,v=i||e.has("OES_texture_float");return{isWebGL2:i,drawBuffers:l,getMaxAnisotropy:function(){if(void 0!==r)return r;if(!0===e.has("EXT_texture_filter_anisotropic")){const n=e.get("EXT_texture_filter_anisotropic");r=t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:s,precision:a,logarithmicDepthBuffer:u,maxTextures:c,maxVertexTextures:h,maxTextureSize:d,maxCubemapSize:p,maxAttributes:f,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:x,vertexTextures:y,floatFragmentTextures:v,floatVertexTextures:y&&v,maxSamples:i?t.getParameter(36183):0}}function Bi(t){const e=this;let n=null,r=0,s=!1,i=!1;const a=new Ei,o=new Dn,l={value:null,needsUpdate:!1};function u(){l.value!==n&&(l.value=n,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function c(t,n,r,s){const i=null!==t?t.length:0;let u=null;if(0!==i){if(u=l.value,!0!==s||null===u){const e=r+4*i,s=n.matrixWorldInverse;o.getNormalMatrix(s),(null===u||u.length<e)&&(u=new Float32Array(e));for(let e=0,n=r;e!==i;++e,n+=4)a.copy(t[e]).applyMatrix4(s,o),a.normal.toArray(u,n),u[n+3]=a.constant}l.value=u,l.needsUpdate=!0}return e.numPlanes=i,e.numIntersection=0,u}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(t,e,i){const a=0!==t.length||e||0!==r||s;return s=e,n=c(t,i,0),r=t.length,a},this.beginShadows=function(){i=!0,c(null)},this.endShadows=function(){i=!1,u()},this.setState=function(e,a,o){const h=e.clippingPlanes,d=e.clipIntersection,p=e.clipShadows,f=t.get(e);if(!s||null===h||0===h.length||i&&!p)i?c(null):u();else{const t=i?0:r,e=4*t;let s=f.clippingState||null;l.value=s,s=c(h,a,e,o);for(let t=0;t!==e;++t)s[t]=n[t];f.clippingState=s,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=t}}}function Ui(t){let e=new WeakMap;function n(t,e){return e===ct?t.mapping=lt:e===ht&&(t.mapping=ut),t}function r(t){const n=t.target;n.removeEventListener("dispose",r);const s=e.get(n);void 0!==s&&(e.delete(n),s.dispose())}return{get:function(s){if(s&&s.isTexture&&!1===s.isRenderTargetTexture){const i=s.mapping;if(i===ct||i===ht){if(e.has(s))return n(e.get(s).texture,s.mapping);{const i=s.image;if(i&&i.height>0){const a=new Si(i.height/2);return a.fromEquirectangularTexture(t,s),e.set(s,a),s.addEventListener("dispose",r),n(a.texture,s.mapping)}return null}}}return s},dispose:function(){e=new WeakMap}}}Fi.physical={uniforms:fi([Fi.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Nn(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Xn(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Nn},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Xn(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Xn(1,1,1)},specularColorMap:{value:null}}]),vertexShader:Di.meshphysical_vert,fragmentShader:Di.meshphysical_frag};class Wi extends xi{constructor(t=-1,e=1,n=1,r=-1,s=.1,i=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=r,this.near=s,this.far=i,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=null===t.view?null:Object.assign({},t.view),this}setViewOffset(t,e,n,r,s,i){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=i,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=n-t,i=n+t,a=r+e,o=r-e;if(null!==this.view&&this.view.enabled){const t=(this.right-this.left)/this.view.fullWidth/this.zoom,e=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=t*this.view.offsetX,i=s+t*this.view.width,a-=e*this.view.offsetY,o=a-e*this.view.height}this.projectionMatrix.makeOrthographic(s,i,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}Wi.prototype.isOrthographicCamera=!0;const Vi=[.125,.215,.35,.446,.526,.582],Gi=new Wi,Hi=new Xn;let ji=null;const qi=(1+Math.sqrt(5))/2,Xi=1/qi,Ki=[new ur(1,1,1),new ur(-1,1,1),new ur(1,1,-1),new ur(-1,1,-1),new ur(0,qi,Xi),new ur(0,qi,-Xi),new ur(Xi,0,qi),new ur(-Xi,0,qi),new ur(qi,Xi,0),new ur(-qi,Xi,0)];class Yi{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,r=100){ji=this._renderer.getRenderTarget(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(t,n,r,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=ta(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=Qi(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(ji),t.scissorTest=!1,Zi(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===lt||t.mapping===ut?this._setSize(0===t.image.length?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),ji=this._renderer.getRenderTarget();const n=e||this._allocateTargets();return this._textureToCubeUV(t,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,n={magFilter:wt,minFilter:wt,generateMipmaps:!1,type:Dt,format:zt,encoding:Fe,depthBuffer:!1},r=Ji(t,e,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==t){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Ji(t,e,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(t){const e=[],n=[],r=[];let s=t;const i=t-4+1+Vi.length;for(let a=0;a<i;a++){const i=Math.pow(2,s);n.push(i);let o=1/i;a>t-4?o=Vi[a-t+4-1]:0===a&&(o=0),r.push(o);const l=1/(i-2),u=-l,c=1+l,h=[u,u,c,u,c,c,u,u,c,c,u,c],d=6,p=6,f=3,m=2,g=1,x=new Float32Array(f*p*d),y=new Float32Array(m*p*d),v=new Float32Array(g*p*d);for(let t=0;t<d;t++){const e=t%3*2/3-1,n=t>2?0:-1,r=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];x.set(r,f*p*t),y.set(h,m*p*t);const s=[t,t,t,t,t,t];v.set(s,g*p*t)}const b=new js;b.setAttribute("position",new Is(x,f)),b.setAttribute("uv",new Is(y,m)),b.setAttribute("faceIndex",new Is(v,g)),e.push(b),s>4&&s--}return{lodPlanes:e,sizeLods:n,sigmas:r}}(r)),this._blurMaterial=function(t,e,n){const r=new Float32Array(20),s=new ur(0,1,0);return new gi({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:s}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:S,depthTest:!1,depthWrite:!1})}(r,t,e)}return r}_compileMaterial(t){const e=new ci(this._lodPlanes[0],t);this._renderer.compile(e,Gi)}_sceneToCubeUV(t,e,n,r){const s=new yi(90,1,e,n),i=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,u=o.toneMapping;o.getClearColor(Hi),o.toneMapping=et,o.autoClear=!1;const c=new Ms({name:"PMREM.Background",side:y,depthWrite:!1,depthTest:!1}),h=new ci(new di,c);let d=!1;const p=t.background;p?p.isColor&&(c.color.copy(p),t.background=null,d=!0):(c.color.copy(Hi),d=!0);for(let e=0;e<6;e++){const n=e%3;0===n?(s.up.set(0,i[e],0),s.lookAt(a[e],0,0)):1===n?(s.up.set(0,0,i[e]),s.lookAt(0,a[e],0)):(s.up.set(0,i[e],0),s.lookAt(0,0,a[e]));const l=this._cubeSize;Zi(r,n*l,e>2?l:0,l,l),o.setRenderTarget(r),d&&o.render(h,s),o.render(t,s)}h.geometry.dispose(),h.material.dispose(),o.toneMapping=u,o.autoClear=l,t.background=p}_textureToCubeUV(t,e){const n=this._renderer,r=t.mapping===lt||t.mapping===ut;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=ta()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===t.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=Qi());const s=r?this._cubemapMaterial:this._equirectMaterial,i=new ci(this._lodPlanes[0],s);s.uniforms.envMap.value=t;const a=this._cubeSize;Zi(e,0,0,3*a,2*a),n.setRenderTarget(e),n.render(i,Gi)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let e=1;e<this._lodPlanes.length;e++){const n=Math.sqrt(this._sigmas[e]*this._sigmas[e]-this._sigmas[e-1]*this._sigmas[e-1]),r=Ki[(e-1)%Ki.length];this._blur(t,e-1,e,n,r)}e.autoClear=n}_blur(t,e,n,r,s){const i=this._pingPongRenderTarget;this._halfBlur(t,i,e,n,r,"latitudinal",s),this._halfBlur(i,t,n,n,r,"longitudinal",s)}_halfBlur(t,e,n,r,s,i,a){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==i&&"longitudinal"!==i&&console.error("blur direction must be either latitudinal or longitudinal!");const u=new ci(this._lodPlanes[r],l),c=l.uniforms,h=this._sizeLods[n]-1,d=isFinite(s)?Math.PI/(2*h):2*Math.PI/39,p=s/d,f=isFinite(s)?1+Math.floor(3*p):20;f>20&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);const m=[];let g=0;for(let t=0;t<20;++t){const e=t/p,n=Math.exp(-e*e/2);m.push(n),0===t?g+=n:t<f&&(g+=2*n)}for(let t=0;t<m.length;t++)m[t]=m[t]/g;c.envMap.value=t.texture,c.samples.value=f,c.weights.value=m,c.latitudinal.value="latitudinal"===i,a&&(c.poleAxis.value=a);const{_lodMax:x}=this;c.dTheta.value=d,c.mipInt.value=x-n;const y=this._sizeLods[r];Zi(e,3*y*(r>x-4?r-x+4:0),4*(this._cubeSize-y),3*y,2*y),o.setRenderTarget(e),o.render(u,Gi)}}function Ji(t,e,n){const r=new nr(t,e,n);return r.texture.mapping=dt,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function Zi(t,e,n,r,s){t.viewport.set(e,n,r,s),t.scissor.set(e,n,r,s)}function Qi(){return new gi({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:S,depthTest:!1,depthWrite:!1})}function ta(){return new gi({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:S,depthTest:!1,depthWrite:!1})}function ea(t){let e=new WeakMap,n=null;function r(t){const n=t.target;n.removeEventListener("dispose",r);const s=e.get(n);void 0!==s&&(e.delete(n),s.dispose())}return{get:function(s){if(s&&s.isTexture){const i=s.mapping,a=i===ct||i===ht,o=i===lt||i===ut;if(a||o){if(s.isRenderTargetTexture&&!0===s.needsPMREMUpdate){s.needsPMREMUpdate=!1;let r=e.get(s);return null===n&&(n=new Yi(t)),r=a?n.fromEquirectangular(s,r):n.fromCubemap(s,r),e.set(s,r),r.texture}if(e.has(s))return e.get(s).texture;{const i=s.image;if(a&&i&&i.height>0||o&&i&&function(t){let e=0;for(let n=0;n<6;n++)void 0!==t[n]&&e++;return 6===e}(i)){null===n&&(n=new Yi(t));const i=a?n.fromEquirectangular(s):n.fromCubemap(s);return e.set(s,i),s.addEventListener("dispose",r),i.texture}return null}}}return s},dispose:function(){e=new WeakMap,null!==n&&(n.dispose(),n=null)}}}function na(t){const e={};function n(n){if(void 0!==e[n])return e[n];let r;switch(n){case"WEBGL_depth_texture":r=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=t.getExtension(n)}return e[n]=r,r}return{has:function(t){return null!==n(t)},init:function(t){t.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture")},get:function(t){const e=n(t);return null===e&&console.warn("THREE.WebGLRenderer: "+t+" extension not supported."),e}}}function ra(t,e,n,r){const s={},i=new WeakMap;function a(t){const o=t.target;null!==o.index&&e.remove(o.index);for(const t in o.attributes)e.remove(o.attributes[t]);o.removeEventListener("dispose",a),delete s[o.id];const l=i.get(o);l&&(e.remove(l),i.delete(o)),r.releaseStatesOfGeometry(o),!0===o.isInstancedBufferGeometry&&delete o._maxInstanceCount,n.memory.geometries--}function o(t){const n=[],r=t.index,s=t.attributes.position;let a=0;if(null!==r){const t=r.array;a=r.version;for(let e=0,r=t.length;e<r;e+=3){const r=t[e+0],s=t[e+1],i=t[e+2];n.push(r,s,s,i,i,r)}}else{const t=s.array;a=s.version;for(let e=0,r=t.length/3-1;e<r;e+=3){const t=e+0,r=e+1,s=e+2;n.push(t,r,r,s,s,t)}}const o=new(Ln(n)?Fs:Ds)(n,1);o.version=a;const l=i.get(t);l&&e.remove(l),i.set(t,o)}return{get:function(t,e){return!0===s[e.id]||(e.addEventListener("dispose",a),s[e.id]=!0,n.memory.geometries++),e},update:function(t){const n=t.attributes;for(const t in n)e.update(n[t],34962);const r=t.morphAttributes;for(const t in r){const n=r[t];for(let t=0,r=n.length;t<r;t++)e.update(n[t],34962)}},getWireframeAttribute:function(t){const e=i.get(t);if(e){const n=t.index;null!==n&&e.version<n.version&&o(t)}else o(t);return i.get(t)}}}function sa(t,e,n,r){const s=r.isWebGL2;let i,a,o;this.setMode=function(t){i=t},this.setIndex=function(t){a=t.type,o=t.bytesPerElement},this.render=function(e,r){t.drawElements(i,r,a,e*o),n.update(r,i,1)},this.renderInstances=function(r,l,u){if(0===u)return;let c,h;if(s)c=t,h="drawElementsInstanced";else if(c=e.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",null===c)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[h](i,l,a,r*o,u),n.update(l,i,u)}}function ia(t){const e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(t,n,r){switch(e.calls++,n){case 4:e.triangles+=r*(t/3);break;case 1:e.lines+=r*(t/2);break;case 3:e.lines+=r*(t-1);break;case 2:e.lines+=r*t;break;case 0:e.points+=r*t;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function aa(t,e){return t[0]-e[0]}function oa(t,e){return Math.abs(e[1])-Math.abs(t[1])}function la(t,e){let n=1;const r=e.isInterleavedBufferAttribute?e.data.array:e.array;r instanceof Int8Array?n=127:r instanceof Int16Array?n=32767:r instanceof Int32Array?n=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",r),t.divideScalar(n)}function ua(t,e,n){const r={},s=new Float32Array(8),i=new WeakMap,a=new er,o=[];for(let t=0;t<8;t++)o[t]=[t,0];return{update:function(l,u,c,h){const d=l.morphTargetInfluences;if(!0===e.isWebGL2){const p=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,f=void 0!==p?p.length:0;let m=i.get(u);if(void 0===m||m.count!==f){void 0!==m&&m.texture.dispose();const y=void 0!==u.morphAttributes.position,v=void 0!==u.morphAttributes.normal,b=void 0!==u.morphAttributes.color,w=u.morphAttributes.position||[],S=u.morphAttributes.normal||[],_=u.morphAttributes.color||[];let T=0;!0===y&&(T=1),!0===v&&(T=2),!0===b&&(T=3);let M=u.attributes.position.count*T,E=1;M>e.maxTextureSize&&(E=Math.ceil(M/e.maxTextureSize),M=e.maxTextureSize);const k=new Float32Array(M*E*4*f),I=new rr(k,M,E,f);I.type=Nt,I.needsUpdate=!0;const C=4*T;for(let R=0;R<f;R++){const N=w[R],D=S[R],L=_[R],F=M*E*4*R;for(let P=0;P<N.count;P++){const $=P*C;!0===y&&(a.fromBufferAttribute(N,P),!0===N.normalized&&la(a,N),k[F+$+0]=a.x,k[F+$+1]=a.y,k[F+$+2]=a.z,k[F+$+3]=0),!0===v&&(a.fromBufferAttribute(D,P),!0===D.normalized&&la(a,D),k[F+$+4]=a.x,k[F+$+5]=a.y,k[F+$+6]=a.z,k[F+$+7]=0),!0===b&&(a.fromBufferAttribute(L,P),!0===L.normalized&&la(a,L),k[F+$+8]=a.x,k[F+$+9]=a.y,k[F+$+10]=a.z,k[F+$+11]=4===L.itemSize?a.w:1)}}function A(){I.dispose(),i.delete(u),u.removeEventListener("dispose",A)}m={count:f,texture:I,size:new Nn(M,E)},i.set(u,m),u.addEventListener("dispose",A)}let g=0;for(let O=0;O<d.length;O++)g+=d[O];const x=u.morphTargetsRelative?1:1-g;h.getUniforms().setValue(t,"morphTargetBaseInfluence",x),h.getUniforms().setValue(t,"morphTargetInfluences",d),h.getUniforms().setValue(t,"morphTargetsTexture",m.texture,n),h.getUniforms().setValue(t,"morphTargetsTextureSize",m.size)}else{const z=void 0===d?0:d.length;let B=r[u.id];if(void 0===B||B.length!==z){B=[];for(let H=0;H<z;H++)B[H]=[H,0];r[u.id]=B}for(let j=0;j<z;j++){const q=B[j];q[0]=j,q[1]=d[j]}B.sort(oa);for(let X=0;X<8;X++)X<z&&B[X][1]?(o[X][0]=B[X][0],o[X][1]=B[X][1]):(o[X][0]=Number.MAX_SAFE_INTEGER,o[X][1]=0);o.sort(aa);const U=u.morphAttributes.position,W=u.morphAttributes.normal;let V=0;for(let K=0;K<8;K++){const Y=o[K],J=Y[0],Z=Y[1];J!==Number.MAX_SAFE_INTEGER&&Z?(U&&u.getAttribute("morphTarget"+K)!==U[J]&&u.setAttribute("morphTarget"+K,U[J]),W&&u.getAttribute("morphNormal"+K)!==W[J]&&u.setAttribute("morphNormal"+K,W[J]),s[K]=Z,V+=Z):(U&&!0===u.hasAttribute("morphTarget"+K)&&u.deleteAttribute("morphTarget"+K),W&&!0===u.hasAttribute("morphNormal"+K)&&u.deleteAttribute("morphNormal"+K),s[K]=0)}const G=u.morphTargetsRelative?1:1-V;h.getUniforms().setValue(t,"morphTargetBaseInfluence",G),h.getUniforms().setValue(t,"morphTargetInfluences",s)}}}}function ca(t,e,n,r){let s=new WeakMap;function i(t){const e=t.target;e.removeEventListener("dispose",i),n.remove(e.instanceMatrix),null!==e.instanceColor&&n.remove(e.instanceColor)}return{update:function(t){const a=r.render.frame,o=t.geometry,l=e.get(t,o);return s.get(l)!==a&&(e.update(l),s.set(l,a)),t.isInstancedMesh&&(!1===t.hasEventListener("dispose",i)&&t.addEventListener("dispose",i),n.update(t.instanceMatrix,34962),null!==t.instanceColor&&n.update(t.instanceColor,34962)),l},dispose:function(){s=new WeakMap}}}const ha=new tr,da=new rr,pa=new ir,fa=new wi,ma=[],ga=[],xa=new Float32Array(16),ya=new Float32Array(9),va=new Float32Array(4);function ba(t,e,n){const r=t[0];if(r<=0||r>0)return t;const s=e*n;let i=ma[s];if(void 0===i&&(i=new Float32Array(s),ma[s]=i),0!==e){r.toArray(i,0);for(let r=1,s=0;r!==e;++r)s+=n,t[r].toArray(i,s)}return i}function wa(t,e){if(t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}function Sa(t,e){for(let n=0,r=e.length;n<r;n++)t[n]=e[n]}function _a(t,e){let n=ga[e];void 0===n&&(n=new Int32Array(e),ga[e]=n);for(let r=0;r!==e;++r)n[r]=t.allocateTextureUnit();return n}function Ta(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function Ma(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y||(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(wa(n,e))return;t.uniform2fv(this.addr,e),Sa(n,e)}}function Ea(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z||(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(void 0!==e.r)n[0]===e.r&&n[1]===e.g&&n[2]===e.b||(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(wa(n,e))return;t.uniform3fv(this.addr,e),Sa(n,e)}}function ka(t,e){const n=this.cache;if(void 0!==e.x)n[0]===e.x&&n[1]===e.y&&n[2]===e.z&&n[3]===e.w||(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(wa(n,e))return;t.uniform4fv(this.addr,e),Sa(n,e)}}function Ia(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(wa(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),Sa(n,e)}else{if(wa(n,r))return;va.set(r),t.uniformMatrix2fv(this.addr,!1,va),Sa(n,r)}}function Ca(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(wa(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),Sa(n,e)}else{if(wa(n,r))return;ya.set(r),t.uniformMatrix3fv(this.addr,!1,ya),Sa(n,r)}}function Aa(t,e){const n=this.cache,r=e.elements;if(void 0===r){if(wa(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),Sa(n,e)}else{if(wa(n,r))return;xa.set(r),t.uniformMatrix4fv(this.addr,!1,xa),Sa(n,r)}}function Ra(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function Na(t,e){const n=this.cache;wa(n,e)||(t.uniform2iv(this.addr,e),Sa(n,e))}function Da(t,e){const n=this.cache;wa(n,e)||(t.uniform3iv(this.addr,e),Sa(n,e))}function La(t,e){const n=this.cache;wa(n,e)||(t.uniform4iv(this.addr,e),Sa(n,e))}function Fa(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function Pa(t,e){const n=this.cache;wa(n,e)||(t.uniform2uiv(this.addr,e),Sa(n,e))}function $a(t,e){const n=this.cache;wa(n,e)||(t.uniform3uiv(this.addr,e),Sa(n,e))}function Oa(t,e){const n=this.cache;wa(n,e)||(t.uniform4uiv(this.addr,e),Sa(n,e))}function za(t,e,n){const r=this.cache,s=n.allocateTextureUnit();r[0]!==s&&(t.uniform1i(this.addr,s),r[0]=s),n.setTexture2D(e||ha,s)}function Ba(t,e,n){const r=this.cache,s=n.allocateTextureUnit();r[0]!==s&&(t.uniform1i(this.addr,s),r[0]=s),n.setTexture3D(e||pa,s)}function Ua(t,e,n){const r=this.cache,s=n.allocateTextureUnit();r[0]!==s&&(t.uniform1i(this.addr,s),r[0]=s),n.setTextureCube(e||fa,s)}function Wa(t,e,n){const r=this.cache,s=n.allocateTextureUnit();r[0]!==s&&(t.uniform1i(this.addr,s),r[0]=s),n.setTexture2DArray(e||da,s)}function Va(t,e){t.uniform1fv(this.addr,e)}function Ga(t,e){const n=ba(e,this.size,2);t.uniform2fv(this.addr,n)}function Ha(t,e){const n=ba(e,this.size,3);t.uniform3fv(this.addr,n)}function ja(t,e){const n=ba(e,this.size,4);t.uniform4fv(this.addr,n)}function qa(t,e){const n=ba(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function Xa(t,e){const n=ba(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function Ka(t,e){const n=ba(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function Ya(t,e){t.uniform1iv(this.addr,e)}function Ja(t,e){t.uniform2iv(this.addr,e)}function Za(t,e){t.uniform3iv(this.addr,e)}function Qa(t,e){t.uniform4iv(this.addr,e)}function to(t,e){t.uniform1uiv(this.addr,e)}function eo(t,e){t.uniform2uiv(this.addr,e)}function no(t,e){t.uniform3uiv(this.addr,e)}function ro(t,e){t.uniform4uiv(this.addr,e)}function so(t,e,n){const r=e.length,s=_a(n,r);t.uniform1iv(this.addr,s);for(let t=0;t!==r;++t)n.setTexture2D(e[t]||ha,s[t])}function io(t,e,n){const r=e.length,s=_a(n,r);t.uniform1iv(this.addr,s);for(let t=0;t!==r;++t)n.setTexture3D(e[t]||pa,s[t])}function ao(t,e,n){const r=e.length,s=_a(n,r);t.uniform1iv(this.addr,s);for(let t=0;t!==r;++t)n.setTextureCube(e[t]||fa,s[t])}function oo(t,e,n){const r=e.length,s=_a(n,r);t.uniform1iv(this.addr,s);for(let t=0;t!==r;++t)n.setTexture2DArray(e[t]||da,s[t])}function lo(t,e,n){this.id=t,this.addr=n,this.cache=[],this.setValue=function(t){switch(t){case 5126:return Ta;case 35664:return Ma;case 35665:return Ea;case 35666:return ka;case 35674:return Ia;case 35675:return Ca;case 35676:return Aa;case 5124:case 35670:return Ra;case 35667:case 35671:return Na;case 35668:case 35672:return Da;case 35669:case 35673:return La;case 5125:return Fa;case 36294:return Pa;case 36295:return $a;case 36296:return Oa;case 35678:case 36198:case 36298:case 36306:case 35682:return za;case 35679:case 36299:case 36307:return Ba;case 35680:case 36300:case 36308:case 36293:return Ua;case 36289:case 36303:case 36311:case 36292:return Wa}}(e.type)}function uo(t,e,n){this.id=t,this.addr=n,this.cache=[],this.size=e.size,this.setValue=function(t){switch(t){case 5126:return Va;case 35664:return Ga;case 35665:return Ha;case 35666:return ja;case 35674:return qa;case 35675:return Xa;case 35676:return Ka;case 5124:case 35670:return Ya;case 35667:case 35671:return Ja;case 35668:case 35672:return Za;case 35669:case 35673:return Qa;case 5125:return to;case 36294:return eo;case 36295:return no;case 36296:return ro;case 35678:case 36198:case 36298:case 36306:case 35682:return so;case 35679:case 36299:case 36307:return io;case 35680:case 36300:case 36308:case 36293:return ao;case 36289:case 36303:case 36311:case 36292:return oo}}(e.type)}function co(t){this.id=t,this.seq=[],this.map={}}co.prototype.setValue=function(t,e,n){const r=this.seq;for(let s=0,i=r.length;s!==i;++s){const i=r[s];i.setValue(t,e[i.id],n)}};const ho=/(\w+)(\])?(\[|\.)?/g;function po(t,e){t.seq.push(e),t.map[e.id]=e}function fo(t,e,n){const r=t.name,s=r.length;for(ho.lastIndex=0;;){const i=ho.exec(r),a=ho.lastIndex;let o=i[1];const l="]"===i[2],u=i[3];if(l&&(o|=0),void 0===u||"["===u&&a+2===s){po(n,void 0===u?new lo(o,t,e):new uo(o,t,e));break}{let t=n.map[o];void 0===t&&(t=new co(o),po(n,t)),n=t}}}function mo(t,e){this.seq=[],this.map={};const n=t.getProgramParameter(e,35718);for(let r=0;r<n;++r){const n=t.getActiveUniform(e,r);fo(n,t.getUniformLocation(e,n.name),this)}}function go(t,e,n){const r=t.createShader(e);return t.shaderSource(r,n),t.compileShader(r),r}mo.prototype.setValue=function(t,e,n,r){const s=this.map[e];void 0!==s&&s.setValue(t,n,r)},mo.prototype.setOptional=function(t,e,n){const r=e[n];void 0!==r&&this.setValue(t,n,r)},mo.upload=function(t,e,n,r){for(let s=0,i=e.length;s!==i;++s){const i=e[s],a=n[i.id];!1!==a.needsUpdate&&i.setValue(t,a.value,r)}},mo.seqWithValue=function(t,e){const n=[];for(let r=0,s=t.length;r!==s;++r){const s=t[r];s.id in e&&n.push(s)}return n};let xo=0;function yo(t,e,n){const r=t.getShaderParameter(e,35713),s=t.getShaderInfoLog(e).trim();if(r&&""===s)return"";const i=/ERROR: 0:(\d+)/.exec(s);if(i){const r=parseInt(i[0]);return n.toUpperCase()+"\n\n"+s+"\n\n"+function(t,e){const n=t.split("\n"),r=[],s=Math.max(e-6,0),i=Math.min(e+6,n.length);for(let t=s;t<i;t++)r.push(t+1+": "+n[t]);return r.join("\n")}(t.getShaderSource(e),r)}return s}function vo(t,e){const n=function(t){switch(t){case Fe:return["Linear","( value )"];case Pe:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",t),["Linear","( value )"]}}(e);return"vec4 "+t+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function bo(t,e){let n;switch(e){case nt:n="Linear";break;case rt:n="Reinhard";break;case st:n="OptimizedCineon";break;case it:n="ACESFilmic";break;case at:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function wo(t){return""!==t}function So(t,e){return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function _o(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const To=/^[ \t]*#include +<([\w\d./]+)>/gm;function Mo(t){return t.replace(To,Eo)}function Eo(t,e){const n=Di[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return Mo(n)}const ko=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Io=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Co(t){return t.replace(Io,Ro).replace(ko,Ao)}function Ao(t,e,n,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Ro(0,e,n,r)}function Ro(t,e,n,r){let s="";for(let t=parseInt(e);t<parseInt(n);t++)s+=r.replace(/\[\s*i\s*\]/g,"[ "+t+" ]").replace(/UNROLLED_LOOP_INDEX/g,t);return s}function No(t){let e="precision "+t.precision+" float;\nprecision "+t.precision+" int;";return"highp"===t.precision?e+="\n#define HIGH_PRECISION":"mediump"===t.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===t.precision&&(e+="\n#define LOW_PRECISION"),e}function Do(t,e,n,r){const s=t.getContext(),i=n.defines;let a=n.vertexShader,o=n.fragmentShader;const l=function(t){let e="SHADOWMAP_TYPE_BASIC";return t.shadowMapType===f?e="SHADOWMAP_TYPE_PCF":t.shadowMapType===m?e="SHADOWMAP_TYPE_PCF_SOFT":t.shadowMapType===g&&(e="SHADOWMAP_TYPE_VSM"),e}(n),u=function(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case lt:case ut:e="ENVMAP_TYPE_CUBE";break;case dt:e="ENVMAP_TYPE_CUBE_UV"}return e}(n),c=function(t){let e="ENVMAP_MODE_REFLECTION";return t.envMap&&t.envMapMode===ut&&(e="ENVMAP_MODE_REFRACTION"),e}(n),h=function(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case Z:e="ENVMAP_BLENDING_MULTIPLY";break;case Q:e="ENVMAP_BLENDING_MIX";break;case tt:e="ENVMAP_BLENDING_ADD"}return e}(n),d=function(t){const e=t.envMapCubeUVHeight;if(null===e)return null;const n=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:r,maxMip:n}}(n),p=n.isWebGL2?"":function(t){return[t.extensionDerivatives||t.envMapCubeUVHeight||t.bumpMap||t.tangentSpaceNormalMap||t.clearcoatNormalMap||t.flatShading||"physical"===t.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(t.extensionFragDepth||t.logarithmicDepthBuffer)&&t.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",t.extensionDrawBuffers&&t.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(t.extensionShaderTextureLOD||t.envMap||t.transmission)&&t.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(wo).join("\n")}(n),x=function(t){const e=[];for(const n in t){const r=t[n];!1!==r&&e.push("#define "+n+" "+r)}return e.join("\n")}(i),y=s.createProgram();let v,b,w=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(v=[x].filter(wo).join("\n"),v.length>0&&(v+="\n"),b=[p,x].filter(wo).join("\n"),b.length>0&&(b+="\n")):(v=[No(n),"#define SHADER_NAME "+n.shaderName,x,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors&&n.isWebGL2?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0&&n.isWebGL2?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(wo).join("\n"),b=[p,No(n),"#define SHADER_NAME "+n.shaderName,x,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.envMap?"#define "+c:"",n.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",n.specularColorMap?"#define USE_SPECULARCOLORMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEENCOLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==et?"#define TONE_MAPPING":"",n.toneMapping!==et?Di.tonemapping_pars_fragment:"",n.toneMapping!==et?bo("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Di.encodings_pars_fragment,vo("linearToOutputTexel",n.outputEncoding),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(wo).join("\n")),a=Mo(a),a=So(a,n),a=_o(a,n),o=Mo(o),o=So(o,n),o=_o(o,n),a=Co(a),o=Co(o),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(w="#version 300 es\n",v=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+v,b=["#define varying in",n.glslVersion===xn?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===xn?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+b);const S=w+b+o,_=go(s,35633,w+v+a),T=go(s,35632,S);if(s.attachShader(y,_),s.attachShader(y,T),void 0!==n.index0AttributeName?s.bindAttribLocation(y,0,n.index0AttributeName):!0===n.morphTargets&&s.bindAttribLocation(y,0,"position"),s.linkProgram(y),t.debug.checkShaderErrors){const t=s.getProgramInfoLog(y).trim(),e=s.getShaderInfoLog(_).trim(),n=s.getShaderInfoLog(T).trim();let r=!0,i=!0;if(!1===s.getProgramParameter(y,35714)){r=!1;const e=yo(s,_,"vertex"),n=yo(s,T,"fragment");console.error("THREE.WebGLProgram: Shader Error "+s.getError()+" - VALIDATE_STATUS "+s.getProgramParameter(y,35715)+"\n\nProgram Info Log: "+t+"\n"+e+"\n"+n)}else""!==t?console.warn("THREE.WebGLProgram: Program Info Log:",t):""!==e&&""!==n||(i=!1);i&&(this.diagnostics={runnable:r,programLog:t,vertexShader:{log:e,prefix:v},fragmentShader:{log:n,prefix:b}})}let M,E;return s.deleteShader(_),s.deleteShader(T),this.getUniforms=function(){return void 0===M&&(M=new mo(s,y)),M},this.getAttributes=function(){return void 0===E&&(E=function(t,e){const n={},r=t.getProgramParameter(e,35721);for(let s=0;s<r;s++){const r=t.getActiveAttrib(e,s),i=r.name;let a=1;35674===r.type&&(a=2),35675===r.type&&(a=3),35676===r.type&&(a=4),n[i]={type:r.type,location:t.getAttribLocation(e,i),locationSize:a}}return n}(s,y)),E},this.destroy=function(){r.releaseStatesOfProgram(this),s.deleteProgram(y),this.program=void 0},this.name=n.shaderName,this.id=xo++,this.cacheKey=e,this.usedTimes=1,this.program=y,this.vertexShader=_,this.fragmentShader=T,this}let Lo=0;class Fo{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,r=this._getShaderStage(e),s=this._getShaderStage(n),i=this._getShaderCacheForMaterial(t);return!1===i.has(r)&&(i.add(r),r.usedTimes++),!1===i.has(s)&&(i.add(s),s.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const t of e)t.usedTimes--,0===t.usedTimes&&this.shaderCache.delete(t.code);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;return!1===e.has(t)&&e.set(t,new Set),e.get(t)}_getShaderStage(t){const e=this.shaderCache;if(!1===e.has(t)){const n=new Po(t);e.set(t,n)}return e.get(t)}}class Po{constructor(t){this.id=Lo++,this.code=t,this.usedTimes=0}}function $o(t,e,n,r,s,i,a){const o=new Jr,l=new Fo,u=[],c=s.isWebGL2,h=s.logarithmicDepthBuffer,d=s.vertexTextures;let p=s.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(i,o,u,m,g){const x=m.fog,b=g.geometry,w=i.isMeshStandardMaterial?m.environment:null,S=(i.isMeshStandardMaterial?n:e).get(i.envMap||w),T=S&&S.mapping===dt?S.image.height:null,M=f[i.type];null!==i.precision&&(p=s.getMaxPrecision(i.precision),p!==i.precision&&console.warn("THREE.WebGLProgram.getParameters:",i.precision,"not supported, using",p,"instead."));const E=b.morphAttributes.position||b.morphAttributes.normal||b.morphAttributes.color,k=void 0!==E?E.length:0;let I,C,A,R,N=0;if(void 0!==b.morphAttributes.position&&(N=1),void 0!==b.morphAttributes.normal&&(N=2),void 0!==b.morphAttributes.color&&(N=3),M){const t=Fi[M];I=t.vertexShader,C=t.fragmentShader}else I=i.vertexShader,C=i.fragmentShader,l.update(i),A=l.getVertexShaderID(i),R=l.getFragmentShaderID(i);const D=t.getRenderTarget(),L=i.alphaTest>0,F=i.clearcoat>0;return{isWebGL2:c,shaderID:M,shaderName:i.type,vertexShader:I,fragmentShader:C,defines:i.defines,customVertexShaderID:A,customFragmentShaderID:R,isRawShaderMaterial:!0===i.isRawShaderMaterial,glslVersion:i.glslVersion,precision:p,instancing:!0===g.isInstancedMesh,instancingColor:!0===g.isInstancedMesh&&null!==g.instanceColor,supportsVertexTextures:d,outputEncoding:null===D?t.outputEncoding:!0===D.isXRRenderTarget?D.texture.encoding:Fe,map:!!i.map,matcap:!!i.matcap,envMap:!!S,envMapMode:S&&S.mapping,envMapCubeUVHeight:T,lightMap:!!i.lightMap,aoMap:!!i.aoMap,emissiveMap:!!i.emissiveMap,bumpMap:!!i.bumpMap,normalMap:!!i.normalMap,objectSpaceNormalMap:i.normalMapType===Be,tangentSpaceNormalMap:i.normalMapType===ze,decodeVideoTexture:!!i.map&&!0===i.map.isVideoTexture&&i.map.encoding===Pe,clearcoat:F,clearcoatMap:F&&!!i.clearcoatMap,clearcoatRoughnessMap:F&&!!i.clearcoatRoughnessMap,clearcoatNormalMap:F&&!!i.clearcoatNormalMap,displacementMap:!!i.displacementMap,roughnessMap:!!i.roughnessMap,metalnessMap:!!i.metalnessMap,specularMap:!!i.specularMap,specularIntensityMap:!!i.specularIntensityMap,specularColorMap:!!i.specularColorMap,opaque:!1===i.transparent&&i.blending===_,alphaMap:!!i.alphaMap,alphaTest:L,gradientMap:!!i.gradientMap,sheen:i.sheen>0,sheenColorMap:!!i.sheenColorMap,sheenRoughnessMap:!!i.sheenRoughnessMap,transmission:i.transmission>0,transmissionMap:!!i.transmissionMap,thicknessMap:!!i.thicknessMap,combine:i.combine,vertexTangents:!!i.normalMap&&!!b.attributes.tangent,vertexColors:i.vertexColors,vertexAlphas:!0===i.vertexColors&&!!b.attributes.color&&4===b.attributes.color.itemSize,vertexUvs:!!(i.map||i.bumpMap||i.normalMap||i.specularMap||i.alphaMap||i.emissiveMap||i.roughnessMap||i.metalnessMap||i.clearcoatMap||i.clearcoatRoughnessMap||i.clearcoatNormalMap||i.displacementMap||i.transmissionMap||i.thicknessMap||i.specularIntensityMap||i.specularColorMap||i.sheenColorMap||i.sheenRoughnessMap),uvsVertexOnly:!(i.map||i.bumpMap||i.normalMap||i.specularMap||i.alphaMap||i.emissiveMap||i.roughnessMap||i.metalnessMap||i.clearcoatNormalMap||i.transmission>0||i.transmissionMap||i.thicknessMap||i.specularIntensityMap||i.specularColorMap||i.sheen>0||i.sheenColorMap||i.sheenRoughnessMap||!i.displacementMap),fog:!!x,useFog:!0===i.fog,fogExp2:x&&x.isFogExp2,flatShading:!!i.flatShading,sizeAttenuation:i.sizeAttenuation,logarithmicDepthBuffer:h,skinning:!0===g.isSkinnedMesh,morphTargets:void 0!==b.morphAttributes.position,morphNormals:void 0!==b.morphAttributes.normal,morphColors:void 0!==b.morphAttributes.color,morphTargetsCount:k,morphTextureStride:N,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:i.dithering,shadowMapEnabled:t.shadowMap.enabled&&u.length>0,shadowMapType:t.shadowMap.type,toneMapping:i.toneMapped?t.toneMapping:et,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:i.premultipliedAlpha,doubleSided:i.side===v,flipSided:i.side===y,useDepthPacking:!!i.depthPacking,depthPacking:i.depthPacking||0,index0AttributeName:i.index0AttributeName,extensionDerivatives:i.extensions&&i.extensions.derivatives,extensionFragDepth:i.extensions&&i.extensions.fragDepth,extensionDrawBuffers:i.extensions&&i.extensions.drawBuffers,extensionShaderTextureLOD:i.extensions&&i.extensions.shaderTextureLOD,rendererExtensionFragDepth:c||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||r.has("EXT_shader_texture_lod"),customProgramCacheKey:i.customProgramCacheKey()}},getProgramCacheKey:function(e){const n=[];if(e.shaderID?n.push(e.shaderID):(n.push(e.customVertexShaderID),n.push(e.customFragmentShaderID)),void 0!==e.defines)for(const t in e.defines)n.push(t),n.push(e.defines[t]);return!1===e.isRawShaderMaterial&&(function(t,e){t.push(e.precision),t.push(e.outputEncoding),t.push(e.envMapMode),t.push(e.envMapCubeUVHeight),t.push(e.combine),t.push(e.vertexUvs),t.push(e.fogExp2),t.push(e.sizeAttenuation),t.push(e.morphTargetsCount),t.push(e.morphAttributeCount),t.push(e.numDirLights),t.push(e.numPointLights),t.push(e.numSpotLights),t.push(e.numHemiLights),t.push(e.numRectAreaLights),t.push(e.numDirLightShadows),t.push(e.numPointLightShadows),t.push(e.numSpotLightShadows),t.push(e.shadowMapType),t.push(e.toneMapping),t.push(e.numClippingPlanes),t.push(e.numClipIntersection),t.push(e.depthPacking)}(n,e),function(t,e){o.disableAll(),e.isWebGL2&&o.enable(0),e.supportsVertexTextures&&o.enable(1),e.instancing&&o.enable(2),e.instancingColor&&o.enable(3),e.map&&o.enable(4),e.matcap&&o.enable(5),e.envMap&&o.enable(6),e.lightMap&&o.enable(7),e.aoMap&&o.enable(8),e.emissiveMap&&o.enable(9),e.bumpMap&&o.enable(10),e.normalMap&&o.enable(11),e.objectSpaceNormalMap&&o.enable(12),e.tangentSpaceNormalMap&&o.enable(13),e.clearcoat&&o.enable(14),e.clearcoatMap&&o.enable(15),e.clearcoatRoughnessMap&&o.enable(16),e.clearcoatNormalMap&&o.enable(17),e.displacementMap&&o.enable(18),e.specularMap&&o.enable(19),e.roughnessMap&&o.enable(20),e.metalnessMap&&o.enable(21),e.gradientMap&&o.enable(22),e.alphaMap&&o.enable(23),e.alphaTest&&o.enable(24),e.vertexColors&&o.enable(25),e.vertexAlphas&&o.enable(26),e.vertexUvs&&o.enable(27),e.vertexTangents&&o.enable(28),e.uvsVertexOnly&&o.enable(29),e.fog&&o.enable(30),t.push(o.mask),o.disableAll(),e.useFog&&o.enable(0),e.flatShading&&o.enable(1),e.logarithmicDepthBuffer&&o.enable(2),e.skinning&&o.enable(3),e.morphTargets&&o.enable(4),e.morphNormals&&o.enable(5),e.morphColors&&o.enable(6),e.premultipliedAlpha&&o.enable(7),e.shadowMapEnabled&&o.enable(8),e.physicallyCorrectLights&&o.enable(9),e.doubleSided&&o.enable(10),e.flipSided&&o.enable(11),e.useDepthPacking&&o.enable(12),e.dithering&&o.enable(13),e.specularIntensityMap&&o.enable(14),e.specularColorMap&&o.enable(15),e.transmission&&o.enable(16),e.transmissionMap&&o.enable(17),e.thicknessMap&&o.enable(18),e.sheen&&o.enable(19),e.sheenColorMap&&o.enable(20),e.sheenRoughnessMap&&o.enable(21),e.decodeVideoTexture&&o.enable(22),e.opaque&&o.enable(23),t.push(o.mask)}(n,e),n.push(t.outputEncoding)),n.push(e.customProgramCacheKey),n.join()},getUniforms:function(t){const e=f[t.type];let n;if(e){const t=Fi[e];n=mi.clone(t.uniforms)}else n=t.uniforms;return n},acquireProgram:function(e,n){let r;for(let t=0,e=u.length;t<e;t++){const e=u[t];if(e.cacheKey===n){r=e,++r.usedTimes;break}}return void 0===r&&(r=new Do(t,n,e,i),u.push(r)),r},releaseProgram:function(t){if(0==--t.usedTimes){const e=u.indexOf(t);u[e]=u[u.length-1],u.pop(),t.destroy()}},releaseShaderCache:function(t){l.remove(t)},programs:u,dispose:function(){l.dispose()}}}function Oo(){let t=new WeakMap;return{get:function(e){let n=t.get(e);return void 0===n&&(n={},t.set(e,n)),n},remove:function(e){t.delete(e)},update:function(e,n,r){t.get(e)[n]=r},dispose:function(){t=new WeakMap}}}function zo(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function Bo(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function Uo(){const t=[];let e=0;const n=[],r=[],s=[];function i(n,r,s,i,a,o){let l=t[e];return void 0===l?(l={id:n.id,object:n,geometry:r,material:s,groupOrder:i,renderOrder:n.renderOrder,z:a,group:o},t[e]=l):(l.id=n.id,l.object=n,l.geometry=r,l.material=s,l.groupOrder=i,l.renderOrder=n.renderOrder,l.z=a,l.group=o),e++,l}return{opaque:n,transmissive:r,transparent:s,init:function(){e=0,n.length=0,r.length=0,s.length=0},push:function(t,e,a,o,l,u){const c=i(t,e,a,o,l,u);a.transmission>0?r.push(c):!0===a.transparent?s.push(c):n.push(c)},unshift:function(t,e,a,o,l,u){const c=i(t,e,a,o,l,u);a.transmission>0?r.unshift(c):!0===a.transparent?s.unshift(c):n.unshift(c)},finish:function(){for(let n=e,r=t.length;n<r;n++){const e=t[n];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.group=null}},sort:function(t,e){n.length>1&&n.sort(t||zo),r.length>1&&r.sort(e||Bo),s.length>1&&s.sort(e||Bo)}}}function Wo(){let t=new WeakMap;return{get:function(e,n){let r;return!1===t.has(e)?(r=new Uo,t.set(e,[r])):n>=t.get(e).length?(r=new Uo,t.get(e).push(r)):r=t.get(e)[n],r},dispose:function(){t=new WeakMap}}}function Vo(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new ur,color:new Xn};break;case"SpotLight":n={position:new ur,direction:new ur,color:new Xn,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new ur,color:new Xn,distance:0,decay:0};break;case"HemisphereLight":n={direction:new ur,skyColor:new Xn,groundColor:new Xn};break;case"RectAreaLight":n={color:new Xn,position:new ur,halfWidth:new ur,halfHeight:new ur}}return t[e.id]=n,n}}}let Go=0;function Ho(t,e){return(e.castShadow?1:0)-(t.castShadow?1:0)}function jo(t,e){const n=new Vo,r=function(){const t={};return{get:function(e){if(void 0!==t[e.id])return t[e.id];let n;switch(e.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Nn};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Nn,shadowCameraNear:1,shadowCameraFar:1e3}}return t[e.id]=n,n}}}(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let t=0;t<9;t++)s.probe.push(new ur);const i=new ur,a=new Br,o=new Br;return{setup:function(i,a){let o=0,l=0,u=0;for(let t=0;t<9;t++)s.probe[t].set(0,0,0);let c=0,h=0,d=0,p=0,f=0,m=0,g=0,x=0;i.sort(Ho);const y=!0!==a?Math.PI:1;for(let t=0,e=i.length;t<e;t++){const e=i[t],a=e.color,v=e.intensity,b=e.distance,w=e.shadow&&e.shadow.map?e.shadow.map.texture:null;if(e.isAmbientLight)o+=a.r*v*y,l+=a.g*v*y,u+=a.b*v*y;else if(e.isLightProbe)for(let t=0;t<9;t++)s.probe[t].addScaledVector(e.sh.coefficients[t],v);else if(e.isDirectionalLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*y),e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,s.directionalShadow[c]=n,s.directionalShadowMap[c]=w,s.directionalShadowMatrix[c]=e.shadow.matrix,m++}s.directional[c]=t,c++}else if(e.isSpotLight){const t=n.get(e);if(t.position.setFromMatrixPosition(e.matrixWorld),t.color.copy(a).multiplyScalar(v*y),t.distance=b,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.angle*(1-e.penumbra)),t.decay=e.decay,e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,s.spotShadow[d]=n,s.spotShadowMap[d]=w,s.spotShadowMatrix[d]=e.shadow.matrix,x++}s.spot[d]=t,d++}else if(e.isRectAreaLight){const t=n.get(e);t.color.copy(a).multiplyScalar(v),t.halfWidth.set(.5*e.width,0,0),t.halfHeight.set(0,.5*e.height,0),s.rectArea[p]=t,p++}else if(e.isPointLight){const t=n.get(e);if(t.color.copy(e.color).multiplyScalar(e.intensity*y),t.distance=e.distance,t.decay=e.decay,e.castShadow){const t=e.shadow,n=r.get(e);n.shadowBias=t.bias,n.shadowNormalBias=t.normalBias,n.shadowRadius=t.radius,n.shadowMapSize=t.mapSize,n.shadowCameraNear=t.camera.near,n.shadowCameraFar=t.camera.far,s.pointShadow[h]=n,s.pointShadowMap[h]=w,s.pointShadowMatrix[h]=e.shadow.matrix,g++}s.point[h]=t,h++}else if(e.isHemisphereLight){const t=n.get(e);t.skyColor.copy(e.color).multiplyScalar(v*y),t.groundColor.copy(e.groundColor).multiplyScalar(v*y),s.hemi[f]=t,f++}}p>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(s.rectAreaLTC1=Li.LTC_FLOAT_1,s.rectAreaLTC2=Li.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(s.rectAreaLTC1=Li.LTC_HALF_1,s.rectAreaLTC2=Li.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),s.ambient[0]=o,s.ambient[1]=l,s.ambient[2]=u;const v=s.hash;v.directionalLength===c&&v.pointLength===h&&v.spotLength===d&&v.rectAreaLength===p&&v.hemiLength===f&&v.numDirectionalShadows===m&&v.numPointShadows===g&&v.numSpotShadows===x||(s.directional.length=c,s.spot.length=d,s.rectArea.length=p,s.point.length=h,s.hemi.length=f,s.directionalShadow.length=m,s.directionalShadowMap.length=m,s.pointShadow.length=g,s.pointShadowMap.length=g,s.spotShadow.length=x,s.spotShadowMap.length=x,s.directionalShadowMatrix.length=m,s.pointShadowMatrix.length=g,s.spotShadowMatrix.length=x,v.directionalLength=c,v.pointLength=h,v.spotLength=d,v.rectAreaLength=p,v.hemiLength=f,v.numDirectionalShadows=m,v.numPointShadows=g,v.numSpotShadows=x,s.version=Go++)},setupView:function(t,e){let n=0,r=0,l=0,u=0,c=0;const h=e.matrixWorldInverse;for(let e=0,d=t.length;e<d;e++){const d=t[e];if(d.isDirectionalLight){const t=s.directional[n];t.direction.setFromMatrixPosition(d.matrixWorld),i.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(i),t.direction.transformDirection(h),n++}else if(d.isSpotLight){const t=s.spot[l];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),t.direction.setFromMatrixPosition(d.matrixWorld),i.setFromMatrixPosition(d.target.matrixWorld),t.direction.sub(i),t.direction.transformDirection(h),l++}else if(d.isRectAreaLight){const t=s.rectArea[u];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),o.identity(),a.copy(d.matrixWorld),a.premultiply(h),o.extractRotation(a),t.halfWidth.set(.5*d.width,0,0),t.halfHeight.set(0,.5*d.height,0),t.halfWidth.applyMatrix4(o),t.halfHeight.applyMatrix4(o),u++}else if(d.isPointLight){const t=s.point[r];t.position.setFromMatrixPosition(d.matrixWorld),t.position.applyMatrix4(h),r++}else if(d.isHemisphereLight){const t=s.hemi[c];t.direction.setFromMatrixPosition(d.matrixWorld),t.direction.transformDirection(h),c++}}},state:s}}function qo(t,e){const n=new jo(t,e),r=[],s=[];return{init:function(){r.length=0,s.length=0},state:{lightsArray:r,shadowsArray:s,lights:n},setupLights:function(t){n.setup(r,t)},setupLightsView:function(t){n.setupView(r,t)},pushLight:function(t){r.push(t)},pushShadow:function(t){s.push(t)}}}function Xo(t,e){let n=new WeakMap;return{get:function(r,s=0){let i;return!1===n.has(r)?(i=new qo(t,e),n.set(r,[i])):s>=n.get(r).length?(i=new qo(t,e),n.get(r).push(i)):i=n.get(r)[s],i},dispose:function(){n=new WeakMap}}}class Ko extends Ts{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=$e,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}Ko.prototype.isMeshDepthMaterial=!0;class Yo extends Ts{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new ur,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}function Jo(t,e,n){let r=new Ci;const s=new Nn,i=new Nn,a=new er,o=new Ko({depthPacking:Oe}),l=new Yo,u={},c=n.maxTextureSize,h={0:y,1:x,2:v},d=new gi({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Nn},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const m=new js;m.setAttribute("position",new Is(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const b=new ci(m,d),w=this;function _(n,r){const s=e.update(b);d.defines.VSM_SAMPLES!==n.blurSamples&&(d.defines.VSM_SAMPLES=n.blurSamples,p.defines.VSM_SAMPLES=n.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),d.uniforms.shadow_pass.value=n.map.texture,d.uniforms.resolution.value=n.mapSize,d.uniforms.radius.value=n.radius,t.setRenderTarget(n.mapPass),t.clear(),t.renderBufferDirect(r,null,s,d,b,null),p.uniforms.shadow_pass.value=n.mapPass.texture,p.uniforms.resolution.value=n.mapSize,p.uniforms.radius.value=n.radius,t.setRenderTarget(n.map),t.clear(),t.renderBufferDirect(r,null,s,p,b,null)}function T(e,n,r,s,i,a){let c=null;const d=!0===r.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(c=void 0!==d?d:!0===r.isPointLight?l:o,t.localClippingEnabled&&!0===n.clipShadows&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0){const t=c.uuid,e=n.uuid;let r=u[t];void 0===r&&(r={},u[t]=r);let s=r[e];void 0===s&&(s=c.clone(),r[e]=s),c=s}return c.visible=n.visible,c.wireframe=n.wireframe,c.side=a===g?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:h[n.side],c.alphaMap=n.alphaMap,c.alphaTest=n.alphaTest,c.clipShadows=n.clipShadows,c.clippingPlanes=n.clippingPlanes,c.clipIntersection=n.clipIntersection,c.displacementMap=n.displacementMap,c.displacementScale=n.displacementScale,c.displacementBias=n.displacementBias,c.wireframeLinewidth=n.wireframeLinewidth,c.linewidth=n.linewidth,!0===r.isPointLight&&!0===c.isMeshDistanceMaterial&&(c.referencePosition.setFromMatrixPosition(r.matrixWorld),c.nearDistance=s,c.farDistance=i),c}function M(n,s,i,a,o){if(!1===n.visible)return;if(n.layers.test(s.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&o===g)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,n.matrixWorld);const r=e.update(n),s=n.material;if(Array.isArray(s)){const e=r.groups;for(let l=0,u=e.length;l<u;l++){const u=e[l],c=s[u.materialIndex];if(c&&c.visible){const e=T(n,c,a,i.near,i.far,o);t.renderBufferDirect(i,null,r,e,n,u)}}}else if(s.visible){const e=T(n,s,a,i.near,i.far,o);t.renderBufferDirect(i,null,r,e,n,null)}}const l=n.children;for(let t=0,e=l.length;t<e;t++)M(l[t],s,i,a,o)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=f,this.render=function(e,n,o){if(!1===w.enabled)return;if(!1===w.autoUpdate&&!1===w.needsUpdate)return;if(0===e.length)return;const l=t.getRenderTarget(),u=t.getActiveCubeFace(),h=t.getActiveMipmapLevel(),d=t.state;d.setBlending(S),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let l=0,u=e.length;l<u;l++){const u=e[l],h=u.shadow;if(void 0===h){console.warn("THREE.WebGLShadowMap:",u,"has no shadow.");continue}if(!1===h.autoUpdate&&!1===h.needsUpdate)continue;s.copy(h.mapSize);const p=h.getFrameExtents();if(s.multiply(p),i.copy(h.mapSize),(s.x>c||s.y>c)&&(s.x>c&&(i.x=Math.floor(c/p.x),s.x=i.x*p.x,h.mapSize.x=i.x),s.y>c&&(i.y=Math.floor(c/p.y),s.y=i.y*p.y,h.mapSize.y=i.y)),null!==h.map||h.isPointLightShadow||this.type!==g||(h.map=new nr(s.x,s.y),h.map.texture.name=u.name+".shadowMap",h.mapPass=new nr(s.x,s.y),h.camera.updateProjectionMatrix()),null===h.map){const t={minFilter:gt,magFilter:gt,format:zt};h.map=new nr(s.x,s.y,t),h.map.texture.name=u.name+".shadowMap",h.camera.updateProjectionMatrix()}t.setRenderTarget(h.map),t.clear();const f=h.getViewportCount();for(let t=0;t<f;t++){const e=h.getViewport(t);a.set(i.x*e.x,i.y*e.y,i.x*e.z,i.y*e.w),d.viewport(a),h.updateMatrices(u,t),r=h.getFrustum(),M(n,o,h.camera,u,this.type)}h.isPointLightShadow||this.type!==g||_(h,o),h.needsUpdate=!1}w.needsUpdate=!1,t.setRenderTarget(l,u,h)}}function Zo(t,e,n){const r=n.isWebGL2,s=new function(){let e=!1;const n=new er;let r=null;const s=new er(0,0,0,0);return{setMask:function(n){r===n||e||(t.colorMask(n,n,n,n),r=n)},setLocked:function(t){e=t},setClear:function(e,r,i,a,o){!0===o&&(e*=a,r*=a,i*=a),n.set(e,r,i,a),!1===s.equals(n)&&(t.clearColor(e,r,i,a),s.copy(n))},reset:function(){e=!1,r=null,s.set(-1,0,0,0)}}},i=new function(){let e=!1,n=null,r=null,s=null;return{setTest:function(t){t?vt(2929):bt(2929)},setMask:function(r){n===r||e||(t.depthMask(r),n=r)},setFunc:function(e){if(r!==e){if(e)switch(e){case G:t.depthFunc(512);break;case H:t.depthFunc(519);break;case j:t.depthFunc(513);break;case q:t.depthFunc(515);break;case X:t.depthFunc(514);break;case K:t.depthFunc(518);break;case Y:t.depthFunc(516);break;case J:t.depthFunc(517);break;default:t.depthFunc(515)}else t.depthFunc(515);r=e}},setLocked:function(t){e=t},setClear:function(e){s!==e&&(t.clearDepth(e),s=e)},reset:function(){e=!1,n=null,r=null,s=null}}},a=new function(){let e=!1,n=null,r=null,s=null,i=null,a=null,o=null,l=null,u=null;return{setTest:function(t){e||(t?vt(2960):bt(2960))},setMask:function(r){n===r||e||(t.stencilMask(r),n=r)},setFunc:function(e,n,a){r===e&&s===n&&i===a||(t.stencilFunc(e,n,a),r=e,s=n,i=a)},setOp:function(e,n,r){a===e&&o===n&&l===r||(t.stencilOp(e,n,r),a=e,o=n,l=r)},setLocked:function(t){e=t},setClear:function(e){u!==e&&(t.clearStencil(e),u=e)},reset:function(){e=!1,n=null,r=null,s=null,i=null,a=null,o=null,l=null,u=null}}};let o={},l={},d=new WeakMap,p=[],f=null,m=!1,g=null,x=null,b=null,w=null,Z=null,Q=null,tt=null,et=!1,nt=null,rt=null,st=null,it=null,at=null;const ot=t.getParameter(35661);let lt=!1,ut=0;const ct=t.getParameter(7938);-1!==ct.indexOf("WebGL")?(ut=parseFloat(/^WebGL (\d)/.exec(ct)[1]),lt=ut>=1):-1!==ct.indexOf("OpenGL ES")&&(ut=parseFloat(/^OpenGL ES (\d)/.exec(ct)[1]),lt=ut>=2);let ht=null,dt={};const pt=t.getParameter(3088),ft=t.getParameter(2978),mt=(new er).fromArray(pt),gt=(new er).fromArray(ft);function xt(e,n,r){const s=new Uint8Array(4),i=t.createTexture();t.bindTexture(e,i),t.texParameteri(e,10241,9728),t.texParameteri(e,10240,9728);for(let e=0;e<r;e++)t.texImage2D(n+e,0,6408,1,1,0,6408,5121,s);return i}const yt={};function vt(e){!0!==o[e]&&(t.enable(e),o[e]=!0)}function bt(e){!1!==o[e]&&(t.disable(e),o[e]=!1)}yt[3553]=xt(3553,3553,1),yt[34067]=xt(34067,34069,6),s.setClear(0,0,0,1),i.setClear(1),a.setClear(0),vt(2929),i.setFunc(q),Tt(!1),Mt(c),vt(2884),_t(S);const wt={[I]:32774,[C]:32778,[A]:32779};if(r)wt[R]=32775,wt[N]=32776;else{const t=e.get("EXT_blend_minmax");null!==t&&(wt[R]=t.MIN_EXT,wt[N]=t.MAX_EXT)}const St={[D]:0,[L]:1,[F]:768,[$]:770,[V]:776,[U]:774,[z]:772,[P]:769,[O]:771,[W]:775,[B]:773};function _t(e,n,r,s,i,a,o,l){if(e!==S){if(!1===m&&(vt(3042),m=!0),e===k)i=i||n,a=a||r,o=o||s,n===x&&i===Z||(t.blendEquationSeparate(wt[n],wt[i]),x=n,Z=i),r===b&&s===w&&a===Q&&o===tt||(t.blendFuncSeparate(St[r],St[s],St[a],St[o]),b=r,w=s,Q=a,tt=o),g=e,et=null;else if(e!==g||l!==et){if(x===I&&Z===I||(t.blendEquation(32774),x=I,Z=I),l)switch(e){case _:t.blendFuncSeparate(1,771,1,771);break;case T:t.blendFunc(1,1);break;case M:t.blendFuncSeparate(0,769,0,1);break;case E:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case _:t.blendFuncSeparate(770,771,1,771);break;case T:t.blendFunc(770,1);break;case M:t.blendFuncSeparate(0,769,0,1);break;case E:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}b=null,w=null,Q=null,tt=null,g=e,et=l}}else!0===m&&(bt(3042),m=!1)}function Tt(e){nt!==e&&(e?t.frontFace(2304):t.frontFace(2305),nt=e)}function Mt(e){e!==u?(vt(2884),e!==rt&&(e===c?t.cullFace(1029):e===h?t.cullFace(1028):t.cullFace(1032))):bt(2884),rt=e}function Et(e,n,r){e?(vt(32823),it===n&&at===r||(t.polygonOffset(n,r),it=n,at=r)):bt(32823)}function kt(e){void 0===e&&(e=33984+ot-1),ht!==e&&(t.activeTexture(e),ht=e)}return{buffers:{color:s,depth:i,stencil:a},enable:vt,disable:bt,bindFramebuffer:function(e,n){return l[e]!==n&&(t.bindFramebuffer(e,n),l[e]=n,r&&(36009===e&&(l[36160]=n),36160===e&&(l[36009]=n)),!0)},drawBuffers:function(r,s){let i=p,a=!1;if(r)if(i=d.get(s),void 0===i&&(i=[],d.set(s,i)),r.isWebGLMultipleRenderTargets){const t=r.texture;if(i.length!==t.length||36064!==i[0]){for(let e=0,n=t.length;e<n;e++)i[e]=36064+e;i.length=t.length,a=!0}}else 36064!==i[0]&&(i[0]=36064,a=!0);else 1029!==i[0]&&(i[0]=1029,a=!0);a&&(n.isWebGL2?t.drawBuffers(i):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(i))},useProgram:function(e){return f!==e&&(t.useProgram(e),f=e,!0)},setBlending:_t,setMaterial:function(t,e){t.side===v?bt(2884):vt(2884);let n=t.side===y;e&&(n=!n),Tt(n),t.blending===_&&!1===t.transparent?_t(S):_t(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),i.setFunc(t.depthFunc),i.setTest(t.depthTest),i.setMask(t.depthWrite),s.setMask(t.colorWrite);const r=t.stencilWrite;a.setTest(r),r&&(a.setMask(t.stencilWriteMask),a.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),a.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),Et(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?vt(32926):bt(32926)},setFlipSided:Tt,setCullFace:Mt,setLineWidth:function(e){e!==st&&(lt&&t.lineWidth(e),st=e)},setPolygonOffset:Et,setScissorTest:function(t){t?vt(3089):bt(3089)},activeTexture:kt,bindTexture:function(e,n){null===ht&&kt();let r=dt[ht];void 0===r&&(r={type:void 0,texture:void 0},dt[ht]=r),r.type===e&&r.texture===n||(t.bindTexture(e,n||yt[e]),r.type=e,r.texture=n)},unbindTexture:function(){const e=dt[ht];void 0!==e&&void 0!==e.type&&(t.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function(){try{t.texImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage2D:function(){try{t.texStorage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage3D:function(){try{t.texStorage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage2D:function(){try{t.texSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage3D:function(){try{t.texSubImage3D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage2D:function(){try{t.compressedTexSubImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function(e){!1===mt.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),mt.copy(e))},viewport:function(e){!1===gt.equals(e)&&(t.viewport(e.x,e.y,e.z,e.w),gt.copy(e))},reset:function(){t.disable(3042),t.disable(2884),t.disable(2929),t.disable(32823),t.disable(3089),t.disable(2960),t.disable(32926),t.blendEquation(32774),t.blendFunc(1,0),t.blendFuncSeparate(1,0,1,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(513),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(519,0,4294967295),t.stencilOp(7680,7680,7680),t.clearStencil(0),t.cullFace(1029),t.frontFace(2305),t.polygonOffset(0,0),t.activeTexture(33984),t.bindFramebuffer(36160,null),!0===r&&(t.bindFramebuffer(36009,null),t.bindFramebuffer(36008,null)),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),o={},ht=null,dt={},l={},d=new WeakMap,p=[],f=null,m=!1,g=null,x=null,b=null,w=null,Z=null,Q=null,tt=null,et=!1,nt=null,rt=null,st=null,it=null,at=null,mt.set(0,0,t.canvas.width,t.canvas.height),gt.set(0,0,t.canvas.width,t.canvas.height),s.reset(),i.reset(),a.reset()}}}function Qo(t,e,n,r,s,i,a){const o=s.isWebGL2,l=s.maxTextures,u=s.maxCubemapSize,c=s.maxTextureSize,h=s.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,p=/OculusBrowser/g.test(navigator.userAgent),f=new WeakMap;let m;const g=new WeakMap;let x=!1;try{x="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}function y(t,e){return x?new OffscreenCanvas(t,e):$n("canvas")}function v(t,e,n,r){let s=1;if((t.width>r||t.height>r)&&(s=r/Math.max(t.width,t.height)),s<1||!0===e){if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap){const r=e?An:Math.floor,i=r(s*t.width),a=r(s*t.height);void 0===m&&(m=y(i,a));const o=n?y(i,a):m;return o.width=i,o.height=a,o.getContext("2d").drawImage(t,0,0,i,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+t.width+"x"+t.height+") to ("+i+"x"+a+")."),o}return"data"in t&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+t.width+"x"+t.height+")."),t}return t}function b(t){return In(t.width)&&In(t.height)}function w(t,e){return t.generateMipmaps&&e&&t.minFilter!==gt&&t.minFilter!==wt}function S(e){t.generateMipmap(e)}function _(n,r,s,i,a=!1){if(!1===o)return r;if(null!==n){if(void 0!==t[n])return t[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let l=r;return 6403===r&&(5126===s&&(l=33326),5131===s&&(l=33325),5121===s&&(l=33321)),33319===r&&(5126===s&&(l=33328),5131===s&&(l=33327),5121===s&&(l=33323)),6408===r&&(5126===s&&(l=34836),5131===s&&(l=34842),5121===s&&(l=i===Pe&&!1===a?35907:32856),32819===s&&(l=32854),32820===s&&(l=32855)),33325!==l&&33326!==l&&33327!==l&&33328!==l&&34842!==l&&34836!==l||e.get("EXT_color_buffer_float"),l}function T(t,e,n){return!0===w(t,n)||t.isFramebufferTexture&&t.minFilter!==gt&&t.minFilter!==wt?Math.log2(Math.max(e.width,e.height))+1:void 0!==t.mipmaps&&t.mipmaps.length>0?t.mipmaps.length:t.isCompressedTexture&&Array.isArray(t.image)?e.mipmaps.length:1}function M(t){return t===gt||t===xt||t===vt?9728:9729}function E(t){const e=t.target;e.removeEventListener("dispose",E),function(t){const e=r.get(t);if(void 0===e.__webglInit)return;const n=t.source,s=g.get(n);if(s){const r=s[e.__cacheKey];r.usedTimes--,0===r.usedTimes&&I(t),0===Object.keys(s).length&&g.delete(n)}r.remove(t)}(e),e.isVideoTexture&&f.delete(e)}function k(e){const n=e.target;n.removeEventListener("dispose",k),function(e){const n=e.texture,s=r.get(e),i=r.get(n);if(void 0!==i.__webglTexture&&(t.deleteTexture(i.__webglTexture),a.memory.textures--),e.depthTexture&&e.depthTexture.dispose(),e.isWebGLCubeRenderTarget)for(let e=0;e<6;e++)t.deleteFramebuffer(s.__webglFramebuffer[e]),s.__webglDepthbuffer&&t.deleteRenderbuffer(s.__webglDepthbuffer[e]);else t.deleteFramebuffer(s.__webglFramebuffer),s.__webglDepthbuffer&&t.deleteRenderbuffer(s.__webglDepthbuffer),s.__webglMultisampledFramebuffer&&t.deleteFramebuffer(s.__webglMultisampledFramebuffer),s.__webglColorRenderbuffer&&t.deleteRenderbuffer(s.__webglColorRenderbuffer),s.__webglDepthRenderbuffer&&t.deleteRenderbuffer(s.__webglDepthRenderbuffer);if(e.isWebGLMultipleRenderTargets)for(let e=0,s=n.length;e<s;e++){const s=r.get(n[e]);s.__webglTexture&&(t.deleteTexture(s.__webglTexture),a.memory.textures--),r.remove(n[e])}r.remove(n),r.remove(e)}(n)}function I(e){const n=r.get(e);t.deleteTexture(n.__webglTexture);const s=e.source;delete g.get(s)[n.__cacheKey],a.memory.textures--}let C=0;function A(t,e){const s=r.get(t);if(t.isVideoTexture&&function(t){const e=a.render.frame;f.get(t)!==e&&(f.set(t,e),t.update())}(t),!1===t.isRenderTargetTexture&&t.version>0&&s.__version!==t.version){const n=t.image;if(null===n)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==n.complete)return void F(s,t,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(33984+e),n.bindTexture(3553,s.__webglTexture)}const R={[pt]:10497,[ft]:33071,[mt]:33648},N={[gt]:9728,[xt]:9984,[vt]:9986,[wt]:9729,[St]:9985,[Tt]:9987};function D(n,i,a){if(a?(t.texParameteri(n,10242,R[i.wrapS]),t.texParameteri(n,10243,R[i.wrapT]),32879!==n&&35866!==n||t.texParameteri(n,32882,R[i.wrapR]),t.texParameteri(n,10240,N[i.magFilter]),t.texParameteri(n,10241,N[i.minFilter])):(t.texParameteri(n,10242,33071),t.texParameteri(n,10243,33071),32879!==n&&35866!==n||t.texParameteri(n,32882,33071),i.wrapS===ft&&i.wrapT===ft||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),t.texParameteri(n,10240,M(i.magFilter)),t.texParameteri(n,10241,M(i.minFilter)),i.minFilter!==gt&&i.minFilter!==wt&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){const a=e.get("EXT_texture_filter_anisotropic");if(i.type===Nt&&!1===e.has("OES_texture_float_linear"))return;if(!1===o&&i.type===Dt&&!1===e.has("OES_texture_half_float_linear"))return;(i.anisotropy>1||r.get(i).__currentAnisotropy)&&(t.texParameterf(n,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(i.anisotropy,s.getMaxAnisotropy())),r.get(i).__currentAnisotropy=i.anisotropy)}}function L(e,n){let r=!1;void 0===e.__webglInit&&(e.__webglInit=!0,n.addEventListener("dispose",E));const s=n.source;let i=g.get(s);void 0===i&&(i={},g.set(s,i));const o=function(t){const e=[];return e.push(t.wrapS),e.push(t.wrapT),e.push(t.magFilter),e.push(t.minFilter),e.push(t.anisotropy),e.push(t.internalFormat),e.push(t.format),e.push(t.type),e.push(t.generateMipmaps),e.push(t.premultiplyAlpha),e.push(t.flipY),e.push(t.unpackAlignment),e.push(t.encoding),e.join()}(n);if(o!==e.__cacheKey){void 0===i[o]&&(i[o]={texture:t.createTexture(),usedTimes:0},a.memory.textures++,r=!0),i[o].usedTimes++;const s=i[e.__cacheKey];void 0!==s&&(i[e.__cacheKey].usedTimes--,0===s.usedTimes&&I(n)),e.__cacheKey=o,e.__webglTexture=i[o].texture}return r}function F(e,r,s){let a=3553;r.isDataArrayTexture&&(a=35866),r.isData3DTexture&&(a=32879);const l=L(e,r),u=r.source;if(n.activeTexture(33984+s),n.bindTexture(a,e.__webglTexture),u.version!==u.__currentVersion||!0===l){t.pixelStorei(37440,r.flipY),t.pixelStorei(37441,r.premultiplyAlpha),t.pixelStorei(3317,r.unpackAlignment),t.pixelStorei(37443,0);const s=function(t){return!o&&(t.wrapS!==ft||t.wrapT!==ft||t.minFilter!==gt&&t.minFilter!==wt)}(r)&&!1===b(r.image);let h=v(r.image,s,!1,c);h=U(r,h);const d=b(h)||o,p=i.convert(r.format,r.encoding);let f,m=i.convert(r.type),g=_(r.internalFormat,p,m,r.encoding,r.isVideoTexture);D(a,r,d);const x=r.mipmaps,y=o&&!0!==r.isVideoTexture,M=void 0===e.__version||!0===l,E=T(r,h,d);if(r.isDepthTexture)g=6402,o?g=r.type===Nt?36012:r.type===Rt?33190:r.type===Pt?35056:33189:r.type===Nt&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===Wt&&6402===g&&r.type!==Ct&&r.type!==Rt&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=Ct,m=i.convert(r.type)),r.format===Vt&&6402===g&&(g=34041,r.type!==Pt&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=Pt,m=i.convert(r.type))),M&&(y?n.texStorage2D(3553,1,g,h.width,h.height):n.texImage2D(3553,0,g,h.width,h.height,0,p,m,null));else if(r.isDataTexture)if(x.length>0&&d){y&&M&&n.texStorage2D(3553,E,g,x[0].width,x[0].height);for(let t=0,e=x.length;t<e;t++)f=x[t],y?n.texSubImage2D(3553,t,0,0,f.width,f.height,p,m,f.data):n.texImage2D(3553,t,g,f.width,f.height,0,p,m,f.data);r.generateMipmaps=!1}else y?(M&&n.texStorage2D(3553,E,g,h.width,h.height),n.texSubImage2D(3553,0,0,0,h.width,h.height,p,m,h.data)):n.texImage2D(3553,0,g,h.width,h.height,0,p,m,h.data);else if(r.isCompressedTexture){y&&M&&n.texStorage2D(3553,E,g,x[0].width,x[0].height);for(let t=0,e=x.length;t<e;t++)f=x[t],r.format!==zt?null!==p?y?n.compressedTexSubImage2D(3553,t,0,0,f.width,f.height,p,f.data):n.compressedTexImage2D(3553,t,g,f.width,f.height,0,f.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):y?n.texSubImage2D(3553,t,0,0,f.width,f.height,p,m,f.data):n.texImage2D(3553,t,g,f.width,f.height,0,p,m,f.data)}else if(r.isDataArrayTexture)y?(M&&n.texStorage3D(35866,E,g,h.width,h.height,h.depth),n.texSubImage3D(35866,0,0,0,0,h.width,h.height,h.depth,p,m,h.data)):n.texImage3D(35866,0,g,h.width,h.height,h.depth,0,p,m,h.data);else if(r.isData3DTexture)y?(M&&n.texStorage3D(32879,E,g,h.width,h.height,h.depth),n.texSubImage3D(32879,0,0,0,0,h.width,h.height,h.depth,p,m,h.data)):n.texImage3D(32879,0,g,h.width,h.height,h.depth,0,p,m,h.data);else if(r.isFramebufferTexture){if(M)if(y)n.texStorage2D(3553,E,g,h.width,h.height);else{let t=h.width,e=h.height;for(let r=0;r<E;r++)n.texImage2D(3553,r,g,t,e,0,p,m,null),t>>=1,e>>=1}}else if(x.length>0&&d){y&&M&&n.texStorage2D(3553,E,g,x[0].width,x[0].height);for(let t=0,e=x.length;t<e;t++)f=x[t],y?n.texSubImage2D(3553,t,0,0,p,m,f):n.texImage2D(3553,t,g,p,m,f);r.generateMipmaps=!1}else y?(M&&n.texStorage2D(3553,E,g,h.width,h.height),n.texSubImage2D(3553,0,0,0,p,m,h)):n.texImage2D(3553,0,g,p,m,h);w(r,d)&&S(a),u.__currentVersion=u.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}function P(e,s,a,o,l){const u=i.convert(a.format,a.encoding),c=i.convert(a.type),h=_(a.internalFormat,u,c,a.encoding);r.get(s).__hasExternalTextures||(32879===l||35866===l?n.texImage3D(l,0,h,s.width,s.height,s.depth,0,u,c,null):n.texImage2D(l,0,h,s.width,s.height,0,u,c,null)),n.bindFramebuffer(36160,e),B(s)?d.framebufferTexture2DMultisampleEXT(36160,o,l,r.get(a).__webglTexture,0,z(s)):t.framebufferTexture2D(36160,o,l,r.get(a).__webglTexture,0),n.bindFramebuffer(36160,null)}function $(e,n,r){if(t.bindRenderbuffer(36161,e),n.depthBuffer&&!n.stencilBuffer){let s=33189;if(r||B(n)){const e=n.depthTexture;e&&e.isDepthTexture&&(e.type===Nt?s=36012:e.type===Rt&&(s=33190));const r=z(n);B(n)?d.renderbufferStorageMultisampleEXT(36161,r,s,n.width,n.height):t.renderbufferStorageMultisample(36161,r,s,n.width,n.height)}else t.renderbufferStorage(36161,s,n.width,n.height);t.framebufferRenderbuffer(36160,36096,36161,e)}else if(n.depthBuffer&&n.stencilBuffer){const s=z(n);r&&!1===B(n)?t.renderbufferStorageMultisample(36161,s,35056,n.width,n.height):B(n)?d.renderbufferStorageMultisampleEXT(36161,s,35056,n.width,n.height):t.renderbufferStorage(36161,34041,n.width,n.height),t.framebufferRenderbuffer(36160,33306,36161,e)}else{const e=!0===n.isWebGLMultipleRenderTargets?n.texture[0]:n.texture,s=i.convert(e.format,e.encoding),a=i.convert(e.type),o=_(e.internalFormat,s,a,e.encoding),l=z(n);r&&!1===B(n)?t.renderbufferStorageMultisample(36161,l,o,n.width,n.height):B(n)?d.renderbufferStorageMultisampleEXT(36161,l,o,n.width,n.height):t.renderbufferStorage(36161,o,n.width,n.height)}t.bindRenderbuffer(36161,null)}function O(e){const s=r.get(e),i=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture&&!s.__autoAllocateDepthBuffer){if(i)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,s){if(s&&s.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,e),!s.depthTexture||!s.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(s.depthTexture).__webglTexture&&s.depthTexture.image.width===s.width&&s.depthTexture.image.height===s.height||(s.depthTexture.image.width=s.width,s.depthTexture.image.height=s.height,s.depthTexture.needsUpdate=!0),A(s.depthTexture,0);const i=r.get(s.depthTexture).__webglTexture,a=z(s);if(s.depthTexture.format===Wt)B(s)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,i,0,a):t.framebufferTexture2D(36160,36096,3553,i,0);else{if(s.depthTexture.format!==Vt)throw new Error("Unknown depthTexture format");B(s)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,i,0,a):t.framebufferTexture2D(36160,33306,3553,i,0)}}(s.__webglFramebuffer,e)}else if(i){s.__webglDepthbuffer=[];for(let r=0;r<6;r++)n.bindFramebuffer(36160,s.__webglFramebuffer[r]),s.__webglDepthbuffer[r]=t.createRenderbuffer(),$(s.__webglDepthbuffer[r],e,!1)}else n.bindFramebuffer(36160,s.__webglFramebuffer),s.__webglDepthbuffer=t.createRenderbuffer(),$(s.__webglDepthbuffer,e,!1);n.bindFramebuffer(36160,null)}function z(t){return Math.min(h,t.samples)}function B(t){const n=r.get(t);return o&&t.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==n.__useRenderToTexture}function U(t,n){const r=t.encoding,s=t.format,i=t.type;return!0===t.isCompressedTexture||!0===t.isVideoTexture||t.format===yn||r!==Fe&&(r===Pe?!1===o?!0===e.has("EXT_sRGB")&&s===zt?(t.format=yn,t.minFilter=wt,t.generateMipmaps=!1):n=Yn.sRGBToLinear(n):s===zt&&i===Et||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",r)),n}this.allocateTextureUnit=function(){const t=C;return t>=l&&console.warn("THREE.WebGLTextures: Trying to use "+t+" texture units while this GPU supports only "+l),C+=1,t},this.resetTextureUnits=function(){C=0},this.setTexture2D=A,this.setTexture2DArray=function(t,e){const s=r.get(t);t.version>0&&s.__version!==t.version?F(s,t,e):(n.activeTexture(33984+e),n.bindTexture(35866,s.__webglTexture))},this.setTexture3D=function(t,e){const s=r.get(t);t.version>0&&s.__version!==t.version?F(s,t,e):(n.activeTexture(33984+e),n.bindTexture(32879,s.__webglTexture))},this.setTextureCube=function(e,s){const a=r.get(e);e.version>0&&a.__version!==e.version?function(e,r,s){if(6!==r.image.length)return;const a=L(e,r),l=r.source;if(n.activeTexture(33984+s),n.bindTexture(34067,e.__webglTexture),l.version!==l.__currentVersion||!0===a){t.pixelStorei(37440,r.flipY),t.pixelStorei(37441,r.premultiplyAlpha),t.pixelStorei(3317,r.unpackAlignment),t.pixelStorei(37443,0);const s=r.isCompressedTexture||r.image[0].isCompressedTexture,a=r.image[0]&&r.image[0].isDataTexture,c=[];for(let t=0;t<6;t++)c[t]=s||a?a?r.image[t].image:r.image[t]:v(r.image[t],!1,!0,u),c[t]=U(r,c[t]);const h=c[0],d=b(h)||o,p=i.convert(r.format,r.encoding),f=i.convert(r.type),m=_(r.internalFormat,p,f,r.encoding),g=o&&!0!==r.isVideoTexture,x=void 0===e.__version;let y,M=T(r,h,d);if(D(34067,r,d),s){g&&x&&n.texStorage2D(34067,M,m,h.width,h.height);for(let t=0;t<6;t++){y=c[t].mipmaps;for(let e=0;e<y.length;e++){const s=y[e];r.format!==zt?null!==p?g?n.compressedTexSubImage2D(34069+t,e,0,0,s.width,s.height,p,s.data):n.compressedTexImage2D(34069+t,e,m,s.width,s.height,0,s.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):g?n.texSubImage2D(34069+t,e,0,0,s.width,s.height,p,f,s.data):n.texImage2D(34069+t,e,m,s.width,s.height,0,p,f,s.data)}}}else{y=r.mipmaps,g&&x&&(y.length>0&&M++,n.texStorage2D(34067,M,m,c[0].width,c[0].height));for(let t=0;t<6;t++)if(a){g?n.texSubImage2D(34069+t,0,0,0,c[t].width,c[t].height,p,f,c[t].data):n.texImage2D(34069+t,0,m,c[t].width,c[t].height,0,p,f,c[t].data);for(let e=0;e<y.length;e++){const r=y[e].image[t].image;g?n.texSubImage2D(34069+t,e+1,0,0,r.width,r.height,p,f,r.data):n.texImage2D(34069+t,e+1,m,r.width,r.height,0,p,f,r.data)}}else{g?n.texSubImage2D(34069+t,0,0,0,p,f,c[t]):n.texImage2D(34069+t,0,m,p,f,c[t]);for(let e=0;e<y.length;e++){const r=y[e];g?n.texSubImage2D(34069+t,e+1,0,0,p,f,r.image[t]):n.texImage2D(34069+t,e+1,m,p,f,r.image[t])}}}w(r,d)&&S(34067),l.__currentVersion=l.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}(a,e,s):(n.activeTexture(33984+s),n.bindTexture(34067,a.__webglTexture))},this.rebindTextures=function(t,e,n){const s=r.get(t);void 0!==e&&P(s.__webglFramebuffer,t,t.texture,36064,3553),void 0!==n&&O(t)},this.setupRenderTarget=function(e){const l=e.texture,u=r.get(e),c=r.get(l);e.addEventListener("dispose",k),!0!==e.isWebGLMultipleRenderTargets&&(void 0===c.__webglTexture&&(c.__webglTexture=t.createTexture()),c.__version=l.version,a.memory.textures++);const h=!0===e.isWebGLCubeRenderTarget,d=!0===e.isWebGLMultipleRenderTargets,p=b(e)||o;if(h){u.__webglFramebuffer=[];for(let e=0;e<6;e++)u.__webglFramebuffer[e]=t.createFramebuffer()}else if(u.__webglFramebuffer=t.createFramebuffer(),d)if(s.drawBuffers){const n=e.texture;for(let e=0,s=n.length;e<s;e++){const s=r.get(n[e]);void 0===s.__webglTexture&&(s.__webglTexture=t.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(o&&e.samples>0&&!1===B(e)){u.__webglMultisampledFramebuffer=t.createFramebuffer(),u.__webglColorRenderbuffer=t.createRenderbuffer(),t.bindRenderbuffer(36161,u.__webglColorRenderbuffer);const r=i.convert(l.format,l.encoding),s=i.convert(l.type),a=_(l.internalFormat,r,s,l.encoding),o=z(e);t.renderbufferStorageMultisample(36161,o,a,e.width,e.height),n.bindFramebuffer(36160,u.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(36160,36064,36161,u.__webglColorRenderbuffer),t.bindRenderbuffer(36161,null),e.depthBuffer&&(u.__webglDepthRenderbuffer=t.createRenderbuffer(),$(u.__webglDepthRenderbuffer,e,!0)),n.bindFramebuffer(36160,null)}if(h){n.bindTexture(34067,c.__webglTexture),D(34067,l,p);for(let t=0;t<6;t++)P(u.__webglFramebuffer[t],e,l,36064,34069+t);w(l,p)&&S(34067),n.unbindTexture()}else if(d){const t=e.texture;for(let s=0,i=t.length;s<i;s++){const i=t[s],a=r.get(i);n.bindTexture(3553,a.__webglTexture),D(3553,i,p),P(u.__webglFramebuffer,e,i,36064+s,3553),w(i,p)&&S(3553)}n.unbindTexture()}else{let t=3553;(e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(o?t=e.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),n.bindTexture(t,c.__webglTexture),D(t,l,p),P(u.__webglFramebuffer,e,l,36064,t),w(l,p)&&S(t),n.unbindTexture()}e.depthBuffer&&O(e)},this.updateRenderTargetMipmap=function(t){const e=b(t)||o,s=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture];for(let i=0,a=s.length;i<a;i++){const a=s[i];if(w(a,e)){const e=t.isWebGLCubeRenderTarget?34067:3553,s=r.get(a).__webglTexture;n.bindTexture(e,s),S(e),n.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(o&&e.samples>0&&!1===B(e)){const s=e.width,i=e.height;let a=16384;const o=[36064],l=e.stencilBuffer?33306:36096;e.depthBuffer&&o.push(l);const u=r.get(e),c=void 0!==u.__ignoreDepthValues&&u.__ignoreDepthValues;!1===c&&(e.depthBuffer&&(a|=256),e.stencilBuffer&&(a|=1024)),n.bindFramebuffer(36008,u.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,u.__webglFramebuffer),!0===c&&(t.invalidateFramebuffer(36008,[l]),t.invalidateFramebuffer(36009,[l])),t.blitFramebuffer(0,0,s,i,0,0,s,i,a,9728),p&&t.invalidateFramebuffer(36008,o),n.bindFramebuffer(36008,null),n.bindFramebuffer(36009,u.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=O,this.setupFrameBufferTexture=P,this.useMultisampledRTT=B}function tl(t,e,n){const r=n.isWebGL2;return{convert:function(n,s=null){let i;if(n===Et)return 5121;if(n===Lt)return 32819;if(n===Ft)return 32820;if(n===kt)return 5120;if(n===It)return 5122;if(n===Ct)return 5123;if(n===At)return 5124;if(n===Rt)return 5125;if(n===Nt)return 5126;if(n===Dt)return r?5131:(i=e.get("OES_texture_half_float"),null!==i?i.HALF_FLOAT_OES:null);if(n===$t)return 6406;if(n===zt)return 6408;if(n===Bt)return 6409;if(n===Ut)return 6410;if(n===Wt)return 6402;if(n===Vt)return 34041;if(n===Gt)return 6403;if(n===Ot)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(n===yn)return i=e.get("EXT_sRGB"),null!==i?i.SRGB_ALPHA_EXT:null;if(n===Ht)return 36244;if(n===jt)return 33319;if(n===qt)return 33320;if(n===Xt)return 36249;if(n===Kt||n===Yt||n===Jt||n===Zt)if(s===Pe){if(i=e.get("WEBGL_compressed_texture_s3tc_srgb"),null===i)return null;if(n===Kt)return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===Yt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===Jt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===Zt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(i=e.get("WEBGL_compressed_texture_s3tc"),null===i)return null;if(n===Kt)return i.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===Yt)return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===Jt)return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Zt)return i.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===Qt||n===te||n===ee||n===ne){if(i=e.get("WEBGL_compressed_texture_pvrtc"),null===i)return null;if(n===Qt)return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===te)return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===ee)return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===ne)return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===re)return i=e.get("WEBGL_compressed_texture_etc1"),null!==i?i.COMPRESSED_RGB_ETC1_WEBGL:null;if(n===se||n===ie){if(i=e.get("WEBGL_compressed_texture_etc"),null===i)return null;if(n===se)return s===Pe?i.COMPRESSED_SRGB8_ETC2:i.COMPRESSED_RGB8_ETC2;if(n===ie)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:i.COMPRESSED_RGBA8_ETC2_EAC}if(n===ae||n===oe||n===le||n===ue||n===ce||n===he||n===de||n===pe||n===fe||n===me||n===ge||n===xe||n===ye||n===ve){if(i=e.get("WEBGL_compressed_texture_astc"),null===i)return null;if(n===ae)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:i.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===oe)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:i.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===le)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:i.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===ue)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:i.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===ce)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:i.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===he)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:i.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===de)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:i.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===pe)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:i.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===fe)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:i.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===me)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:i.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===ge)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:i.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===xe)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:i.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===ye)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:i.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===ve)return s===Pe?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:i.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===be){if(i=e.get("EXT_texture_compression_bptc"),null===i)return null;if(n===be)return s===Pe?i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:i.COMPRESSED_RGBA_BPTC_UNORM_EXT}return n===Pt?r?34042:(i=e.get("WEBGL_depth_texture"),null!==i?i.UNSIGNED_INT_24_8_WEBGL:null):void 0!==t[n]?t[n]:null}}}Yo.prototype.isMeshDistanceMaterial=!0;class el extends yi{constructor(t=[]){super(),this.cameras=t}}el.prototype.isArrayCamera=!0;class nl extends hs{constructor(){super(),this.type="Group"}}nl.prototype.isGroup=!0;const rl={type:"move"};class sl{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new nl,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new nl,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new ur,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new ur),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new nl,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new ur,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new ur),this._grip}dispatchEvent(t){return null!==this._targetRay&&this._targetRay.dispatchEvent(t),null!==this._grip&&this._grip.dispatchEvent(t),null!==this._hand&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(t,e,n){let r=null,s=null,i=null;const a=this._targetRay,o=this._grip,l=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(null!==a&&(r=e.getPose(t.targetRaySpace,n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(rl))),l&&t.hand){i=!0;for(const r of t.hand.values()){const t=e.getJointPose(r,n);if(void 0===l.joints[r.jointName]){const t=new nl;t.matrixAutoUpdate=!1,t.visible=!1,l.joints[r.jointName]=t,l.add(t)}const s=l.joints[r.jointName];null!==t&&(s.matrix.fromArray(t.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),s.jointRadius=t.radius),s.visible=null!==t}const r=l.joints["index-finger-tip"],s=l.joints["thumb-tip"],a=r.position.distanceTo(s.position),o=.02,u=.005;l.inputState.pinching&&a>o+u?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&a<=o-u&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&t.gripSpace&&(s=e.getPose(t.gripSpace,n),null!==s&&(o.matrix.fromArray(s.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),s.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(s.linearVelocity)):o.hasLinearVelocity=!1,s.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(s.angularVelocity)):o.hasAngularVelocity=!1));return null!==a&&(a.visible=null!==r),null!==o&&(o.visible=null!==s),null!==l&&(l.visible=null!==i),this}}class il extends tr{constructor(t,e,n,r,s,i,a,o,l,u){if((u=void 0!==u?u:Wt)!==Wt&&u!==Vt)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&u===Wt&&(n=Ct),void 0===n&&u===Vt&&(n=Pt),super(null,r,s,i,a,o,u,n,l),this.image={width:t,height:e},this.magFilter=void 0!==a?a:gt,this.minFilter=void 0!==o?o:gt,this.flipY=!1,this.generateMipmaps=!1}}il.prototype.isDepthTexture=!0;class al extends vn{constructor(t,e){super();const n=this;let r=null,s=1,i=null,a="local-floor",o=null,l=null,u=null,c=null,h=null,d=null;const p=e.getContextAttributes();let f=null,m=null;const g=[],x=new Map,y=new yi;y.layers.enable(1),y.viewport=new er;const v=new yi;v.layers.enable(2),v.viewport=new er;const b=[y,v],w=new el;w.layers.enable(1),w.layers.enable(2);let S=null,_=null;function T(t){const e=x.get(t.inputSource);e&&e.dispatchEvent({type:t.type,data:t.inputSource})}function M(){x.forEach((function(t,e){t.disconnect(e)})),x.clear(),S=null,_=null,t.setRenderTarget(f),h=null,c=null,u=null,r=null,m=null,R.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function E(t){const e=r.inputSources;for(let t=0;t<e.length;t++){const n="right"===e[t].handedness?1:0;x.set(e[t],g[n])}for(let e=0;e<t.removed.length;e++){const n=t.removed[e],r=x.get(n);r&&(r.dispatchEvent({type:"disconnected",data:n}),x.delete(n))}for(let e=0;e<t.added.length;e++){const n=t.added[e],r=x.get(n);r&&r.dispatchEvent({type:"connected",data:n})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(t){let e=g[t];return void 0===e&&(e=new sl,g[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){let e=g[t];return void 0===e&&(e=new sl,g[t]=e),e.getGripSpace()},this.getHand=function(t){let e=g[t];return void 0===e&&(e=new sl,g[t]=e),e.getHandSpace()},this.setFramebufferScaleFactor=function(t){s=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(t){a=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o||i},this.setReferenceSpace=function(t){o=t},this.getBaseLayer=function(){return null!==c?c:h},this.getBinding=function(){return u},this.getFrame=function(){return d},this.getSession=function(){return r},this.setSession=async function(o){if(r=o,null!==r){if(f=t.getRenderTarget(),r.addEventListener("select",T),r.addEventListener("selectstart",T),r.addEventListener("selectend",T),r.addEventListener("squeeze",T),r.addEventListener("squeezestart",T),r.addEventListener("squeezeend",T),r.addEventListener("end",M),r.addEventListener("inputsourceschange",E),!0!==p.xrCompatible&&await e.makeXRCompatible(),void 0===r.renderState.layers||!1===t.capabilities.isWebGL2){const n={antialias:void 0!==r.renderState.layers||p.antialias,alpha:p.alpha,depth:p.depth,stencil:p.stencil,framebufferScaleFactor:s};h=new XRWebGLLayer(r,e,n),r.updateRenderState({baseLayer:h}),m=new nr(h.framebufferWidth,h.framebufferHeight,{format:zt,type:Et,encoding:t.outputEncoding})}else{let n=null,i=null,a=null;p.depth&&(a=p.stencil?35056:33190,n=p.stencil?Vt:Wt,i=p.stencil?Pt:Ct);const o={colorFormat:t.outputEncoding===Pe?35907:32856,depthFormat:a,scaleFactor:s};u=new XRWebGLBinding(r,e),c=u.createProjectionLayer(o),r.updateRenderState({layers:[c]}),m=new nr(c.textureWidth,c.textureHeight,{format:zt,type:Et,depthTexture:new il(c.textureWidth,c.textureHeight,i,void 0,void 0,void 0,void 0,void 0,void 0,n),stencilBuffer:p.stencil,encoding:t.outputEncoding,samples:p.antialias?4:0}),t.properties.get(m).__ignoreDepthValues=c.ignoreDepthValues}m.isXRRenderTarget=!0,this.setFoveation(1),i=await r.requestReferenceSpace(a),R.setContext(r),R.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const k=new ur,I=new ur;function C(t,e){null===e?t.matrixWorld.copy(t.matrix):t.matrixWorld.multiplyMatrices(e.matrixWorld,t.matrix),t.matrixWorldInverse.copy(t.matrixWorld).invert()}this.updateCamera=function(t){if(null===r)return;w.near=v.near=y.near=t.near,w.far=v.far=y.far=t.far,S===w.near&&_===w.far||(r.updateRenderState({depthNear:w.near,depthFar:w.far}),S=w.near,_=w.far);const e=t.parent,n=w.cameras;C(w,e);for(let t=0;t<n.length;t++)C(n[t],e);w.matrixWorld.decompose(w.position,w.quaternion,w.scale),t.position.copy(w.position),t.quaternion.copy(w.quaternion),t.scale.copy(w.scale),t.matrix.copy(w.matrix),t.matrixWorld.copy(w.matrixWorld);const s=t.children;for(let t=0,e=s.length;t<e;t++)s[t].updateMatrixWorld(!0);2===n.length?function(t,e,n){k.setFromMatrixPosition(e.matrixWorld),I.setFromMatrixPosition(n.matrixWorld);const r=k.distanceTo(I),s=e.projectionMatrix.elements,i=n.projectionMatrix.elements,a=s[14]/(s[10]-1),o=s[14]/(s[10]+1),l=(s[9]+1)/s[5],u=(s[9]-1)/s[5],c=(s[8]-1)/s[0],h=(i[8]+1)/i[0],d=a*c,p=a*h,f=r/(-c+h),m=f*-c;e.matrixWorld.decompose(t.position,t.quaternion,t.scale),t.translateX(m),t.translateZ(f),t.matrixWorld.compose(t.position,t.quaternion,t.scale),t.matrixWorldInverse.copy(t.matrixWorld).invert();const g=a+f,x=o+f,y=d-m,v=p+(r-m),b=l*o/x*g,w=u*o/x*g;t.projectionMatrix.makePerspective(y,v,b,w,g,x)}(w,y,v):w.projectionMatrix.copy(y.projectionMatrix)},this.getCamera=function(){return w},this.getFoveation=function(){return null!==c?c.fixedFoveation:null!==h?h.fixedFoveation:void 0},this.setFoveation=function(t){null!==c&&(c.fixedFoveation=t),null!==h&&void 0!==h.fixedFoveation&&(h.fixedFoveation=t)};let A=null;const R=new Ai;R.setAnimationLoop((function(e,n){if(l=n.getViewerPose(o||i),d=n,null!==l){const e=l.views;null!==h&&(t.setRenderTargetFramebuffer(m,h.framebuffer),t.setRenderTarget(m));let n=!1;e.length!==w.cameras.length&&(w.cameras.length=0,n=!0);for(let r=0;r<e.length;r++){const s=e[r];let i=null;if(null!==h)i=h.getViewport(s);else{const e=u.getViewSubImage(c,s);i=e.viewport,0===r&&(t.setRenderTargetTextures(m,e.colorTexture,c.ignoreDepthValues?void 0:e.depthStencilTexture),t.setRenderTarget(m))}const a=b[r];a.matrix.fromArray(s.transform.matrix),a.projectionMatrix.fromArray(s.projectionMatrix),a.viewport.set(i.x,i.y,i.width,i.height),0===r&&w.matrix.copy(a.matrix),!0===n&&w.cameras.push(a)}}const s=r.inputSources;for(let t=0;t<g.length;t++){const e=s[t],r=x.get(e);void 0!==r&&r.update(e,n,o||i)}A&&A(e,n),d=null})),this.setAnimationLoop=function(t){A=t},this.dispose=function(){}}}function ol(t,e){function n(n,r){n.opacity.value=r.opacity,r.color&&n.diffuse.value.copy(r.color),r.emissive&&n.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(n.map.value=r.map),r.alphaMap&&(n.alphaMap.value=r.alphaMap),r.bumpMap&&(n.bumpMap.value=r.bumpMap,n.bumpScale.value=r.bumpScale,r.side===y&&(n.bumpScale.value*=-1)),r.displacementMap&&(n.displacementMap.value=r.displacementMap,n.displacementScale.value=r.displacementScale,n.displacementBias.value=r.displacementBias),r.emissiveMap&&(n.emissiveMap.value=r.emissiveMap),r.normalMap&&(n.normalMap.value=r.normalMap,n.normalScale.value.copy(r.normalScale),r.side===y&&n.normalScale.value.negate()),r.specularMap&&(n.specularMap.value=r.specularMap),r.alphaTest>0&&(n.alphaTest.value=r.alphaTest);const s=e.get(r).envMap;if(s&&(n.envMap.value=s,n.flipEnvMap.value=s.isCubeTexture&&!1===s.isRenderTargetTexture?-1:1,n.reflectivity.value=r.reflectivity,n.ior.value=r.ior,n.refractionRatio.value=r.refractionRatio),r.lightMap){n.lightMap.value=r.lightMap;const e=!0!==t.physicallyCorrectLights?Math.PI:1;n.lightMapIntensity.value=r.lightMapIntensity*e}let i,a;r.aoMap&&(n.aoMap.value=r.aoMap,n.aoMapIntensity.value=r.aoMapIntensity),r.map?i=r.map:r.specularMap?i=r.specularMap:r.displacementMap?i=r.displacementMap:r.normalMap?i=r.normalMap:r.bumpMap?i=r.bumpMap:r.roughnessMap?i=r.roughnessMap:r.metalnessMap?i=r.metalnessMap:r.alphaMap?i=r.alphaMap:r.emissiveMap?i=r.emissiveMap:r.clearcoatMap?i=r.clearcoatMap:r.clearcoatNormalMap?i=r.clearcoatNormalMap:r.clearcoatRoughnessMap?i=r.clearcoatRoughnessMap:r.specularIntensityMap?i=r.specularIntensityMap:r.specularColorMap?i=r.specularColorMap:r.transmissionMap?i=r.transmissionMap:r.thicknessMap?i=r.thicknessMap:r.sheenColorMap?i=r.sheenColorMap:r.sheenRoughnessMap&&(i=r.sheenRoughnessMap),void 0!==i&&(i.isWebGLRenderTarget&&(i=i.texture),!0===i.matrixAutoUpdate&&i.updateMatrix(),n.uvTransform.value.copy(i.matrix)),r.aoMap?a=r.aoMap:r.lightMap&&(a=r.lightMap),void 0!==a&&(a.isWebGLRenderTarget&&(a=a.texture),!0===a.matrixAutoUpdate&&a.updateMatrix(),n.uv2Transform.value.copy(a.matrix))}return{refreshFogUniforms:function(t,e){t.fogColor.value.copy(e.color),e.isFog?(t.fogNear.value=e.near,t.fogFar.value=e.far):e.isFogExp2&&(t.fogDensity.value=e.density)},refreshMaterialUniforms:function(t,r,s,i,a){r.isMeshBasicMaterial||r.isMeshLambertMaterial?n(t,r):r.isMeshToonMaterial?(n(t,r),function(t,e){e.gradientMap&&(t.gradientMap.value=e.gradientMap)}(t,r)):r.isMeshPhongMaterial?(n(t,r),function(t,e){t.specular.value.copy(e.specular),t.shininess.value=Math.max(e.shininess,1e-4)}(t,r)):r.isMeshStandardMaterial?(n(t,r),function(t,n){t.roughness.value=n.roughness,t.metalness.value=n.metalness,n.roughnessMap&&(t.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(t.metalnessMap.value=n.metalnessMap),e.get(n).envMap&&(t.envMapIntensity.value=n.envMapIntensity)}(t,r),r.isMeshPhysicalMaterial&&function(t,e,n){t.ior.value=e.ior,e.sheen>0&&(t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),t.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(t.sheenColorMap.value=e.sheenColorMap),e.sheenRoughnessMap&&(t.sheenRoughnessMap.value=e.sheenRoughnessMap)),e.clearcoat>0&&(t.clearcoat.value=e.clearcoat,t.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(t.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(t.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),t.clearcoatNormalMap.value=e.clearcoatNormalMap,e.side===y&&t.clearcoatNormalScale.value.negate())),e.transmission>0&&(t.transmission.value=e.transmission,t.transmissionSamplerMap.value=n.texture,t.transmissionSamplerSize.value.set(n.width,n.height),e.transmissionMap&&(t.transmissionMap.value=e.transmissionMap),t.thickness.value=e.thickness,e.thicknessMap&&(t.thicknessMap.value=e.thicknessMap),t.attenuationDistance.value=e.attenuationDistance,t.attenuationColor.value.copy(e.attenuationColor)),t.specularIntensity.value=e.specularIntensity,t.specularColor.value.copy(e.specularColor),e.specularIntensityMap&&(t.specularIntensityMap.value=e.specularIntensityMap),e.specularColorMap&&(t.specularColorMap.value=e.specularColorMap)}(t,r,a)):r.isMeshMatcapMaterial?(n(t,r),function(t,e){e.matcap&&(t.matcap.value=e.matcap)}(t,r)):r.isMeshDepthMaterial?n(t,r):r.isMeshDistanceMaterial?(n(t,r),function(t,e){t.referencePosition.value.copy(e.referencePosition),t.nearDistance.value=e.nearDistance,t.farDistance.value=e.farDistance}(t,r)):r.isMeshNormalMaterial?n(t,r):r.isLineBasicMaterial?(function(t,e){t.diffuse.value.copy(e.color),t.opacity.value=e.opacity}(t,r),r.isLineDashedMaterial&&function(t,e){t.dashSize.value=e.dashSize,t.totalSize.value=e.dashSize+e.gapSize,t.scale.value=e.scale}(t,r)):r.isPointsMaterial?function(t,e,n,r){let s;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.size.value=e.size*n,t.scale.value=.5*r,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest),e.map?s=e.map:e.alphaMap&&(s=e.alphaMap),void 0!==s&&(!0===s.matrixAutoUpdate&&s.updateMatrix(),t.uvTransform.value.copy(s.matrix))}(t,r,s,i):r.isSpriteMaterial?function(t,e){let n;t.diffuse.value.copy(e.color),t.opacity.value=e.opacity,t.rotation.value=e.rotation,e.map&&(t.map.value=e.map),e.alphaMap&&(t.alphaMap.value=e.alphaMap),e.alphaTest>0&&(t.alphaTest.value=e.alphaTest),e.map?n=e.map:e.alphaMap&&(n=e.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),t.uvTransform.value.copy(n.matrix))}(t,r):r.isShadowMaterial?(t.color.value.copy(r.color),t.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function ll(t={}){const e=void 0!==t.canvas?t.canvas:function(){const t=$n("canvas");return t.style.display="block",t}(),n=void 0!==t.context?t.context:null,r=void 0===t.depth||t.depth,s=void 0===t.stencil||t.stencil,i=void 0!==t.antialias&&t.antialias,o=void 0===t.premultipliedAlpha||t.premultipliedAlpha,l=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,u=void 0!==t.powerPreference?t.powerPreference:"default",c=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat;let h;h=null!==n?n.getContextAttributes().alpha:void 0!==t.alpha&&t.alpha;let d=null,p=null;const f=[],m=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Fe,this.physicallyCorrectLights=!1,this.toneMapping=et,this.toneMappingExposure=1;const g=this;let b=!1,w=0,S=0,_=null,T=-1,M=null;const E=new er,k=new er;let I=null,C=e.width,A=e.height,R=1,N=null,D=null;const L=new er(0,0,C,A),F=new er(0,0,C,A);let P=!1;const $=new Ci;let O=!1,z=!1,B=null;const U=new Br,W=new Nn,V=new ur,G={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function H(){return null===_?R:1}let j,q,X,K,Y,J,Z,Q,tt,nt,rt,st,it,at,ot,lt,ut,ct,ht,dt,pt,ft,mt,gt=n;function xt(t,n){for(let r=0;r<t.length;r++){const s=t[r],i=e.getContext(s,n);if(null!==i)return i}return null}try{const t={alpha:!0,depth:r,stencil:s,antialias:i,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:u,failIfMajorPerformanceCaveat:c};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${a}`),e.addEventListener("webglcontextlost",bt,!1),e.addEventListener("webglcontextrestored",wt,!1),null===gt){const e=["webgl2","webgl","experimental-webgl"];if(!0===g.isWebGL1Renderer&&e.shift(),gt=xt(e,t),null===gt)throw xt(e)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===gt.getShaderPrecisionFormat&&(gt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function yt(){j=new na(gt),q=new zi(gt,j,t),j.init(q),ft=new tl(gt,j,q),X=new Zo(gt,j,q),K=new ia(gt),Y=new Oo,J=new Qo(gt,j,X,Y,q,ft,K),Z=new Ui(g),Q=new ea(g),tt=new Ri(gt,q),mt=new $i(gt,j,tt,q),nt=new ra(gt,tt,K,mt),rt=new ca(gt,nt,tt,K),ht=new ua(gt,q,J),lt=new Bi(Y),st=new $o(g,Z,Q,j,q,mt,lt),it=new ol(g,Y),at=new Wo,ot=new Xo(j,q),ct=new Pi(g,Z,X,rt,h,o),ut=new Jo(g,rt,q),dt=new Oi(gt,j,K,q),pt=new sa(gt,j,K,q),K.programs=st.programs,g.capabilities=q,g.extensions=j,g.properties=Y,g.renderLists=at,g.shadowMap=ut,g.state=X,g.info=K}yt();const vt=new al(g,gt);function bt(t){t.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),b=!0}function wt(){console.log("THREE.WebGLRenderer: Context Restored."),b=!1;const t=K.autoReset,e=ut.enabled,n=ut.autoUpdate,r=ut.needsUpdate,s=ut.type;yt(),K.autoReset=t,ut.enabled=e,ut.autoUpdate=n,ut.needsUpdate=r,ut.type=s}function St(t){const e=t.target;e.removeEventListener("dispose",St),function(t){(function(t){const e=Y.get(t).programs;void 0!==e&&(e.forEach((function(t){st.releaseProgram(t)})),t.isShaderMaterial&&st.releaseShaderCache(t))})(t),Y.remove(t)}(e)}this.xr=vt,this.getContext=function(){return gt},this.getContextAttributes=function(){return gt.getContextAttributes()},this.forceContextLoss=function(){const t=j.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=function(){const t=j.get("WEBGL_lose_context");t&&t.restoreContext()},this.getPixelRatio=function(){return R},this.setPixelRatio=function(t){void 0!==t&&(R=t,this.setSize(C,A,!1))},this.getSize=function(t){return t.set(C,A)},this.setSize=function(t,n,r){vt.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(C=t,A=n,e.width=Math.floor(t*R),e.height=Math.floor(n*R),!1!==r&&(e.style.width=t+"px",e.style.height=n+"px"),this.setViewport(0,0,t,n))},this.getDrawingBufferSize=function(t){return t.set(C*R,A*R).floor()},this.setDrawingBufferSize=function(t,n,r){C=t,A=n,R=r,e.width=Math.floor(t*r),e.height=Math.floor(n*r),this.setViewport(0,0,t,n)},this.getCurrentViewport=function(t){return t.copy(E)},this.getViewport=function(t){return t.copy(L)},this.setViewport=function(t,e,n,r){t.isVector4?L.set(t.x,t.y,t.z,t.w):L.set(t,e,n,r),X.viewport(E.copy(L).multiplyScalar(R).floor())},this.getScissor=function(t){return t.copy(F)},this.setScissor=function(t,e,n,r){t.isVector4?F.set(t.x,t.y,t.z,t.w):F.set(t,e,n,r),X.scissor(k.copy(F).multiplyScalar(R).floor())},this.getScissorTest=function(){return P},this.setScissorTest=function(t){X.setScissorTest(P=t)},this.setOpaqueSort=function(t){N=t},this.setTransparentSort=function(t){D=t},this.getClearColor=function(t){return t.copy(ct.getClearColor())},this.setClearColor=function(){ct.setClearColor.apply(ct,arguments)},this.getClearAlpha=function(){return ct.getClearAlpha()},this.setClearAlpha=function(){ct.setClearAlpha.apply(ct,arguments)},this.clear=function(t=!0,e=!0,n=!0){let r=0;t&&(r|=16384),e&&(r|=256),n&&(r|=1024),gt.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",bt,!1),e.removeEventListener("webglcontextrestored",wt,!1),at.dispose(),ot.dispose(),Y.dispose(),Z.dispose(),Q.dispose(),rt.dispose(),mt.dispose(),st.dispose(),vt.dispose(),vt.removeEventListener("sessionstart",Mt),vt.removeEventListener("sessionend",kt),B&&(B.dispose(),B=null),It.stop()},this.renderBufferDirect=function(t,e,n,r,s,i){null===e&&(e=G);const a=s.isMesh&&s.matrixWorld.determinant()<0,o=function(t,e,n,r,s){!0!==e.isScene&&(e=G),J.resetTextureUnits();const i=e.fog,a=r.isMeshStandardMaterial?e.environment:null,o=null===_?g.outputEncoding:!0===_.isXRRenderTarget?_.texture.encoding:Fe,l=(r.isMeshStandardMaterial?Q:Z).get(r.envMap||a),u=!0===r.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,c=!!r.normalMap&&!!n.attributes.tangent,h=!!n.morphAttributes.position,d=!!n.morphAttributes.normal,f=!!n.morphAttributes.color,m=r.toneMapped?g.toneMapping:et,x=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,y=void 0!==x?x.length:0,v=Y.get(r),b=p.state.lights;if(!0===O&&(!0===z||t!==M)){const e=t===M&&r.id===T;lt.setState(r,t,e)}let w=!1;r.version===v.__version?v.needsLights&&v.lightsStateVersion!==b.state.version||v.outputEncoding!==o||s.isInstancedMesh&&!1===v.instancing?w=!0:s.isInstancedMesh||!0!==v.instancing?s.isSkinnedMesh&&!1===v.skinning?w=!0:s.isSkinnedMesh||!0!==v.skinning?v.envMap!==l||!0===r.fog&&v.fog!==i?w=!0:void 0===v.numClippingPlanes||v.numClippingPlanes===lt.numPlanes&&v.numIntersection===lt.numIntersection?(v.vertexAlphas!==u||v.vertexTangents!==c||v.morphTargets!==h||v.morphNormals!==d||v.morphColors!==f||v.toneMapping!==m||!0===q.isWebGL2&&v.morphTargetsCount!==y)&&(w=!0):w=!0:w=!0:w=!0:(w=!0,v.__version=r.version);let S=v.currentProgram;!0===w&&(S=Ft(r,e,s));let E=!1,k=!1,I=!1;const C=S.getUniforms(),N=v.uniforms;if(X.useProgram(S.program)&&(E=!0,k=!0,I=!0),r.id!==T&&(T=r.id,k=!0),E||M!==t){if(C.setValue(gt,"projectionMatrix",t.projectionMatrix),q.logarithmicDepthBuffer&&C.setValue(gt,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),M!==t&&(M=t,k=!0,I=!0),r.isShaderMaterial||r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshStandardMaterial||r.envMap){const e=C.map.cameraPosition;void 0!==e&&e.setValue(gt,V.setFromMatrixPosition(t.matrixWorld))}(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&C.setValue(gt,"isOrthographic",!0===t.isOrthographicCamera),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial||r.isShadowMaterial||s.isSkinnedMesh)&&C.setValue(gt,"viewMatrix",t.matrixWorldInverse)}if(s.isSkinnedMesh){C.setOptional(gt,s,"bindMatrix"),C.setOptional(gt,s,"bindMatrixInverse");const t=s.skeleton;t&&(q.floatVertexTextures?(null===t.boneTexture&&t.computeBoneTexture(),C.setValue(gt,"boneTexture",t.boneTexture,J),C.setValue(gt,"boneTextureSize",t.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const D=n.morphAttributes;var L,F;return(void 0!==D.position||void 0!==D.normal||void 0!==D.color&&!0===q.isWebGL2)&&ht.update(s,n,r,S),(k||v.receiveShadow!==s.receiveShadow)&&(v.receiveShadow=s.receiveShadow,C.setValue(gt,"receiveShadow",s.receiveShadow)),k&&(C.setValue(gt,"toneMappingExposure",g.toneMappingExposure),v.needsLights&&(F=I,(L=N).ambientLightColor.needsUpdate=F,L.lightProbe.needsUpdate=F,L.directionalLights.needsUpdate=F,L.directionalLightShadows.needsUpdate=F,L.pointLights.needsUpdate=F,L.pointLightShadows.needsUpdate=F,L.spotLights.needsUpdate=F,L.spotLightShadows.needsUpdate=F,L.rectAreaLights.needsUpdate=F,L.hemisphereLights.needsUpdate=F),i&&!0===r.fog&&it.refreshFogUniforms(N,i),it.refreshMaterialUniforms(N,r,R,A,B),mo.upload(gt,v.uniformsList,N,J)),r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(mo.upload(gt,v.uniformsList,N,J),r.uniformsNeedUpdate=!1),r.isSpriteMaterial&&C.setValue(gt,"center",s.center),C.setValue(gt,"modelViewMatrix",s.modelViewMatrix),C.setValue(gt,"normalMatrix",s.normalMatrix),C.setValue(gt,"modelMatrix",s.matrixWorld),S}(t,e,n,r,s);X.setMaterial(r,a);let l=n.index;const u=n.attributes.position;if(null===l){if(void 0===u||0===u.count)return}else if(0===l.count)return;let c,h=1;!0===r.wireframe&&(l=nt.getWireframeAttribute(n),h=2),mt.setup(s,r,o,n,l);let d=dt;null!==l&&(c=tt.get(l),d=pt,d.setIndex(c));const f=null!==l?l.count:u.count,m=n.drawRange.start*h,x=n.drawRange.count*h,y=null!==i?i.start*h:0,v=null!==i?i.count*h:1/0,b=Math.max(m,y),w=Math.min(f,m+x,y+v)-1,S=Math.max(0,w-b+1);if(0!==S){if(s.isMesh)!0===r.wireframe?(X.setLineWidth(r.wireframeLinewidth*H()),d.setMode(1)):d.setMode(4);else if(s.isLine){let t=r.linewidth;void 0===t&&(t=1),X.setLineWidth(t*H()),s.isLineSegments?d.setMode(1):s.isLineLoop?d.setMode(2):d.setMode(3)}else s.isPoints?d.setMode(0):s.isSprite&&d.setMode(4);if(s.isInstancedMesh)d.renderInstances(b,S,s.count);else if(n.isInstancedBufferGeometry){const t=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(b,S,t)}else d.render(b,S)}},this.compile=function(t,e){p=ot.get(t),p.init(),m.push(p),t.traverseVisible((function(t){t.isLight&&t.layers.test(e.layers)&&(p.pushLight(t),t.castShadow&&p.pushShadow(t))})),p.setupLights(g.physicallyCorrectLights),t.traverse((function(e){const n=e.material;if(n)if(Array.isArray(n))for(let r=0;r<n.length;r++)Ft(n[r],t,e);else Ft(n,t,e)})),m.pop(),p=null};let _t=null;function Mt(){It.stop()}function kt(){It.start()}const It=new Ai;function Ct(t,e,n,r){if(!1===t.visible)return;if(t.layers.test(e.layers))if(t.isGroup)n=t.renderOrder;else if(t.isLOD)!0===t.autoUpdate&&t.update(e);else if(t.isLight)p.pushLight(t),t.castShadow&&p.pushShadow(t);else if(t.isSprite){if(!t.frustumCulled||$.intersectsSprite(t)){r&&V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);const e=rt.update(t),s=t.material;s.visible&&d.push(t,e,s,n,V.z,null)}}else if((t.isMesh||t.isLine||t.isPoints)&&(t.isSkinnedMesh&&t.skeleton.frame!==K.render.frame&&(t.skeleton.update(),t.skeleton.frame=K.render.frame),!t.frustumCulled||$.intersectsObject(t))){r&&V.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);const e=rt.update(t),s=t.material;if(Array.isArray(s)){const r=e.groups;for(let i=0,a=r.length;i<a;i++){const a=r[i],o=s[a.materialIndex];o&&o.visible&&d.push(t,e,o,n,V.z,a)}}else s.visible&&d.push(t,e,s,n,V.z,null)}const s=t.children;for(let t=0,i=s.length;t<i;t++)Ct(s[t],e,n,r)}function At(t,e,n,r){const s=t.opaque,a=t.transmissive,o=t.transparent;p.setupLightsView(n),a.length>0&&function(t,e,n){const r=q.isWebGL2;null===B&&(B=new nr(1,1,{generateMipmaps:!0,type:j.has("EXT_color_buffer_half_float")?Dt:Et,minFilter:Tt,samples:r&&!0===i?4:0})),g.getDrawingBufferSize(W),r?B.setSize(W.x,W.y):B.setSize(An(W.x),An(W.y));const s=g.getRenderTarget();g.setRenderTarget(B),g.clear();const a=g.toneMapping;g.toneMapping=et,Rt(t,e,n),g.toneMapping=a,J.updateMultisampleRenderTarget(B),J.updateRenderTargetMipmap(B),g.setRenderTarget(s)}(s,e,n),r&&X.viewport(E.copy(r)),s.length>0&&Rt(s,e,n),a.length>0&&Rt(a,e,n),o.length>0&&Rt(o,e,n),X.buffers.depth.setTest(!0),X.buffers.depth.setMask(!0),X.buffers.color.setMask(!0),X.setPolygonOffset(!1)}function Rt(t,e,n){const r=!0===e.isScene?e.overrideMaterial:null;for(let s=0,i=t.length;s<i;s++){const i=t[s],a=i.object,o=i.geometry,l=null===r?i.material:r,u=i.group;a.layers.test(n.layers)&&Lt(a,e,n,o,l,u)}}function Lt(t,e,n,r,s,i){t.onBeforeRender(g,e,n,r,s,i),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),s.onBeforeRender(g,e,n,r,t,i),!0===s.transparent&&s.side===v?(s.side=y,s.needsUpdate=!0,g.renderBufferDirect(n,e,r,s,t,i),s.side=x,s.needsUpdate=!0,g.renderBufferDirect(n,e,r,s,t,i),s.side=v):g.renderBufferDirect(n,e,r,s,t,i),t.onAfterRender(g,e,n,r,s,i)}function Ft(t,e,n){!0!==e.isScene&&(e=G);const r=Y.get(t),s=p.state.lights,i=p.state.shadowsArray,a=s.state.version,o=st.getParameters(t,s.state,i,e,n),l=st.getProgramCacheKey(o);let u=r.programs;r.environment=t.isMeshStandardMaterial?e.environment:null,r.fog=e.fog,r.envMap=(t.isMeshStandardMaterial?Q:Z).get(t.envMap||r.environment),void 0===u&&(t.addEventListener("dispose",St),u=new Map,r.programs=u);let c=u.get(l);if(void 0!==c){if(r.currentProgram===c&&r.lightsStateVersion===a)return Pt(t,o),c}else o.uniforms=st.getUniforms(t),t.onBuild(n,o,g),t.onBeforeCompile(o,g),c=st.acquireProgram(o,l),u.set(l,c),r.uniforms=o.uniforms;const h=r.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(h.clippingPlanes=lt.uniform),Pt(t,o),r.needsLights=function(t){return t.isMeshLambertMaterial||t.isMeshToonMaterial||t.isMeshPhongMaterial||t.isMeshStandardMaterial||t.isShadowMaterial||t.isShaderMaterial&&!0===t.lights}(t),r.lightsStateVersion=a,r.needsLights&&(h.ambientLightColor.value=s.state.ambient,h.lightProbe.value=s.state.probe,h.directionalLights.value=s.state.directional,h.directionalLightShadows.value=s.state.directionalShadow,h.spotLights.value=s.state.spot,h.spotLightShadows.value=s.state.spotShadow,h.rectAreaLights.value=s.state.rectArea,h.ltc_1.value=s.state.rectAreaLTC1,h.ltc_2.value=s.state.rectAreaLTC2,h.pointLights.value=s.state.point,h.pointLightShadows.value=s.state.pointShadow,h.hemisphereLights.value=s.state.hemi,h.directionalShadowMap.value=s.state.directionalShadowMap,h.directionalShadowMatrix.value=s.state.directionalShadowMatrix,h.spotShadowMap.value=s.state.spotShadowMap,h.spotShadowMatrix.value=s.state.spotShadowMatrix,h.pointShadowMap.value=s.state.pointShadowMap,h.pointShadowMatrix.value=s.state.pointShadowMatrix);const d=c.getUniforms(),f=mo.seqWithValue(d.seq,h);return r.currentProgram=c,r.uniformsList=f,c}function Pt(t,e){const n=Y.get(t);n.outputEncoding=e.outputEncoding,n.instancing=e.instancing,n.skinning=e.skinning,n.morphTargets=e.morphTargets,n.morphNormals=e.morphNormals,n.morphColors=e.morphColors,n.morphTargetsCount=e.morphTargetsCount,n.numClippingPlanes=e.numClippingPlanes,n.numIntersection=e.numClipIntersection,n.vertexAlphas=e.vertexAlphas,n.vertexTangents=e.vertexTangents,n.toneMapping=e.toneMapping}It.setAnimationLoop((function(t){_t&&_t(t)})),"undefined"!=typeof self&&It.setContext(self),this.setAnimationLoop=function(t){_t=t,vt.setAnimationLoop(t),null===t?It.stop():It.start()},vt.addEventListener("sessionstart",Mt),vt.addEventListener("sessionend",kt),this.render=function(t,e){if(void 0!==e&&!0!==e.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===b)return;!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===vt.enabled&&!0===vt.isPresenting&&(!0===vt.cameraAutoUpdate&&vt.updateCamera(e),e=vt.getCamera()),!0===t.isScene&&t.onBeforeRender(g,t,e,_),p=ot.get(t,m.length),p.init(),m.push(p),U.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),$.setFromProjectionMatrix(U),z=this.localClippingEnabled,O=lt.init(this.clippingPlanes,z,e),d=at.get(t,f.length),d.init(),f.push(d),Ct(t,e,0,g.sortObjects),d.finish(),!0===g.sortObjects&&d.sort(N,D),!0===O&&lt.beginShadows();const n=p.state.shadowsArray;if(ut.render(n,t,e),!0===O&&lt.endShadows(),!0===this.info.autoReset&&this.info.reset(),ct.render(d,t),p.setupLights(g.physicallyCorrectLights),e.isArrayCamera){const n=e.cameras;for(let e=0,r=n.length;e<r;e++){const r=n[e];At(d,t,r,r.viewport)}}else At(d,t,e);null!==_&&(J.updateMultisampleRenderTarget(_),J.updateRenderTargetMipmap(_)),!0===t.isScene&&t.onAfterRender(g,t,e),mt.resetDefaultState(),T=-1,M=null,m.pop(),p=m.length>0?m[m.length-1]:null,f.pop(),d=f.length>0?f[f.length-1]:null},this.getActiveCubeFace=function(){return w},this.getActiveMipmapLevel=function(){return S},this.getRenderTarget=function(){return _},this.setRenderTargetTextures=function(t,e,n){Y.get(t.texture).__webglTexture=e,Y.get(t.depthTexture).__webglTexture=n;const r=Y.get(t);r.__hasExternalTextures=!0,r.__hasExternalTextures&&(r.__autoAllocateDepthBuffer=void 0===n,r.__autoAllocateDepthBuffer||!0===j.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),r.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(t,e){const n=Y.get(t);n.__webglFramebuffer=e,n.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(t,e=0,n=0){_=t,w=e,S=n;let r=!0;if(t){const e=Y.get(t);void 0!==e.__useDefaultFramebuffer?(X.bindFramebuffer(36160,null),r=!1):void 0===e.__webglFramebuffer?J.setupRenderTarget(t):e.__hasExternalTextures&&J.rebindTextures(t,Y.get(t.texture).__webglTexture,Y.get(t.depthTexture).__webglTexture)}let s=null,i=!1,a=!1;if(t){const n=t.texture;(n.isData3DTexture||n.isDataArrayTexture)&&(a=!0);const r=Y.get(t).__webglFramebuffer;t.isWebGLCubeRenderTarget?(s=r[e],i=!0):s=q.isWebGL2&&t.samples>0&&!1===J.useMultisampledRTT(t)?Y.get(t).__webglMultisampledFramebuffer:r,E.copy(t.viewport),k.copy(t.scissor),I=t.scissorTest}else E.copy(L).multiplyScalar(R).floor(),k.copy(F).multiplyScalar(R).floor(),I=P;if(X.bindFramebuffer(36160,s)&&q.drawBuffers&&r&&X.drawBuffers(t,s),X.viewport(E),X.scissor(k),X.setScissorTest(I),i){const r=Y.get(t.texture);gt.framebufferTexture2D(36160,36064,34069+e,r.__webglTexture,n)}else if(a){const r=Y.get(t.texture),s=e||0;gt.framebufferTextureLayer(36160,36064,r.__webglTexture,n||0,s)}T=-1},this.readRenderTargetPixels=function(t,e,n,r,s,i,a){if(!t||!t.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=Y.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){X.bindFramebuffer(36160,o);try{const a=t.texture,o=a.format,l=a.type;if(o!==zt&&ft.convert(o)!==gt.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const u=l===Dt&&(j.has("EXT_color_buffer_half_float")||q.isWebGL2&&j.has("EXT_color_buffer_float"));if(!(l===Et||ft.convert(l)===gt.getParameter(35738)||l===Nt&&(q.isWebGL2||j.has("OES_texture_float")||j.has("WEBGL_color_buffer_float"))||u))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=t.width-r&&n>=0&&n<=t.height-s&&gt.readPixels(e,n,r,s,ft.convert(o),ft.convert(l),i)}finally{const t=null!==_?Y.get(_).__webglFramebuffer:null;X.bindFramebuffer(36160,t)}}},this.copyFramebufferToTexture=function(t,e,n=0){if(!0!==e.isFramebufferTexture)return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");const r=Math.pow(2,-n),s=Math.floor(e.image.width*r),i=Math.floor(e.image.height*r);J.setTexture2D(e,0),gt.copyTexSubImage2D(3553,n,0,0,t.x,t.y,s,i),X.unbindTexture()},this.copyTextureToTexture=function(t,e,n,r=0){const s=e.image.width,i=e.image.height,a=ft.convert(n.format),o=ft.convert(n.type);J.setTexture2D(n,0),gt.pixelStorei(37440,n.flipY),gt.pixelStorei(37441,n.premultiplyAlpha),gt.pixelStorei(3317,n.unpackAlignment),e.isDataTexture?gt.texSubImage2D(3553,r,t.x,t.y,s,i,a,o,e.image.data):e.isCompressedTexture?gt.compressedTexSubImage2D(3553,r,t.x,t.y,e.mipmaps[0].width,e.mipmaps[0].height,a,e.mipmaps[0].data):gt.texSubImage2D(3553,r,t.x,t.y,a,o,e.image),0===r&&n.generateMipmaps&&gt.generateMipmap(3553),X.unbindTexture()},this.copyTextureToTexture3D=function(t,e,n,r,s=0){if(g.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const i=t.max.x-t.min.x+1,a=t.max.y-t.min.y+1,o=t.max.z-t.min.z+1,l=ft.convert(r.format),u=ft.convert(r.type);let c;if(r.isData3DTexture)J.setTexture3D(r,0),c=32879;else{if(!r.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");J.setTexture2DArray(r,0),c=35866}gt.pixelStorei(37440,r.flipY),gt.pixelStorei(37441,r.premultiplyAlpha),gt.pixelStorei(3317,r.unpackAlignment);const h=gt.getParameter(3314),d=gt.getParameter(32878),p=gt.getParameter(3316),f=gt.getParameter(3315),m=gt.getParameter(32877),x=n.isCompressedTexture?n.mipmaps[0]:n.image;gt.pixelStorei(3314,x.width),gt.pixelStorei(32878,x.height),gt.pixelStorei(3316,t.min.x),gt.pixelStorei(3315,t.min.y),gt.pixelStorei(32877,t.min.z),n.isDataTexture||n.isData3DTexture?gt.texSubImage3D(c,s,e.x,e.y,e.z,i,a,o,l,u,x.data):n.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),gt.compressedTexSubImage3D(c,s,e.x,e.y,e.z,i,a,o,l,x.data)):gt.texSubImage3D(c,s,e.x,e.y,e.z,i,a,o,l,u,x),gt.pixelStorei(3314,h),gt.pixelStorei(32878,d),gt.pixelStorei(3316,p),gt.pixelStorei(3315,f),gt.pixelStorei(32877,m),0===s&&r.generateMipmaps&&gt.generateMipmap(c),X.unbindTexture()},this.initTexture=function(t){J.setTexture2D(t,0),X.unbindTexture()},this.resetState=function(){w=0,S=0,_=null,X.reset(),mt.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}ll.prototype.isWebGLRenderer=!0;class ul extends ll{}ul.prototype.isWebGL1Renderer=!0;class cl{constructor(t,e=25e-5){this.name="",this.color=new Xn(t),this.density=e}clone(){return new cl(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}cl.prototype.isFogExp2=!0;class hl{constructor(t,e=1,n=1e3){this.name="",this.color=new Xn(t),this.near=e,this.far=n}clone(){return new hl(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}hl.prototype.isFog=!0;class dl extends hs{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),null!==t.background&&(this.background=t.background.clone()),null!==t.environment&&(this.environment=t.environment.clone()),null!==t.fog&&(this.fog=t.fog.clone()),null!==t.overrideMaterial&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),e}}dl.prototype.isScene=!0;class pl{constructor(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=on,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Tn()}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let r=0,s=this.stride;r<s;r++)this.array[t+r]=e.array[n+r];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Tn()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return void 0===t.arrayBuffers&&(t.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Tn()),void 0===t.arrayBuffers[this.array.buffer._uuid]&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}pl.prototype.isInterleavedBuffer=!0;const fl=new ur;class ml{constructor(t,e,n,r=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=!0===r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)fl.fromBufferAttribute(this,e),fl.applyMatrix4(t),this.setXYZ(e,fl.x,fl.y,fl.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)fl.fromBufferAttribute(this,e),fl.applyNormalMatrix(t),this.setXYZ(e,fl.x,fl.y,fl.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)fl.fromBufferAttribute(this,e),fl.transformDirection(t),this.setXYZ(e,fl.x,fl.y,fl.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this}setXYZW(t,e,n,r,s){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this.data.array[t+3]=s,this}clone(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return new Is(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new ml(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(void 0===t){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let e=0;e<this.count;e++){const n=e*this.data.stride+this.offset;for(let e=0;e<this.itemSize;e++)t.push(this.data.array[n+e])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===t.interleavedBuffers&&(t.interleavedBuffers={}),void 0===t.interleavedBuffers[this.data.uuid]&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}ml.prototype.isInterleavedBufferAttribute=!0;class gl extends Ts{constructor(t){super(),this.type="SpriteMaterial",this.color=new Xn(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}let xl;gl.prototype.isSpriteMaterial=!0;const yl=new ur,vl=new ur,bl=new ur,wl=new Nn,Sl=new Nn,_l=new Br,Tl=new ur,Ml=new ur,El=new ur,kl=new Nn,Il=new Nn,Cl=new Nn;class Al extends hs{constructor(t){if(super(),this.type="Sprite",void 0===xl){xl=new js;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),e=new pl(t,5);xl.setIndex([0,1,2,0,2,3]),xl.setAttribute("position",new ml(e,3,0,!1)),xl.setAttribute("uv",new ml(e,2,3,!1))}this.geometry=xl,this.material=void 0!==t?t:new gl,this.center=new Nn(.5,.5)}raycast(t,e){null===t.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),vl.setFromMatrixScale(this.matrixWorld),_l.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),bl.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&vl.multiplyScalar(-bl.z);const n=this.material.rotation;let r,s;0!==n&&(s=Math.cos(n),r=Math.sin(n));const i=this.center;Rl(Tl.set(-.5,-.5,0),bl,i,vl,r,s),Rl(Ml.set(.5,-.5,0),bl,i,vl,r,s),Rl(El.set(.5,.5,0),bl,i,vl,r,s),kl.set(0,0),Il.set(1,0),Cl.set(1,1);let a=t.ray.intersectTriangle(Tl,Ml,El,!1,yl);if(null===a&&(Rl(Ml.set(-.5,.5,0),bl,i,vl,r,s),Il.set(0,1),a=t.ray.intersectTriangle(Tl,El,Ml,!1,yl),null===a))return;const o=t.ray.origin.distanceTo(yl);o<t.near||o>t.far||e.push({distance:o,point:yl.clone(),uv:Ss.getUV(yl,Tl,Ml,El,kl,Il,Cl,new Nn),face:null,object:this})}copy(t){return super.copy(t),void 0!==t.center&&this.center.copy(t.center),this.material=t.material,this}}function Rl(t,e,n,r,s,i){wl.subVectors(t,n).addScalar(.5).multiply(r),void 0!==s?(Sl.x=i*wl.x-s*wl.y,Sl.y=s*wl.x+i*wl.y):Sl.copy(wl),t.copy(e),t.x+=Sl.x,t.y+=Sl.y,t.applyMatrix4(_l)}Al.prototype.isSprite=!0;const Nl=new ur,Dl=new ur;class Ll extends hs{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(t){super.copy(t,!1);const e=t.levels;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.addLevel(n.object.clone(),n.distance)}return this.autoUpdate=t.autoUpdate,this}addLevel(t,e=0){e=Math.abs(e);const n=this.levels;let r;for(r=0;r<n.length&&!(e<n[r].distance);r++);return n.splice(r,0,{distance:e,object:t}),this.add(t),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(t){const e=this.levels;if(e.length>0){let n,r;for(n=1,r=e.length;n<r&&!(t<e[n].distance);n++);return e[n-1].object}return null}raycast(t,e){if(this.levels.length>0){Nl.setFromMatrixPosition(this.matrixWorld);const n=t.ray.origin.distanceTo(Nl);this.getObjectForDistance(n).raycast(t,e)}}update(t){const e=this.levels;if(e.length>1){Nl.setFromMatrixPosition(t.matrixWorld),Dl.setFromMatrixPosition(this.matrixWorld);const n=Nl.distanceTo(Dl)/t.zoom;let r,s;for(e[0].object.visible=!0,r=1,s=e.length;r<s&&n>=e[r].distance;r++)e[r-1].object.visible=!1,e[r].object.visible=!0;for(this._currentLevel=r-1;r<s;r++)e[r].object.visible=!1}}toJSON(t){const e=super.toJSON(t);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];const n=this.levels;for(let t=0,r=n.length;t<r;t++){const r=n[t];e.object.levels.push({object:r.object.uuid,distance:r.distance})}return e}}const Fl=new ur,Pl=new er,$l=new er,Ol=new ur,zl=new Br;class Bl extends ci{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Br,this.bindMatrixInverse=new Br}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new er,e=this.geometry.attributes.skinWeight;for(let n=0,r=e.count;n<r;n++){t.fromBufferAttribute(e,n);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,r=this.geometry;Pl.fromBufferAttribute(r.attributes.skinIndex,t),$l.fromBufferAttribute(r.attributes.skinWeight,t),Fl.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const r=$l.getComponent(t);if(0!==r){const s=Pl.getComponent(t);zl.multiplyMatrices(n.bones[s].matrixWorld,n.boneInverses[s]),e.addScaledVector(Ol.copy(Fl).applyMatrix4(zl),r)}}return e.applyMatrix4(this.bindMatrixInverse)}}Bl.prototype.isSkinnedMesh=!0;class Ul extends hs{constructor(){super(),this.type="Bone"}}Ul.prototype.isBone=!0;class Wl extends tr{constructor(t=null,e=1,n=1,r,s,i,a,o,l=gt,u=gt,c,h){super(null,i,a,o,l,u,r,s,c,h),this.image={data:t,width:e,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Wl.prototype.isDataTexture=!0;const Vl=new Br,Gl=new Br;class Hl{constructor(t=[],e=[]){this.uuid=Tn(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*t.length),0===e.length)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,e=this.bones.length;t<e;t++)this.boneInverses.push(new Br)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const e=new Br;this.bones[t]&&e.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(e)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&e.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const e=this.bones[t];e&&(e.parent&&e.parent.isBone?(e.matrix.copy(e.parent.matrixWorld).invert(),e.matrix.multiply(e.matrixWorld)):e.matrix.copy(e.matrixWorld),e.matrix.decompose(e.position,e.quaternion,e.scale))}}update(){const t=this.bones,e=this.boneInverses,n=this.boneMatrices,r=this.boneTexture;for(let r=0,s=t.length;r<s;r++){const s=t[r]?t[r].matrixWorld:Gl;Vl.multiplyMatrices(s,e[r]),Vl.toArray(n,16*r)}null!==r&&(r.needsUpdate=!0)}clone(){return new Hl(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(4*this.bones.length);t=Cn(t),t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const n=new Wl(e,t,t,zt,Nt);return n.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=n,this.boneTextureSize=t,this}getBoneByName(t){for(let e=0,n=this.bones.length;e<n;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let n=0,r=t.bones.length;n<r;n++){const r=t.bones[n];let s=e[r];void 0===s&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),s=new Ul),this.bones.push(s),this.boneInverses.push((new Br).fromArray(t.boneInverses[n]))}return this.init(),this}toJSON(){const t={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,n=this.boneInverses;for(let r=0,s=e.length;r<s;r++){const s=e[r];t.bones.push(s.uuid);const i=n[r];t.boneInverses.push(i.toArray())}return t}}class jl extends Is{constructor(t,e,n,r=1){"number"==typeof n&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,n),this.meshPerAttribute=r}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}jl.prototype.isInstancedBufferAttribute=!0;const ql=new Br,Xl=new Br,Kl=[],Yl=new ci;class Jl extends ci{constructor(t,e,n){super(t,e),this.instanceMatrix=new jl(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const n=this.matrixWorld,r=this.count;if(Yl.geometry=this.geometry,Yl.material=this.material,void 0!==Yl.material)for(let s=0;s<r;s++){this.getMatrixAt(s,ql),Xl.multiplyMatrices(n,ql),Yl.matrixWorld=Xl,Yl.raycast(t,Kl);for(let t=0,n=Kl.length;t<n;t++){const n=Kl[t];n.instanceId=s,n.object=this,e.push(n)}Kl.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new jl(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}Jl.prototype.isInstancedMesh=!0;class Zl extends Ts{constructor(t){super(),this.type="LineBasicMaterial",this.color=new Xn(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}Zl.prototype.isLineBasicMaterial=!0;const Ql=new ur,tu=new ur,eu=new Br,nu=new zr,ru=new Rr;class su extends hs{constructor(t=new js,e=new Zl){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[0];for(let t=1,r=e.count;t<r;t++)Ql.fromBufferAttribute(e,t-1),tu.fromBufferAttribute(e,t),n[t]=n[t-1],n[t]+=Ql.distanceTo(tu);t.setAttribute("lineDistance",new $s(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,s=t.params.Line.threshold,i=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),ru.copy(n.boundingSphere),ru.applyMatrix4(r),ru.radius+=s,!1===t.ray.intersectsSphere(ru))return;eu.copy(r).invert(),nu.copy(t.ray).applyMatrix4(eu);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=new ur,u=new ur,c=new ur,h=new ur,d=this.isLineSegments?2:1;if(n.isBufferGeometry){const r=n.index,s=n.attributes.position;if(null!==r)for(let n=Math.max(0,i.start),a=Math.min(r.count,i.start+i.count)-1;n<a;n+=d){const i=r.getX(n),a=r.getX(n+1);if(l.fromBufferAttribute(s,i),u.fromBufferAttribute(s,a),nu.distanceSqToSegment(l,u,h,c)>o)continue;h.applyMatrix4(this.matrixWorld);const d=t.ray.origin.distanceTo(h);d<t.near||d>t.far||e.push({distance:d,point:c.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}else for(let n=Math.max(0,i.start),r=Math.min(s.count,i.start+i.count)-1;n<r;n+=d){if(l.fromBufferAttribute(s,n),u.fromBufferAttribute(s,n+1),nu.distanceSqToSegment(l,u,h,c)>o)continue;h.applyMatrix4(this.matrixWorld);const r=t.ray.origin.distanceTo(h);r<t.near||r>t.far||e.push({distance:r,point:c.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}su.prototype.isLine=!0;const iu=new ur,au=new ur;class ou extends su{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(null===t.index){const e=t.attributes.position,n=[];for(let t=0,r=e.count;t<r;t+=2)iu.fromBufferAttribute(e,t),au.fromBufferAttribute(e,t+1),n[t]=0===t?0:n[t-1],n[t+1]=n[t]+iu.distanceTo(au);t.setAttribute("lineDistance",new $s(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}ou.prototype.isLineSegments=!0;class lu extends su{constructor(t,e){super(t,e),this.type="LineLoop"}}lu.prototype.isLineLoop=!0;class uu extends Ts{constructor(t){super(),this.type="PointsMaterial",this.color=new Xn(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}uu.prototype.isPointsMaterial=!0;const cu=new Br,hu=new zr,du=new Rr,pu=new ur;class fu extends hs{constructor(t=new js,e=new uu){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,s=t.params.Points.threshold,i=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),du.copy(n.boundingSphere),du.applyMatrix4(r),du.radius+=s,!1===t.ray.intersectsSphere(du))return;cu.copy(r).invert(),hu.copy(t.ray).applyMatrix4(cu);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a;if(n.isBufferGeometry){const s=n.index,a=n.attributes.position;if(null!==s)for(let n=Math.max(0,i.start),l=Math.min(s.count,i.start+i.count);n<l;n++){const i=s.getX(n);pu.fromBufferAttribute(a,i),mu(pu,i,o,r,t,e,this)}else for(let n=Math.max(0,i.start),s=Math.min(a.count,i.start+i.count);n<s;n++)pu.fromBufferAttribute(a,n),mu(pu,n,o,r,t,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const t=e[n[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++){const n=t[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}else{const e=t.morphTargets;void 0!==e&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function mu(t,e,n,r,s,i,a){const o=hu.distanceSqToPoint(t);if(o<n){const n=new ur;hu.closestPointToPoint(t,n),n.applyMatrix4(r);const l=s.ray.origin.distanceTo(n);if(l<s.near||l>s.far)return;i.push({distance:l,distanceToRay:Math.sqrt(o),point:n,index:e,face:null,object:a})}}fu.prototype.isPoints=!0;class gu extends tr{constructor(t,e,n,r,s,i,a,o,l){super(t,e,n,r,s,i,a,o,l),this.minFilter=void 0!==i?i:wt,this.magFilter=void 0!==s?s:wt,this.generateMipmaps=!1;const u=this;"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback((function e(){u.needsUpdate=!0,t.requestVideoFrameCallback(e)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;!1=="requestVideoFrameCallback"in t&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}gu.prototype.isVideoTexture=!0;class xu extends tr{constructor(t,e,n){super({width:t,height:e}),this.format=n,this.magFilter=gt,this.minFilter=gt,this.generateMipmaps=!1,this.needsUpdate=!0}}xu.prototype.isFramebufferTexture=!0;class yu extends tr{constructor(t,e,n,r,s,i,a,o,l,u,c,h){super(null,i,a,o,l,u,r,s,c,h),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}yu.prototype.isCompressedTexture=!0;class vu extends tr{constructor(t,e,n,r,s,i,a,o,l){super(t,e,n,r,s,i,a,o,l),this.needsUpdate=!0}}vu.prototype.isCanvasTexture=!0;class bu{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,r=this.getPoint(0),s=0;e.push(0);for(let i=1;i<=t;i++)n=this.getPoint(i/t),s+=n.distanceTo(r),e.push(s),r=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let r=0;const s=n.length;let i;i=e||t*n[s-1];let a,o=0,l=s-1;for(;o<=l;)if(r=Math.floor(o+(l-o)/2),a=n[r]-i,a<0)o=r+1;else{if(!(a>0)){l=r;break}l=r-1}if(r=l,n[r]===i)return r/(s-1);const u=n[r];return(r+(i-u)/(n[r+1]-u))/(s-1)}getTangent(t,e){const n=1e-4;let r=t-n,s=t+n;r<0&&(r=0),s>1&&(s=1);const i=this.getPoint(r),a=this.getPoint(s),o=e||(i.isVector2?new Nn:new ur);return o.copy(a).sub(i).normalize(),o}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new ur,r=[],s=[],i=[],a=new ur,o=new Br;for(let e=0;e<=t;e++){const n=e/t;r[e]=this.getTangentAt(n,new ur)}s[0]=new ur,i[0]=new ur;let l=Number.MAX_VALUE;const u=Math.abs(r[0].x),c=Math.abs(r[0].y),h=Math.abs(r[0].z);u<=l&&(l=u,n.set(1,0,0)),c<=l&&(l=c,n.set(0,1,0)),h<=l&&n.set(0,0,1),a.crossVectors(r[0],n).normalize(),s[0].crossVectors(r[0],a),i[0].crossVectors(r[0],s[0]);for(let e=1;e<=t;e++){if(s[e]=s[e-1].clone(),i[e]=i[e-1].clone(),a.crossVectors(r[e-1],r[e]),a.length()>Number.EPSILON){a.normalize();const t=Math.acos(Mn(r[e-1].dot(r[e]),-1,1));s[e].applyMatrix4(o.makeRotationAxis(a,t))}i[e].crossVectors(r[e],s[e])}if(!0===e){let e=Math.acos(Mn(s[0].dot(s[t]),-1,1));e/=t,r[0].dot(a.crossVectors(s[0],s[t]))>0&&(e=-e);for(let n=1;n<=t;n++)s[n].applyMatrix4(o.makeRotationAxis(r[n],e*n)),i[n].crossVectors(r[n],s[n])}return{tangents:r,normals:s,binormals:i}}clone(){return(new this.constructor).copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class wu extends bu{constructor(t=0,e=0,n=1,r=1,s=0,i=2*Math.PI,a=!1,o=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=r,this.aStartAngle=s,this.aEndAngle=i,this.aClockwise=a,this.aRotation=o}getPoint(t,e){const n=e||new Nn,r=2*Math.PI;let s=this.aEndAngle-this.aStartAngle;const i=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(s=i?0:r),!0!==this.aClockwise||i||(s===r?s=-r:s-=r);const a=this.aStartAngle+t*s;let o=this.aX+this.xRadius*Math.cos(a),l=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const t=Math.cos(this.aRotation),e=Math.sin(this.aRotation),n=o-this.aX,r=l-this.aY;o=n*t-r*e+this.aX,l=n*e+r*t+this.aY}return n.set(o,l)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}wu.prototype.isEllipseCurve=!0;class Su extends wu{constructor(t,e,n,r,s,i){super(t,e,n,n,r,s,i),this.type="ArcCurve"}}function _u(){let t=0,e=0,n=0,r=0;function s(s,i,a,o){t=s,e=a,n=-3*s+3*i-2*a-o,r=2*s-2*i+a+o}return{initCatmullRom:function(t,e,n,r,i){s(e,n,i*(n-t),i*(r-e))},initNonuniformCatmullRom:function(t,e,n,r,i,a,o){let l=(e-t)/i-(n-t)/(i+a)+(n-e)/a,u=(n-e)/a-(r-e)/(a+o)+(r-n)/o;l*=a,u*=a,s(e,n,l,u)},calc:function(s){const i=s*s;return t+e*s+n*i+r*(i*s)}}}Su.prototype.isArcCurve=!0;const Tu=new ur,Mu=new _u,Eu=new _u,ku=new _u;class Iu extends bu{constructor(t=[],e=!1,n="centripetal",r=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=r}getPoint(t,e=new ur){const n=e,r=this.points,s=r.length,i=(s-(this.closed?0:1))*t;let a,o,l=Math.floor(i),u=i-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/s)+1)*s:0===u&&l===s-1&&(l=s-2,u=1),this.closed||l>0?a=r[(l-1)%s]:(Tu.subVectors(r[0],r[1]).add(r[0]),a=Tu);const c=r[l%s],h=r[(l+1)%s];if(this.closed||l+2<s?o=r[(l+2)%s]:(Tu.subVectors(r[s-1],r[s-2]).add(r[s-1]),o=Tu),"centripetal"===this.curveType||"chordal"===this.curveType){const t="chordal"===this.curveType?.5:.25;let e=Math.pow(a.distanceToSquared(c),t),n=Math.pow(c.distanceToSquared(h),t),r=Math.pow(h.distanceToSquared(o),t);n<1e-4&&(n=1),e<1e-4&&(e=n),r<1e-4&&(r=n),Mu.initNonuniformCatmullRom(a.x,c.x,h.x,o.x,e,n,r),Eu.initNonuniformCatmullRom(a.y,c.y,h.y,o.y,e,n,r),ku.initNonuniformCatmullRom(a.z,c.z,h.z,o.z,e,n,r)}else"catmullrom"===this.curveType&&(Mu.initCatmullRom(a.x,c.x,h.x,o.x,this.tension),Eu.initCatmullRom(a.y,c.y,h.y,o.y,this.tension),ku.initCatmullRom(a.z,c.z,h.z,o.z,this.tension));return n.set(Mu.calc(u),Eu.calc(u),ku.calc(u)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new ur).fromArray(n))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}function Cu(t,e,n,r,s){const i=.5*(r-e),a=.5*(s-n),o=t*t;return(2*n-2*r+i+a)*(t*o)+(-3*n+3*r-2*i-a)*o+i*t+n}function Au(t,e,n,r){return function(t,e){const n=1-t;return n*n*e}(t,e)+function(t,e){return 2*(1-t)*t*e}(t,n)+function(t,e){return t*t*e}(t,r)}function Ru(t,e,n,r,s){return function(t,e){const n=1-t;return n*n*n*e}(t,e)+function(t,e){const n=1-t;return 3*n*n*t*e}(t,n)+function(t,e){return 3*(1-t)*t*t*e}(t,r)+function(t,e){return t*t*t*e}(t,s)}Iu.prototype.isCatmullRomCurve3=!0;class Nu extends bu{constructor(t=new Nn,e=new Nn,n=new Nn,r=new Nn){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new Nn){const n=e,r=this.v0,s=this.v1,i=this.v2,a=this.v3;return n.set(Ru(t,r.x,s.x,i.x,a.x),Ru(t,r.y,s.y,i.y,a.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Nu.prototype.isCubicBezierCurve=!0;class Du extends bu{constructor(t=new ur,e=new ur,n=new ur,r=new ur){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new ur){const n=e,r=this.v0,s=this.v1,i=this.v2,a=this.v3;return n.set(Ru(t,r.x,s.x,i.x,a.x),Ru(t,r.y,s.y,i.y,a.y),Ru(t,r.z,s.z,i.z,a.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Du.prototype.isCubicBezierCurve3=!0;class Lu extends bu{constructor(t=new Nn,e=new Nn){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new Nn){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new Nn;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Lu.prototype.isLineCurve=!0;class Fu extends bu{constructor(t=new ur,e=new ur){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new ur){const n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Pu extends bu{constructor(t=new Nn,e=new Nn,n=new Nn){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new Nn){const n=e,r=this.v0,s=this.v1,i=this.v2;return n.set(Au(t,r.x,s.x,i.x),Au(t,r.y,s.y,i.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Pu.prototype.isQuadraticBezierCurve=!0;class $u extends bu{constructor(t=new ur,e=new ur,n=new ur){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new ur){const n=e,r=this.v0,s=this.v1,i=this.v2;return n.set(Au(t,r.x,s.x,i.x),Au(t,r.y,s.y,i.y),Au(t,r.z,s.z,i.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}$u.prototype.isQuadraticBezierCurve3=!0;class Ou extends bu{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new Nn){const n=e,r=this.points,s=(r.length-1)*t,i=Math.floor(s),a=s-i,o=r[0===i?i:i-1],l=r[i],u=r[i>r.length-2?r.length-1:i+1],c=r[i>r.length-3?r.length-1:i+2];return n.set(Cu(a,o.x,l.x,u.x,c.x),Cu(a,o.y,l.y,u.y,c.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const n=this.points[e];t.points.push(n.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const n=t.points[e];this.points.push((new Nn).fromArray(n))}return this}}Ou.prototype.isSplineCurve=!0;var zu=Object.freeze({__proto__:null,ArcCurve:Su,CatmullRomCurve3:Iu,CubicBezierCurve:Nu,CubicBezierCurve3:Du,EllipseCurve:wu,LineCurve:Lu,LineCurve3:Fu,QuadraticBezierCurve:Pu,QuadraticBezierCurve3:$u,SplineCurve:Ou});class Bu extends bu{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new Lu(e,t))}getPoint(t,e){const n=t*this.getLength(),r=this.getCurveLengths();let s=0;for(;s<r.length;){if(r[s]>=n){const t=r[s]-n,i=this.curves[s],a=i.getLength(),o=0===a?0:1-t/a;return i.getPointAt(o,e)}s++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,r=this.curves.length;n<r;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let r=0,s=this.curves;r<s.length;r++){const i=s[r],a=i.isEllipseCurve?2*t:i.isLineCurve||i.isLineCurve3?1:i.isSplineCurve?t*i.points.length:t,o=i.getPoints(a);for(let t=0;t<o.length;t++){const r=o[t];n&&n.equals(r)||(e.push(r),n=r)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push(n.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const n=this.curves[e];t.curves.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const n=t.curves[e];this.curves.push((new zu[n.type]).fromJSON(n))}return this}}class Uu extends Bu{constructor(t){super(),this.type="Path",this.currentPoint=new Nn,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new Lu(this.currentPoint.clone(),new Nn(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,r){const s=new Pu(this.currentPoint.clone(),new Nn(t,e),new Nn(n,r));return this.curves.push(s),this.currentPoint.set(n,r),this}bezierCurveTo(t,e,n,r,s,i){const a=new Nu(this.currentPoint.clone(),new Nn(t,e),new Nn(n,r),new Nn(s,i));return this.curves.push(a),this.currentPoint.set(s,i),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new Ou(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,r,s,i){const a=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(t+a,e+o,n,r,s,i),this}absarc(t,e,n,r,s,i){return this.absellipse(t,e,n,n,r,s,i),this}ellipse(t,e,n,r,s,i,a,o){const l=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(t+l,e+u,n,r,s,i,a,o),this}absellipse(t,e,n,r,s,i,a,o){const l=new wu(t,e,n,r,s,i,a,o);if(this.curves.length>0){const t=l.getPoint(0);t.equals(this.currentPoint)||this.lineTo(t.x,t.y)}this.curves.push(l);const u=l.getPoint(1);return this.currentPoint.copy(u),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Wu extends js{constructor(t=[new Nn(0,.5),new Nn(.5,0),new Nn(0,-.5)],e=12,n=0,r=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:t,segments:e,phiStart:n,phiLength:r},e=Math.floor(e),r=Mn(r,0,2*Math.PI);const s=[],i=[],a=[],o=[],l=[],u=1/e,c=new ur,h=new Nn,d=new ur,p=new ur,f=new ur;let m=0,g=0;for(let e=0;e<=t.length-1;e++)switch(e){case 0:m=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-m,d.z=0*g,f.copy(d),d.normalize(),o.push(d.x,d.y,d.z);break;case t.length-1:o.push(f.x,f.y,f.z);break;default:m=t[e+1].x-t[e].x,g=t[e+1].y-t[e].y,d.x=1*g,d.y=-m,d.z=0*g,p.copy(d),d.x+=f.x,d.y+=f.y,d.z+=f.z,d.normalize(),o.push(d.x,d.y,d.z),f.copy(p)}for(let s=0;s<=e;s++){const d=n+s*u*r,p=Math.sin(d),f=Math.cos(d);for(let n=0;n<=t.length-1;n++){c.x=t[n].x*p,c.y=t[n].y,c.z=t[n].x*f,i.push(c.x,c.y,c.z),h.x=s/e,h.y=n/(t.length-1),a.push(h.x,h.y);const r=o[3*n+0]*p,u=o[3*n+1],d=o[3*n+0]*f;l.push(r,u,d)}}for(let n=0;n<e;n++)for(let e=0;e<t.length-1;e++){const r=e+n*t.length,i=r,a=r+t.length,o=r+t.length+1,l=r+1;s.push(i,a,l),s.push(o,l,a)}this.setIndex(s),this.setAttribute("position",new $s(i,3)),this.setAttribute("uv",new $s(a,2)),this.setAttribute("normal",new $s(l,3))}static fromJSON(t){return new Wu(t.points,t.segments,t.phiStart,t.phiLength)}}class Vu extends Wu{constructor(t=1,e=1,n=4,r=8){const s=new Uu;s.absarc(0,-e/2,t,1.5*Math.PI,0),s.absarc(0,e/2,t,0,.5*Math.PI),super(s.getPoints(n),r),this.type="CapsuleGeometry",this.parameters={radius:t,height:e,capSegments:n,radialSegments:r}}static fromJSON(t){return new Vu(t.radius,t.length,t.capSegments,t.radialSegments)}}class Gu extends js{constructor(t=1,e=8,n=0,r=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:t,segments:e,thetaStart:n,thetaLength:r},e=Math.max(3,e);const s=[],i=[],a=[],o=[],l=new ur,u=new Nn;i.push(0,0,0),a.push(0,0,1),o.push(.5,.5);for(let s=0,c=3;s<=e;s++,c+=3){const h=n+s/e*r;l.x=t*Math.cos(h),l.y=t*Math.sin(h),i.push(l.x,l.y,l.z),a.push(0,0,1),u.x=(i[c]/t+1)/2,u.y=(i[c+1]/t+1)/2,o.push(u.x,u.y)}for(let t=1;t<=e;t++)s.push(t,t+1,0);this.setIndex(s),this.setAttribute("position",new $s(i,3)),this.setAttribute("normal",new $s(a,3)),this.setAttribute("uv",new $s(o,2))}static fromJSON(t){return new Gu(t.radius,t.segments,t.thetaStart,t.thetaLength)}}class Hu extends js{constructor(t=1,e=1,n=1,r=8,s=1,i=!1,a=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:e,height:n,radialSegments:r,heightSegments:s,openEnded:i,thetaStart:a,thetaLength:o};const l=this;r=Math.floor(r),s=Math.floor(s);const u=[],c=[],h=[],d=[];let p=0;const f=[],m=n/2;let g=0;function x(n){const s=p,i=new Nn,f=new ur;let x=0;const y=!0===n?t:e,v=!0===n?1:-1;for(let t=1;t<=r;t++)c.push(0,m*v,0),h.push(0,v,0),d.push(.5,.5),p++;const b=p;for(let t=0;t<=r;t++){const e=t/r*o+a,n=Math.cos(e),s=Math.sin(e);f.x=y*s,f.y=m*v,f.z=y*n,c.push(f.x,f.y,f.z),h.push(0,v,0),i.x=.5*n+.5,i.y=.5*s*v+.5,d.push(i.x,i.y),p++}for(let t=0;t<r;t++){const e=s+t,r=b+t;!0===n?u.push(r,r+1,e):u.push(r+1,r,e),x+=3}l.addGroup(g,x,!0===n?1:2),g+=x}!function(){const i=new ur,x=new ur;let y=0;const v=(e-t)/n;for(let l=0;l<=s;l++){const u=[],g=l/s,y=g*(e-t)+t;for(let t=0;t<=r;t++){const e=t/r,s=e*o+a,l=Math.sin(s),f=Math.cos(s);x.x=y*l,x.y=-g*n+m,x.z=y*f,c.push(x.x,x.y,x.z),i.set(l,v,f).normalize(),h.push(i.x,i.y,i.z),d.push(e,1-g),u.push(p++)}f.push(u)}for(let t=0;t<r;t++)for(let e=0;e<s;e++){const n=f[e][t],r=f[e+1][t],s=f[e+1][t+1],i=f[e][t+1];u.push(n,r,i),u.push(r,s,i),y+=6}l.addGroup(g,y,0),g+=y}(),!1===i&&(t>0&&x(!0),e>0&&x(!1)),this.setIndex(u),this.setAttribute("position",new $s(c,3)),this.setAttribute("normal",new $s(h,3)),this.setAttribute("uv",new $s(d,2))}static fromJSON(t){return new Hu(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class ju extends Hu{constructor(t=1,e=1,n=8,r=1,s=!1,i=0,a=2*Math.PI){super(0,t,e,n,r,s,i,a),this.type="ConeGeometry",this.parameters={radius:t,height:e,radialSegments:n,heightSegments:r,openEnded:s,thetaStart:i,thetaLength:a}}static fromJSON(t){return new ju(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength)}}class qu extends js{constructor(t=[],e=[],n=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:t,indices:e,radius:n,detail:r};const s=[],i=[];function a(t,e,n,r){const s=r+1,i=[];for(let r=0;r<=s;r++){i[r]=[];const a=t.clone().lerp(n,r/s),o=e.clone().lerp(n,r/s),l=s-r;for(let t=0;t<=l;t++)i[r][t]=0===t&&r===s?a:a.clone().lerp(o,t/l)}for(let t=0;t<s;t++)for(let e=0;e<2*(s-t)-1;e++){const n=Math.floor(e/2);e%2==0?(o(i[t][n+1]),o(i[t+1][n]),o(i[t][n])):(o(i[t][n+1]),o(i[t+1][n+1]),o(i[t+1][n]))}}function o(t){s.push(t.x,t.y,t.z)}function l(e,n){const r=3*e;n.x=t[r+0],n.y=t[r+1],n.z=t[r+2]}function u(t,e,n,r){r<0&&1===t.x&&(i[e]=t.x-1),0===n.x&&0===n.z&&(i[e]=r/2/Math.PI+.5)}function c(t){return Math.atan2(t.z,-t.x)}!function(t){const n=new ur,r=new ur,s=new ur;for(let i=0;i<e.length;i+=3)l(e[i+0],n),l(e[i+1],r),l(e[i+2],s),a(n,r,s,t)}(r),function(t){const e=new ur;for(let n=0;n<s.length;n+=3)e.x=s[n+0],e.y=s[n+1],e.z=s[n+2],e.normalize().multiplyScalar(t),s[n+0]=e.x,s[n+1]=e.y,s[n+2]=e.z}(n),function(){const t=new ur;for(let n=0;n<s.length;n+=3){t.x=s[n+0],t.y=s[n+1],t.z=s[n+2];const r=c(t)/2/Math.PI+.5,a=(e=t,Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))/Math.PI+.5);i.push(r,1-a)}var e;(function(){const t=new ur,e=new ur,n=new ur,r=new ur,a=new Nn,o=new Nn,l=new Nn;for(let h=0,d=0;h<s.length;h+=9,d+=6){t.set(s[h+0],s[h+1],s[h+2]),e.set(s[h+3],s[h+4],s[h+5]),n.set(s[h+6],s[h+7],s[h+8]),a.set(i[d+0],i[d+1]),o.set(i[d+2],i[d+3]),l.set(i[d+4],i[d+5]),r.copy(t).add(e).add(n).divideScalar(3);const p=c(r);u(a,d+0,t,p),u(o,d+2,e,p),u(l,d+4,n,p)}})(),function(){for(let t=0;t<i.length;t+=6){const e=i[t+0],n=i[t+2],r=i[t+4],s=Math.max(e,n,r),a=Math.min(e,n,r);s>.9&&a<.1&&(e<.2&&(i[t+0]+=1),n<.2&&(i[t+2]+=1),r<.2&&(i[t+4]+=1))}}()}(),this.setAttribute("position",new $s(s,3)),this.setAttribute("normal",new $s(s.slice(),3)),this.setAttribute("uv",new $s(i,2)),0===r?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(t){return new qu(t.vertices,t.indices,t.radius,t.details)}}class Xu extends qu{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2,r=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-n,0,-r,n,0,r,-n,0,r,n,-r,-n,0,-r,n,0,r,-n,0,r,n,0,-n,0,-r,n,0,-r,-n,0,r,n,0,r],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],t,e),this.type="DodecahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Xu(t.radius,t.detail)}}const Ku=new ur,Yu=new ur,Ju=new ur,Zu=new Ss;class Qu extends js{constructor(t=null,e=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:t,thresholdAngle:e},null!==t){const n=4,r=Math.pow(10,n),s=Math.cos(Sn*e),i=t.getIndex(),a=t.getAttribute("position"),o=i?i.count:a.count,l=[0,0,0],u=["a","b","c"],c=new Array(3),h={},d=[];for(let t=0;t<o;t+=3){i?(l[0]=i.getX(t),l[1]=i.getX(t+1),l[2]=i.getX(t+2)):(l[0]=t,l[1]=t+1,l[2]=t+2);const{a:e,b:n,c:o}=Zu;if(e.fromBufferAttribute(a,l[0]),n.fromBufferAttribute(a,l[1]),o.fromBufferAttribute(a,l[2]),Zu.getNormal(Ju),c[0]=`${Math.round(e.x*r)},${Math.round(e.y*r)},${Math.round(e.z*r)}`,c[1]=`${Math.round(n.x*r)},${Math.round(n.y*r)},${Math.round(n.z*r)}`,c[2]=`${Math.round(o.x*r)},${Math.round(o.y*r)},${Math.round(o.z*r)}`,c[0]!==c[1]&&c[1]!==c[2]&&c[2]!==c[0])for(let t=0;t<3;t++){const e=(t+1)%3,n=c[t],r=c[e],i=Zu[u[t]],a=Zu[u[e]],o=`${n}_${r}`,p=`${r}_${n}`;p in h&&h[p]?(Ju.dot(h[p].normal)<=s&&(d.push(i.x,i.y,i.z),d.push(a.x,a.y,a.z)),h[p]=null):o in h||(h[o]={index0:l[t],index1:l[e],normal:Ju.clone()})}}for(const t in h)if(h[t]){const{index0:e,index1:n}=h[t];Ku.fromBufferAttribute(a,e),Yu.fromBufferAttribute(a,n),d.push(Ku.x,Ku.y,Ku.z),d.push(Yu.x,Yu.y,Yu.z)}this.setAttribute("position",new $s(d,3))}}}class tc extends Uu{constructor(t){super(t),this.uuid=Tn(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,r=this.holes.length;n<r;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push(n.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const n=this.holes[e];t.holes.push(n.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const n=t.holes[e];this.holes.push((new Uu).fromJSON(n))}return this}}function ec(t,e,n,r,s){let i,a;if(s===function(t,e,n,r){let s=0;for(let i=e,a=n-r;i<n;i+=r)s+=(t[a]-t[i])*(t[i+1]+t[a+1]),a=i;return s}(t,e,n,r)>0)for(i=e;i<n;i+=r)a=Sc(i,t[i],t[i+1],a);else for(i=n-r;i>=e;i-=r)a=Sc(i,t[i],t[i+1],a);return a&&gc(a,a.next)&&(_c(a),a=a.next),a}function nc(t,e){if(!t)return t;e||(e=t);let n,r=t;do{if(n=!1,r.steiner||!gc(r,r.next)&&0!==mc(r.prev,r,r.next))r=r.next;else{if(_c(r),r=e=r.prev,r===r.next)break;n=!0}}while(n||r!==e);return e}function rc(t,e,n,r,s,i,a){if(!t)return;!a&&i&&function(t,e,n,r){let s=t;do{null===s.z&&(s.z=hc(s.x,s.y,e,n,r)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next}while(s!==t);s.prevZ.nextZ=null,s.prevZ=null,function(t){let e,n,r,s,i,a,o,l,u=1;do{for(n=t,t=null,i=null,a=0;n;){for(a++,r=n,o=0,e=0;e<u&&(o++,r=r.nextZ,r);e++);for(l=u;o>0||l>0&&r;)0!==o&&(0===l||!r||n.z<=r.z)?(s=n,n=n.nextZ,o--):(s=r,r=r.nextZ,l--),i?i.nextZ=s:t=s,s.prevZ=i,i=s;n=r}i.nextZ=null,u*=2}while(a>1)}(s)}(t,r,s,i);let o,l,u=t;for(;t.prev!==t.next;)if(o=t.prev,l=t.next,i?ic(t,r,s,i):sc(t))e.push(o.i/n),e.push(t.i/n),e.push(l.i/n),_c(t),t=l.next,u=l.next;else if((t=l)===u){a?1===a?rc(t=ac(nc(t),e,n),e,n,r,s,i,2):2===a&&oc(t,e,n,r,s,i):rc(nc(t),e,n,r,s,i,1);break}}function sc(t){const e=t.prev,n=t,r=t.next;if(mc(e,n,r)>=0)return!1;let s=t.next.next;for(;s!==t.prev;){if(pc(e.x,e.y,n.x,n.y,r.x,r.y,s.x,s.y)&&mc(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}function ic(t,e,n,r){const s=t.prev,i=t,a=t.next;if(mc(s,i,a)>=0)return!1;const o=s.x<i.x?s.x<a.x?s.x:a.x:i.x<a.x?i.x:a.x,l=s.y<i.y?s.y<a.y?s.y:a.y:i.y<a.y?i.y:a.y,u=s.x>i.x?s.x>a.x?s.x:a.x:i.x>a.x?i.x:a.x,c=s.y>i.y?s.y>a.y?s.y:a.y:i.y>a.y?i.y:a.y,h=hc(o,l,e,n,r),d=hc(u,c,e,n,r);let p=t.prevZ,f=t.nextZ;for(;p&&p.z>=h&&f&&f.z<=d;){if(p!==t.prev&&p!==t.next&&pc(s.x,s.y,i.x,i.y,a.x,a.y,p.x,p.y)&&mc(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,f!==t.prev&&f!==t.next&&pc(s.x,s.y,i.x,i.y,a.x,a.y,f.x,f.y)&&mc(f.prev,f,f.next)>=0)return!1;f=f.nextZ}for(;p&&p.z>=h;){if(p!==t.prev&&p!==t.next&&pc(s.x,s.y,i.x,i.y,a.x,a.y,p.x,p.y)&&mc(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==t.prev&&f!==t.next&&pc(s.x,s.y,i.x,i.y,a.x,a.y,f.x,f.y)&&mc(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function ac(t,e,n){let r=t;do{const s=r.prev,i=r.next.next;!gc(s,i)&&xc(s,r,r.next,i)&&bc(s,i)&&bc(i,s)&&(e.push(s.i/n),e.push(r.i/n),e.push(i.i/n),_c(r),_c(r.next),r=t=i),r=r.next}while(r!==t);return nc(r)}function oc(t,e,n,r,s,i){let a=t;do{let t=a.next.next;for(;t!==a.prev;){if(a.i!==t.i&&fc(a,t)){let o=wc(a,t);return a=nc(a,a.next),o=nc(o,o.next),rc(a,e,n,r,s,i),void rc(o,e,n,r,s,i)}t=t.next}a=a.next}while(a!==t)}function lc(t,e){return t.x-e.x}function uc(t,e){if(e=function(t,e){let n=e;const r=t.x,s=t.y;let i,a=-1/0;do{if(s<=n.y&&s>=n.next.y&&n.next.y!==n.y){const t=n.x+(s-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(t<=r&&t>a){if(a=t,t===r){if(s===n.y)return n;if(s===n.next.y)return n.next}i=n.x<n.next.x?n:n.next}}n=n.next}while(n!==e);if(!i)return null;if(r===a)return i;const o=i,l=i.x,u=i.y;let c,h=1/0;n=i;do{r>=n.x&&n.x>=l&&r!==n.x&&pc(s<u?r:a,s,l,u,s<u?a:r,s,n.x,n.y)&&(c=Math.abs(s-n.y)/(r-n.x),bc(n,t)&&(c<h||c===h&&(n.x>i.x||n.x===i.x&&cc(i,n)))&&(i=n,h=c)),n=n.next}while(n!==o);return i}(t,e),e){const n=wc(e,t);nc(e,e.next),nc(n,n.next)}}function cc(t,e){return mc(t.prev,t,e.prev)<0&&mc(e.next,t,t.next)<0}function hc(t,e,n,r,s){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*s)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*s)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function dc(t){let e=t,n=t;do{(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next}while(e!==t);return n}function pc(t,e,n,r,s,i,a,o){return(s-a)*(e-o)-(t-a)*(i-o)>=0&&(t-a)*(r-o)-(n-a)*(e-o)>=0&&(n-a)*(i-o)-(s-a)*(r-o)>=0}function fc(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!function(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&xc(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}(t,e)&&(bc(t,e)&&bc(e,t)&&function(t,e){let n=t,r=!1;const s=(t.x+e.x)/2,i=(t.y+e.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&s<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==t);return r}(t,e)&&(mc(t.prev,t,e.prev)||mc(t,e.prev,e))||gc(t,e)&&mc(t.prev,t,t.next)>0&&mc(e.prev,e,e.next)>0)}function mc(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function gc(t,e){return t.x===e.x&&t.y===e.y}function xc(t,e,n,r){const s=vc(mc(t,e,n)),i=vc(mc(t,e,r)),a=vc(mc(n,r,t)),o=vc(mc(n,r,e));return s!==i&&a!==o||!(0!==s||!yc(t,n,e))||!(0!==i||!yc(t,r,e))||!(0!==a||!yc(n,t,r))||!(0!==o||!yc(n,e,r))}function yc(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function vc(t){return t>0?1:t<0?-1:0}function bc(t,e){return mc(t.prev,t,t.next)<0?mc(t,e,t.next)>=0&&mc(t,t.prev,e)>=0:mc(t,e,t.prev)<0||mc(t,t.next,e)<0}function wc(t,e){const n=new Tc(t.i,t.x,t.y),r=new Tc(e.i,e.x,e.y),s=t.next,i=e.prev;return t.next=e,e.prev=t,n.next=s,s.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function Sc(t,e,n,r){const s=new Tc(t,e,n);return r?(s.next=r.next,s.prev=r,r.next.prev=s,r.next=s):(s.prev=s,s.next=s),s}function _c(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function Tc(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class Mc{static area(t){const e=t.length;let n=0;for(let r=e-1,s=0;s<e;r=s++)n+=t[r].x*t[s].y-t[s].x*t[r].y;return.5*n}static isClockWise(t){return Mc.area(t)<0}static triangulateShape(t,e){const n=[],r=[],s=[];Ec(t),kc(n,t);let i=t.length;e.forEach(Ec);for(let t=0;t<e.length;t++)r.push(i),i+=e[t].length,kc(n,e[t]);const a=function(t,e,n=2){const r=e&&e.length,s=r?e[0]*n:t.length;let i=ec(t,0,s,n,!0);const a=[];if(!i||i.next===i.prev)return a;let o,l,u,c,h,d,p;if(r&&(i=function(t,e,n,r){const s=[];let i,a,o,l,u;for(i=0,a=e.length;i<a;i++)o=e[i]*r,l=i<a-1?e[i+1]*r:t.length,u=ec(t,o,l,r,!1),u===u.next&&(u.steiner=!0),s.push(dc(u));for(s.sort(lc),i=0;i<s.length;i++)uc(s[i],n),n=nc(n,n.next);return n}(t,e,i,n)),t.length>80*n){o=u=t[0],l=c=t[1];for(let e=n;e<s;e+=n)h=t[e],d=t[e+1],h<o&&(o=h),d<l&&(l=d),h>u&&(u=h),d>c&&(c=d);p=Math.max(u-o,c-l),p=0!==p?1/p:0}return rc(i,a,n,o,l,p),a}(n,r);for(let t=0;t<a.length;t+=3)s.push(a.slice(t,t+3));return s}}function Ec(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function kc(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class Ic extends js{constructor(t=new tc([new Nn(.5,.5),new Nn(-.5,.5),new Nn(-.5,-.5),new Nn(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,r=[],s=[];for(let e=0,n=t.length;e<n;e++)i(t[e]);function i(t){const i=[],a=void 0!==e.curveSegments?e.curveSegments:12,o=void 0!==e.steps?e.steps:1;let l=void 0!==e.depth?e.depth:1,u=void 0===e.bevelEnabled||e.bevelEnabled,c=void 0!==e.bevelThickness?e.bevelThickness:.2,h=void 0!==e.bevelSize?e.bevelSize:c-.1,d=void 0!==e.bevelOffset?e.bevelOffset:0,p=void 0!==e.bevelSegments?e.bevelSegments:3;const f=e.extrudePath,m=void 0!==e.UVGenerator?e.UVGenerator:Cc;void 0!==e.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=e.amount);let g,x,y,v,b,w=!1;f&&(g=f.getSpacedPoints(o),w=!0,u=!1,x=f.computeFrenetFrames(o,!1),y=new ur,v=new ur,b=new ur),u||(p=0,c=0,h=0,d=0);const S=t.extractPoints(a);let _=S.shape;const T=S.holes;if(!Mc.isClockWise(_)){_=_.reverse();for(let t=0,e=T.length;t<e;t++){const e=T[t];Mc.isClockWise(e)&&(T[t]=e.reverse())}}const M=Mc.triangulateShape(_,T),E=_;for(let t=0,e=T.length;t<e;t++){const e=T[t];_=_.concat(e)}function k(t,e,n){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(n).add(t)}const I=_.length,C=M.length;function A(t,e,n){let r,s,i;const a=t.x-e.x,o=t.y-e.y,l=n.x-t.x,u=n.y-t.y,c=a*a+o*o,h=a*u-o*l;if(Math.abs(h)>Number.EPSILON){const h=Math.sqrt(c),d=Math.sqrt(l*l+u*u),p=e.x-o/h,f=e.y+a/h,m=((n.x-u/d-p)*u-(n.y+l/d-f)*l)/(a*u-o*l);r=p+a*m-t.x,s=f+o*m-t.y;const g=r*r+s*s;if(g<=2)return new Nn(r,s);i=Math.sqrt(g/2)}else{let t=!1;a>Number.EPSILON?l>Number.EPSILON&&(t=!0):a<-Number.EPSILON?l<-Number.EPSILON&&(t=!0):Math.sign(o)===Math.sign(u)&&(t=!0),t?(r=-o,s=a,i=Math.sqrt(c)):(r=a,s=o,i=Math.sqrt(c/2))}return new Nn(r/i,s/i)}const R=[];for(let t=0,e=E.length,n=e-1,r=t+1;t<e;t++,n++,r++)n===e&&(n=0),r===e&&(r=0),R[t]=A(E[t],E[n],E[r]);const N=[];let D,L=R.concat();for(let t=0,e=T.length;t<e;t++){const e=T[t];D=[];for(let t=0,n=e.length,r=n-1,s=t+1;t<n;t++,r++,s++)r===n&&(r=0),s===n&&(s=0),D[t]=A(e[t],e[r],e[s]);N.push(D),L=L.concat(D)}for(let t=0;t<p;t++){const e=t/p,n=c*Math.cos(e*Math.PI/2),r=h*Math.sin(e*Math.PI/2)+d;for(let t=0,e=E.length;t<e;t++){const e=k(E[t],R[t],r);$(e.x,e.y,-n)}for(let t=0,e=T.length;t<e;t++){const e=T[t];D=N[t];for(let t=0,s=e.length;t<s;t++){const s=k(e[t],D[t],r);$(s.x,s.y,-n)}}}const F=h+d;for(let t=0;t<I;t++){const e=u?k(_[t],L[t],F):_[t];w?(v.copy(x.normals[0]).multiplyScalar(e.x),y.copy(x.binormals[0]).multiplyScalar(e.y),b.copy(g[0]).add(v).add(y),$(b.x,b.y,b.z)):$(e.x,e.y,0)}for(let t=1;t<=o;t++)for(let e=0;e<I;e++){const n=u?k(_[e],L[e],F):_[e];w?(v.copy(x.normals[t]).multiplyScalar(n.x),y.copy(x.binormals[t]).multiplyScalar(n.y),b.copy(g[t]).add(v).add(y),$(b.x,b.y,b.z)):$(n.x,n.y,l/o*t)}for(let t=p-1;t>=0;t--){const e=t/p,n=c*Math.cos(e*Math.PI/2),r=h*Math.sin(e*Math.PI/2)+d;for(let t=0,e=E.length;t<e;t++){const e=k(E[t],R[t],r);$(e.x,e.y,l+n)}for(let t=0,e=T.length;t<e;t++){const e=T[t];D=N[t];for(let t=0,s=e.length;t<s;t++){const s=k(e[t],D[t],r);w?$(s.x,s.y+g[o-1].y,g[o-1].x+n):$(s.x,s.y,l+n)}}}function P(t,e){let n=t.length;for(;--n>=0;){const r=n;let s=n-1;s<0&&(s=t.length-1);for(let t=0,n=o+2*p;t<n;t++){const n=I*t,i=I*(t+1);z(e+r+n,e+s+n,e+s+i,e+r+i)}}}function $(t,e,n){i.push(t),i.push(e),i.push(n)}function O(t,e,s){B(t),B(e),B(s);const i=r.length/3,a=m.generateTopUV(n,r,i-3,i-2,i-1);U(a[0]),U(a[1]),U(a[2])}function z(t,e,s,i){B(t),B(e),B(i),B(e),B(s),B(i);const a=r.length/3,o=m.generateSideWallUV(n,r,a-6,a-3,a-2,a-1);U(o[0]),U(o[1]),U(o[3]),U(o[1]),U(o[2]),U(o[3])}function B(t){r.push(i[3*t+0]),r.push(i[3*t+1]),r.push(i[3*t+2])}function U(t){s.push(t.x),s.push(t.y)}!function(){const t=r.length/3;if(u){let t=0,e=I*t;for(let t=0;t<C;t++){const n=M[t];O(n[2]+e,n[1]+e,n[0]+e)}t=o+2*p,e=I*t;for(let t=0;t<C;t++){const n=M[t];O(n[0]+e,n[1]+e,n[2]+e)}}else{for(let t=0;t<C;t++){const e=M[t];O(e[2],e[1],e[0])}for(let t=0;t<C;t++){const e=M[t];O(e[0]+I*o,e[1]+I*o,e[2]+I*o)}}n.addGroup(t,r.length/3-t,0)}(),function(){const t=r.length/3;let e=0;P(E,e),e+=E.length;for(let t=0,n=T.length;t<n;t++){const n=T[t];P(n,e),e+=n.length}n.addGroup(t,r.length/3-t,1)}()}this.setAttribute("position",new $s(r,3)),this.setAttribute("uv",new $s(s,2)),this.computeVertexNormals()}toJSON(){const t=super.toJSON();return function(t,e,n){if(n.shapes=[],Array.isArray(t))for(let e=0,r=t.length;e<r;e++){const r=t[e];n.shapes.push(r.uuid)}else n.shapes.push(t.uuid);return void 0!==e.extrudePath&&(n.options.extrudePath=e.extrudePath.toJSON()),n}(this.parameters.shapes,this.parameters.options,t)}static fromJSON(t,e){const n=[];for(let r=0,s=t.shapes.length;r<s;r++){const s=e[t.shapes[r]];n.push(s)}const r=t.options.extrudePath;return void 0!==r&&(t.options.extrudePath=(new zu[r.type]).fromJSON(r)),new Ic(n,t.options)}}const Cc={generateTopUV:function(t,e,n,r,s){const i=e[3*n],a=e[3*n+1],o=e[3*r],l=e[3*r+1],u=e[3*s],c=e[3*s+1];return[new Nn(i,a),new Nn(o,l),new Nn(u,c)]},generateSideWallUV:function(t,e,n,r,s,i){const a=e[3*n],o=e[3*n+1],l=e[3*n+2],u=e[3*r],c=e[3*r+1],h=e[3*r+2],d=e[3*s],p=e[3*s+1],f=e[3*s+2],m=e[3*i],g=e[3*i+1],x=e[3*i+2];return Math.abs(o-c)<Math.abs(a-u)?[new Nn(a,1-l),new Nn(u,1-h),new Nn(d,1-f),new Nn(m,1-x)]:[new Nn(o,1-l),new Nn(c,1-h),new Nn(p,1-f),new Nn(g,1-x)]}};class Ac extends qu{constructor(t=1,e=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],t,e),this.type="IcosahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Ac(t.radius,t.detail)}}class Rc extends qu{constructor(t=1,e=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],t,e),this.type="OctahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Rc(t.radius,t.detail)}}class Nc extends js{constructor(t=.5,e=1,n=8,r=1,s=0,i=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:t,outerRadius:e,thetaSegments:n,phiSegments:r,thetaStart:s,thetaLength:i},n=Math.max(3,n);const a=[],o=[],l=[],u=[];let c=t;const h=(e-t)/(r=Math.max(1,r)),d=new ur,p=new Nn;for(let t=0;t<=r;t++){for(let t=0;t<=n;t++){const r=s+t/n*i;d.x=c*Math.cos(r),d.y=c*Math.sin(r),o.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/e+1)/2,p.y=(d.y/e+1)/2,u.push(p.x,p.y)}c+=h}for(let t=0;t<r;t++){const e=t*(n+1);for(let t=0;t<n;t++){const r=t+e,s=r,i=r+n+1,o=r+n+2,l=r+1;a.push(s,i,l),a.push(i,o,l)}}this.setIndex(a),this.setAttribute("position",new $s(o,3)),this.setAttribute("normal",new $s(l,3)),this.setAttribute("uv",new $s(u,2))}static fromJSON(t){return new Nc(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength)}}class Dc extends js{constructor(t=new tc([new Nn(0,.5),new Nn(-.5,-.5),new Nn(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],r=[],s=[],i=[];let a=0,o=0;if(!1===Array.isArray(t))l(t);else for(let e=0;e<t.length;e++)l(t[e]),this.addGroup(a,o,e),a+=o,o=0;function l(t){const a=r.length/3,l=t.extractPoints(e);let u=l.shape;const c=l.holes;!1===Mc.isClockWise(u)&&(u=u.reverse());for(let t=0,e=c.length;t<e;t++){const e=c[t];!0===Mc.isClockWise(e)&&(c[t]=e.reverse())}const h=Mc.triangulateShape(u,c);for(let t=0,e=c.length;t<e;t++){const e=c[t];u=u.concat(e)}for(let t=0,e=u.length;t<e;t++){const e=u[t];r.push(e.x,e.y,0),s.push(0,0,1),i.push(e.x,e.y)}for(let t=0,e=h.length;t<e;t++){const e=h[t],r=e[0]+a,s=e[1]+a,i=e[2]+a;n.push(r,s,i),o+=3}}this.setIndex(n),this.setAttribute("position",new $s(r,3)),this.setAttribute("normal",new $s(s,3)),this.setAttribute("uv",new $s(i,2))}toJSON(){const t=super.toJSON();return function(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,r=t.length;n<r;n++){const r=t[n];e.shapes.push(r.uuid)}else e.shapes.push(t.uuid);return e}(this.parameters.shapes,t)}static fromJSON(t,e){const n=[];for(let r=0,s=t.shapes.length;r<s;r++){const s=e[t.shapes[r]];n.push(s)}return new Dc(n,t.curveSegments)}}class Lc extends js{constructor(t=1,e=32,n=16,r=0,s=2*Math.PI,i=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:r,phiLength:s,thetaStart:i,thetaLength:a},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const o=Math.min(i+a,Math.PI);let l=0;const u=[],c=new ur,h=new ur,d=[],p=[],f=[],m=[];for(let d=0;d<=n;d++){const g=[],x=d/n;let y=0;0==d&&0==i?y=.5/e:d==n&&o==Math.PI&&(y=-.5/e);for(let n=0;n<=e;n++){const o=n/e;c.x=-t*Math.cos(r+o*s)*Math.sin(i+x*a),c.y=t*Math.cos(i+x*a),c.z=t*Math.sin(r+o*s)*Math.sin(i+x*a),p.push(c.x,c.y,c.z),h.copy(c).normalize(),f.push(h.x,h.y,h.z),m.push(o+y,1-x),g.push(l++)}u.push(g)}for(let t=0;t<n;t++)for(let r=0;r<e;r++){const e=u[t][r+1],s=u[t][r],a=u[t+1][r],l=u[t+1][r+1];(0!==t||i>0)&&d.push(e,s,l),(t!==n-1||o<Math.PI)&&d.push(s,a,l)}this.setIndex(d),this.setAttribute("position",new $s(p,3)),this.setAttribute("normal",new $s(f,3)),this.setAttribute("uv",new $s(m,2))}static fromJSON(t){return new Lc(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class Fc extends qu{constructor(t=1,e=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],t,e),this.type="TetrahedronGeometry",this.parameters={radius:t,detail:e}}static fromJSON(t){return new Fc(t.radius,t.detail)}}class Pc extends js{constructor(t=1,e=.4,n=8,r=6,s=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:r,arc:s},n=Math.floor(n),r=Math.floor(r);const i=[],a=[],o=[],l=[],u=new ur,c=new ur,h=new ur;for(let i=0;i<=n;i++)for(let d=0;d<=r;d++){const p=d/r*s,f=i/n*Math.PI*2;c.x=(t+e*Math.cos(f))*Math.cos(p),c.y=(t+e*Math.cos(f))*Math.sin(p),c.z=e*Math.sin(f),a.push(c.x,c.y,c.z),u.x=t*Math.cos(p),u.y=t*Math.sin(p),h.subVectors(c,u).normalize(),o.push(h.x,h.y,h.z),l.push(d/r),l.push(i/n)}for(let t=1;t<=n;t++)for(let e=1;e<=r;e++){const n=(r+1)*t+e-1,s=(r+1)*(t-1)+e-1,a=(r+1)*(t-1)+e,o=(r+1)*t+e;i.push(n,s,o),i.push(s,a,o)}this.setIndex(i),this.setAttribute("position",new $s(a,3)),this.setAttribute("normal",new $s(o,3)),this.setAttribute("uv",new $s(l,2))}static fromJSON(t){return new Pc(t.radius,t.tube,t.radialSegments,t.tubularSegments,t.arc)}}class $c extends js{constructor(t=1,e=.4,n=64,r=8,s=2,i=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:t,tube:e,tubularSegments:n,radialSegments:r,p:s,q:i},n=Math.floor(n),r=Math.floor(r);const a=[],o=[],l=[],u=[],c=new ur,h=new ur,d=new ur,p=new ur,f=new ur,m=new ur,g=new ur;for(let a=0;a<=n;++a){const y=a/n*s*Math.PI*2;x(y,s,i,t,d),x(y+.01,s,i,t,p),m.subVectors(p,d),g.addVectors(p,d),f.crossVectors(m,g),g.crossVectors(f,m),f.normalize(),g.normalize();for(let t=0;t<=r;++t){const s=t/r*Math.PI*2,i=-e*Math.cos(s),p=e*Math.sin(s);c.x=d.x+(i*g.x+p*f.x),c.y=d.y+(i*g.y+p*f.y),c.z=d.z+(i*g.z+p*f.z),o.push(c.x,c.y,c.z),h.subVectors(c,d).normalize(),l.push(h.x,h.y,h.z),u.push(a/n),u.push(t/r)}}for(let t=1;t<=n;t++)for(let e=1;e<=r;e++){const n=(r+1)*(t-1)+(e-1),s=(r+1)*t+(e-1),i=(r+1)*t+e,o=(r+1)*(t-1)+e;a.push(n,s,o),a.push(s,i,o)}function x(t,e,n,r,s){const i=Math.cos(t),a=Math.sin(t),o=n/e*t,l=Math.cos(o);s.x=r*(2+l)*.5*i,s.y=r*(2+l)*a*.5,s.z=r*Math.sin(o)*.5}this.setIndex(a),this.setAttribute("position",new $s(o,3)),this.setAttribute("normal",new $s(l,3)),this.setAttribute("uv",new $s(u,2))}static fromJSON(t){return new $c(t.radius,t.tube,t.tubularSegments,t.radialSegments,t.p,t.q)}}class Oc extends js{constructor(t=new $u(new ur(-1,-1,0),new ur(-1,1,0),new ur(1,1,0)),e=64,n=1,r=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:t,tubularSegments:e,radius:n,radialSegments:r,closed:s};const i=t.computeFrenetFrames(e,s);this.tangents=i.tangents,this.normals=i.normals,this.binormals=i.binormals;const a=new ur,o=new ur,l=new Nn;let u=new ur;const c=[],h=[],d=[],p=[];function f(s){u=t.getPointAt(s/e,u);const l=i.normals[s],d=i.binormals[s];for(let t=0;t<=r;t++){const e=t/r*Math.PI*2,s=Math.sin(e),i=-Math.cos(e);o.x=i*l.x+s*d.x,o.y=i*l.y+s*d.y,o.z=i*l.z+s*d.z,o.normalize(),h.push(o.x,o.y,o.z),a.x=u.x+n*o.x,a.y=u.y+n*o.y,a.z=u.z+n*o.z,c.push(a.x,a.y,a.z)}}!function(){for(let t=0;t<e;t++)f(t);f(!1===s?e:0),function(){for(let t=0;t<=e;t++)for(let n=0;n<=r;n++)l.x=t/e,l.y=n/r,d.push(l.x,l.y)}(),function(){for(let t=1;t<=e;t++)for(let e=1;e<=r;e++){const n=(r+1)*(t-1)+(e-1),s=(r+1)*t+(e-1),i=(r+1)*t+e,a=(r+1)*(t-1)+e;p.push(n,s,a),p.push(s,i,a)}}()}(),this.setIndex(p),this.setAttribute("position",new $s(c,3)),this.setAttribute("normal",new $s(h,3)),this.setAttribute("uv",new $s(d,2))}toJSON(){const t=super.toJSON();return t.path=this.parameters.path.toJSON(),t}static fromJSON(t){return new Oc((new zu[t.path.type]).fromJSON(t.path),t.tubularSegments,t.radius,t.radialSegments,t.closed)}}class zc extends js{constructor(t=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:t},null!==t){const e=[],n=new Set,r=new ur,s=new ur;if(null!==t.index){const i=t.attributes.position,a=t.index;let o=t.groups;0===o.length&&(o=[{start:0,count:a.count,materialIndex:0}]);for(let t=0,l=o.length;t<l;++t){const l=o[t],u=l.start;for(let t=u,o=u+l.count;t<o;t+=3)for(let o=0;o<3;o++){const l=a.getX(t+o),u=a.getX(t+(o+1)%3);r.fromBufferAttribute(i,l),s.fromBufferAttribute(i,u),!0===Bc(r,s,n)&&(e.push(r.x,r.y,r.z),e.push(s.x,s.y,s.z))}}}else{const i=t.attributes.position;for(let t=0,a=i.count/3;t<a;t++)for(let a=0;a<3;a++){const o=3*t+a,l=3*t+(a+1)%3;r.fromBufferAttribute(i,o),s.fromBufferAttribute(i,l),!0===Bc(r,s,n)&&(e.push(r.x,r.y,r.z),e.push(s.x,s.y,s.z))}}this.setAttribute("position",new $s(e,3))}}}function Bc(t,e,n){const r=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,s=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return!0!==n.has(r)&&!0!==n.has(s)&&(n.add(r),n.add(s),!0)}var Uc=Object.freeze({__proto__:null,BoxGeometry:di,BoxBufferGeometry:di,CapsuleGeometry:Vu,CapsuleBufferGeometry:Vu,CircleGeometry:Gu,CircleBufferGeometry:Gu,ConeGeometry:ju,ConeBufferGeometry:ju,CylinderGeometry:Hu,CylinderBufferGeometry:Hu,DodecahedronGeometry:Xu,DodecahedronBufferGeometry:Xu,EdgesGeometry:Qu,ExtrudeGeometry:Ic,ExtrudeBufferGeometry:Ic,IcosahedronGeometry:Ac,IcosahedronBufferGeometry:Ac,LatheGeometry:Wu,LatheBufferGeometry:Wu,OctahedronGeometry:Rc,OctahedronBufferGeometry:Rc,PlaneGeometry:Ni,PlaneBufferGeometry:Ni,PolyhedronGeometry:qu,PolyhedronBufferGeometry:qu,RingGeometry:Nc,RingBufferGeometry:Nc,ShapeGeometry:Dc,ShapeBufferGeometry:Dc,SphereGeometry:Lc,SphereBufferGeometry:Lc,TetrahedronGeometry:Fc,TetrahedronBufferGeometry:Fc,TorusGeometry:Pc,TorusBufferGeometry:Pc,TorusKnotGeometry:$c,TorusKnotBufferGeometry:$c,TubeGeometry:Oc,TubeBufferGeometry:Oc,WireframeGeometry:zc});class Wc extends Ts{constructor(t){super(),this.type="ShadowMaterial",this.color=new Xn(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}Wc.prototype.isShadowMaterial=!0;class Vc extends gi{constructor(t){super(t),this.type="RawShaderMaterial"}}Vc.prototype.isRawShaderMaterial=!0;class Gc extends Ts{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Xn(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Xn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ze,this.normalScale=new Nn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}Gc.prototype.isMeshStandardMaterial=!0;class Hc extends Gc{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Nn(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Mn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new Xn(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Xn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Xn(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}Hc.prototype.isMeshPhysicalMaterial=!0;class jc extends Ts{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new Xn(16777215),this.specular=new Xn(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Xn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ze,this.normalScale=new Nn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Z,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}jc.prototype.isMeshPhongMaterial=!0;class qc extends Ts{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Xn(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Xn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ze,this.normalScale=new Nn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}qc.prototype.isMeshToonMaterial=!0;class Xc extends Ts{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ze,this.normalScale=new Nn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}Xc.prototype.isMeshNormalMaterial=!0;class Kc extends Ts{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new Xn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Xn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Z,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}Kc.prototype.isMeshLambertMaterial=!0;class Yc extends Ts{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Xn(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ze,this.normalScale=new Nn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this.fog=t.fog,this}}Yc.prototype.isMeshMatcapMaterial=!0;class Jc extends Zl{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}Jc.prototype.isLineDashedMaterial=!0;const Zc={ShadowMaterial:Wc,SpriteMaterial:gl,RawShaderMaterial:Vc,ShaderMaterial:gi,PointsMaterial:uu,MeshPhysicalMaterial:Hc,MeshStandardMaterial:Gc,MeshPhongMaterial:jc,MeshToonMaterial:qc,MeshNormalMaterial:Xc,MeshLambertMaterial:Kc,MeshDepthMaterial:Ko,MeshDistanceMaterial:Yo,MeshBasicMaterial:Ms,MeshMatcapMaterial:Yc,LineDashedMaterial:Jc,LineBasicMaterial:Zl,Material:Ts};Ts.fromType=function(t){return new Zc[t]};const Qc={arraySlice:function(t,e,n){return Qc.isTypedArray(t)?new t.constructor(t.subarray(e,void 0!==n?n:t.length)):t.slice(e,n)},convertArray:function(t,e,n){return!t||!n&&t.constructor===e?t:"number"==typeof e.BYTES_PER_ELEMENT?new e(t):Array.prototype.slice.call(t)},isTypedArray:function(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)},getKeyframeOrder:function(t){const e=t.length,n=new Array(e);for(let t=0;t!==e;++t)n[t]=t;return n.sort((function(e,n){return t[e]-t[n]})),n},sortedArray:function(t,e,n){const r=t.length,s=new t.constructor(r);for(let i=0,a=0;a!==r;++i){const r=n[i]*e;for(let n=0;n!==e;++n)s[a++]=t[r+n]}return s},flattenJSON:function(t,e,n,r){let s=1,i=t[0];for(;void 0!==i&&void 0===i[r];)i=t[s++];if(void 0===i)return;let a=i[r];if(void 0!==a)if(Array.isArray(a))do{a=i[r],void 0!==a&&(e.push(i.time),n.push.apply(n,a)),i=t[s++]}while(void 0!==i);else if(void 0!==a.toArray)do{a=i[r],void 0!==a&&(e.push(i.time),a.toArray(n,n.length)),i=t[s++]}while(void 0!==i);else do{a=i[r],void 0!==a&&(e.push(i.time),n.push(a)),i=t[s++]}while(void 0!==i)},subclip:function(t,e,n,r,s=30){const i=t.clone();i.name=e;const a=[];for(let t=0;t<i.tracks.length;++t){const e=i.tracks[t],o=e.getValueSize(),l=[],u=[];for(let t=0;t<e.times.length;++t){const i=e.times[t]*s;if(!(i<n||i>=r)){l.push(e.times[t]);for(let n=0;n<o;++n)u.push(e.values[t*o+n])}}0!==l.length&&(e.times=Qc.convertArray(l,e.times.constructor),e.values=Qc.convertArray(u,e.values.constructor),a.push(e))}i.tracks=a;let o=1/0;for(let t=0;t<i.tracks.length;++t)o>i.tracks[t].times[0]&&(o=i.tracks[t].times[0]);for(let t=0;t<i.tracks.length;++t)i.tracks[t].shift(-1*o);return i.resetDuration(),i},makeClipAdditive:function(t,e=0,n=t,r=30){r<=0&&(r=30);const s=n.tracks.length,i=e/r;for(let e=0;e<s;++e){const r=n.tracks[e],s=r.ValueTypeName;if("bool"===s||"string"===s)continue;const a=t.tracks.find((function(t){return t.name===r.name&&t.ValueTypeName===s}));if(void 0===a)continue;let o=0;const l=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let u=0;const c=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=c/3);const h=r.times.length-1;let d;if(i<=r.times[0]){const t=o,e=l-o;d=Qc.arraySlice(r.values,t,e)}else if(i>=r.times[h]){const t=h*l+o,e=t+l-o;d=Qc.arraySlice(r.values,t,e)}else{const t=r.createInterpolant(),e=o,n=l-o;t.evaluate(i),d=Qc.arraySlice(t.resultBuffer,e,n)}"quaternion"===s&&(new lr).fromArray(d).normalize().conjugate().toArray(d);const p=a.times.length;for(let t=0;t<p;++t){const e=t*c+u;if("quaternion"===s)lr.multiplyQuaternionsFlat(a.values,e,d,0,a.values,e);else{const t=c-2*u;for(let n=0;n<t;++n)a.values[e+n]-=d[n]}}}return t.blendMode=Re,t}};class th{constructor(t,e,n,r){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,r=e[n],s=e[n-1];t:{e:{let i;n:{r:if(!(t<r)){for(let i=n+2;;){if(void 0===r){if(t<s)break r;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,s)}if(n===i)break;if(s=r,r=e[++n],t<r)break e}i=e.length;break n}if(t>=s)break t;{const a=e[1];t<a&&(n=2,s=a);for(let i=n-2;;){if(void 0===s)return this._cachedIndex=0,this.beforeStart_(0,t,r);if(n===i)break;if(r=s,s=e[--n-1],t>=s)break e}i=n,n=0}}for(;n<i;){const r=n+i>>>1;t<e[r]?i=r:n=r+1}if(r=e[n],s=e[n-1],void 0===s)return this._cachedIndex=0,this.beforeStart_(0,t,r);if(void 0===r)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,s,t)}this._cachedIndex=n,this.intervalChanged_(n,s,r)}return this.interpolate_(n,s,t,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,r=this.valueSize,s=t*r;for(let t=0;t!==r;++t)e[t]=n[s+t];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}th.prototype.beforeStart_=th.prototype.copySampleValue_,th.prototype.afterEnd_=th.prototype.copySampleValue_;class eh extends th{constructor(t,e,n,r){super(t,e,n,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ke,endingEnd:ke}}intervalChanged_(t,e,n){const r=this.parameterPositions;let s=t-2,i=t+1,a=r[s],o=r[i];if(void 0===a)switch(this.getSettings_().endingStart){case Ie:s=t,a=2*e-n;break;case Ce:s=r.length-2,a=e+r[s]-r[s+1];break;default:s=t,a=n}if(void 0===o)switch(this.getSettings_().endingEnd){case Ie:i=t,o=2*n-e;break;case Ce:i=1,o=n+r[1]-r[0];break;default:i=t-1,o=e}const l=.5*(n-e),u=this.valueSize;this._weightPrev=l/(e-a),this._weightNext=l/(o-n),this._offsetPrev=s*u,this._offsetNext=i*u}interpolate_(t,e,n,r){const s=this.resultBuffer,i=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,u=this._offsetPrev,c=this._offsetNext,h=this._weightPrev,d=this._weightNext,p=(n-e)/(r-e),f=p*p,m=f*p,g=-h*m+2*h*f-h*p,x=(1+h)*m+(-1.5-2*h)*f+(-.5+h)*p+1,y=(-1-d)*m+(1.5+d)*f+.5*p,v=d*m-d*f;for(let t=0;t!==a;++t)s[t]=g*i[u+t]+x*i[l+t]+y*i[o+t]+v*i[c+t];return s}}class nh extends th{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const s=this.resultBuffer,i=this.sampleValues,a=this.valueSize,o=t*a,l=o-a,u=(n-e)/(r-e),c=1-u;for(let t=0;t!==a;++t)s[t]=i[l+t]*c+i[o+t]*u;return s}}class rh extends th{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t){return this.copySampleValue_(t-1)}}class sh{constructor(t,e,n,r){if(void 0===t)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===e||0===e.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Qc.convertArray(e,this.TimeBufferType),this.values=Qc.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:Qc.convertArray(t.times,Array),values:Qc.convertArray(t.values,Array)};const e=t.getInterpolation();e!==t.DefaultInterpolation&&(n.interpolation=e)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new rh(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new nh(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new eh(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Te:e=this.InterpolantFactoryMethodDiscrete;break;case Me:e=this.InterpolantFactoryMethodLinear;break;case Ee:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){const e="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(t===this.DefaultInterpolation)throw new Error(e);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",e),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Te;case this.InterpolantFactoryMethodLinear:return Me;case this.InterpolantFactoryMethodSmooth:return Ee}}getValueSize(){return this.values.length/this.times.length}shift(t){if(0!==t){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]+=t}return this}scale(t){if(1!==t){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]*=t}return this}trim(t,e){const n=this.times,r=n.length;let s=0,i=r-1;for(;s!==r&&n[s]<t;)++s;for(;-1!==i&&n[i]>e;)--i;if(++i,0!==s||i!==r){s>=i&&(i=Math.max(i,1),s=i-1);const t=this.getValueSize();this.times=Qc.arraySlice(n,s,i),this.values=Qc.arraySlice(this.values,s*t,i*t)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,r=this.values,s=n.length;0===s&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let i=null;for(let e=0;e!==s;e++){const r=n[e];if("number"==typeof r&&isNaN(r)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,e,r),t=!1;break}if(null!==i&&i>r){console.error("THREE.KeyframeTrack: Out of order keys.",this,e,r,i),t=!1;break}i=r}if(void 0!==r&&Qc.isTypedArray(r))for(let e=0,n=r.length;e!==n;++e){const n=r[e];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,e,n),t=!1;break}}return t}optimize(){const t=Qc.arraySlice(this.times),e=Qc.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===Ee,s=t.length-1;let i=1;for(let a=1;a<s;++a){let s=!1;const o=t[a];if(o!==t[a+1]&&(1!==a||o!==t[0]))if(r)s=!0;else{const t=a*n,r=t-n,i=t+n;for(let a=0;a!==n;++a){const n=e[t+a];if(n!==e[r+a]||n!==e[i+a]){s=!0;break}}}if(s){if(a!==i){t[i]=t[a];const r=a*n,s=i*n;for(let t=0;t!==n;++t)e[s+t]=e[r+t]}++i}}if(s>0){t[i]=t[s];for(let t=s*n,r=i*n,a=0;a!==n;++a)e[r+a]=e[t+a];++i}return i!==t.length?(this.times=Qc.arraySlice(t,0,i),this.values=Qc.arraySlice(e,0,i*n)):(this.times=t,this.values=e),this}clone(){const t=Qc.arraySlice(this.times,0),e=Qc.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}sh.prototype.TimeBufferType=Float32Array,sh.prototype.ValueBufferType=Float32Array,sh.prototype.DefaultInterpolation=Me;class ih extends sh{}ih.prototype.ValueTypeName="bool",ih.prototype.ValueBufferType=Array,ih.prototype.DefaultInterpolation=Te,ih.prototype.InterpolantFactoryMethodLinear=void 0,ih.prototype.InterpolantFactoryMethodSmooth=void 0;class ah extends sh{}ah.prototype.ValueTypeName="color";class oh extends sh{}oh.prototype.ValueTypeName="number";class lh extends th{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const s=this.resultBuffer,i=this.sampleValues,a=this.valueSize,o=(n-e)/(r-e);let l=t*a;for(let t=l+a;l!==t;l+=4)lr.slerpFlat(s,0,i,l-a,i,l,o);return s}}class uh extends sh{InterpolantFactoryMethodLinear(t){return new lh(this.times,this.values,this.getValueSize(),t)}}uh.prototype.ValueTypeName="quaternion",uh.prototype.DefaultInterpolation=Me,uh.prototype.InterpolantFactoryMethodSmooth=void 0;class ch extends sh{}ch.prototype.ValueTypeName="string",ch.prototype.ValueBufferType=Array,ch.prototype.DefaultInterpolation=Te,ch.prototype.InterpolantFactoryMethodLinear=void 0,ch.prototype.InterpolantFactoryMethodSmooth=void 0;class hh extends sh{}hh.prototype.ValueTypeName="vector";class dh{constructor(t,e=-1,n,r=Ae){this.name=t,this.tracks=n,this.duration=e,this.blendMode=r,this.uuid=Tn(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,r=1/(t.fps||1);for(let t=0,s=n.length;t!==s;++t)e.push(ph(n[t]).scale(r));const s=new this(t.name,t.duration,e,t.blendMode);return s.uuid=t.uuid,s}static toJSON(t){const e=[],n=t.tracks,r={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let t=0,r=n.length;t!==r;++t)e.push(sh.toJSON(n[t]));return r}static CreateFromMorphTargetSequence(t,e,n,r){const s=e.length,i=[];for(let t=0;t<s;t++){let a=[],o=[];a.push((t+s-1)%s,t,(t+1)%s),o.push(0,1,0);const l=Qc.getKeyframeOrder(a);a=Qc.sortedArray(a,1,l),o=Qc.sortedArray(o,1,l),r||0!==a[0]||(a.push(s),o.push(o[0])),i.push(new oh(".morphTargetInfluences["+e[t].name+"]",a,o).scale(1/n))}return new this(t,-1,i)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const e=t;n=e.geometry&&e.geometry.animations||e.animations}for(let t=0;t<n.length;t++)if(n[t].name===e)return n[t];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const r={},s=/^([\w-]*?)([\d]+)$/;for(let e=0,n=t.length;e<n;e++){const n=t[e],i=n.name.match(s);if(i&&i.length>1){const t=i[1];let e=r[t];e||(r[t]=e=[]),e.push(n)}}const i=[];for(const t in r)i.push(this.CreateFromMorphTargetSequence(t,r[t],e,n));return i}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(t,e,n,r,s){if(0!==n.length){const i=[],a=[];Qc.flattenJSON(n,i,a,r),0!==i.length&&s.push(new t(e,i,a))}},r=[],s=t.name||"default",i=t.fps||30,a=t.blendMode;let o=t.length||-1;const l=t.hierarchy||[];for(let t=0;t<l.length;t++){const s=l[t].keys;if(s&&0!==s.length)if(s[0].morphTargets){const t={};let e;for(e=0;e<s.length;e++)if(s[e].morphTargets)for(let n=0;n<s[e].morphTargets.length;n++)t[s[e].morphTargets[n]]=-1;for(const n in t){const t=[],i=[];for(let r=0;r!==s[e].morphTargets.length;++r){const r=s[e];t.push(r.time),i.push(r.morphTarget===n?1:0)}r.push(new oh(".morphTargetInfluence["+n+"]",t,i))}o=t.length*i}else{const i=".bones["+e[t].name+"]";n(hh,i+".position",s,"pos",r),n(uh,i+".quaternion",s,"rot",r),n(hh,i+".scale",s,"scl",r)}}return 0===r.length?null:new this(s,o,r,a)}resetDuration(){let t=0;for(let e=0,n=this.tracks.length;e!==n;++e){const n=this.tracks[e];t=Math.max(t,n.times[n.times.length-1])}return this.duration=t,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function ph(t){if(void 0===t.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=function(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return oh;case"vector":case"vector2":case"vector3":case"vector4":return hh;case"color":return ah;case"quaternion":return uh;case"bool":case"boolean":return ih;case"string":return ch}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}(t.type);if(void 0===t.times){const e=[],n=[];Qc.flattenJSON(t.keys,e,n,"value"),t.times=e,t.values=n}return void 0!==e.parse?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const fh={enabled:!1,files:{},add:function(t,e){!1!==this.enabled&&(this.files[t]=e)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class mh{constructor(t,e,n){const r=this;let s,i=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(t){o++,!1===i&&void 0!==r.onStart&&r.onStart(t,a,o),i=!0},this.itemEnd=function(t){a++,void 0!==r.onProgress&&r.onProgress(t,a,o),a===o&&(i=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(t){void 0!==r.onError&&r.onError(t)},this.resolveURL=function(t){return s?s(t):t},this.setURLModifier=function(t){return s=t,this},this.addHandler=function(t,e){return l.push(t,e),this},this.removeHandler=function(t){const e=l.indexOf(t);return-1!==e&&l.splice(e,2),this},this.getHandler=function(t){for(let e=0,n=l.length;e<n;e+=2){const n=l[e],r=l[e+1];if(n.global&&(n.lastIndex=0),n.test(t))return r}return null}}}const gh=new mh;class xh{constructor(t){this.manager=void 0!==t?t:gh,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise((function(r,s){n.load(t,r,e,s)}))}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const yh={};class vh extends xh{constructor(t){super(t)}load(t,e,n,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const s=fh.get(t);if(void 0!==s)return this.manager.itemStart(t),setTimeout((()=>{e&&e(s),this.manager.itemEnd(t)}),0),s;if(void 0!==yh[t])return void yh[t].push({onLoad:e,onProgress:n,onError:r});yh[t]=[],yh[t].push({onLoad:e,onProgress:n,onError:r});const i=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,o=this.responseType;fetch(i).then((e=>{if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;const n=yh[t],r=e.body.getReader(),s=e.headers.get("Content-Length"),i=s?parseInt(s):0,a=0!==i;let o=0;const l=new ReadableStream({start(t){!function e(){r.read().then((({done:r,value:s})=>{if(r)t.close();else{o+=s.byteLength;const r=new ProgressEvent("progress",{lengthComputable:a,loaded:o,total:i});for(let t=0,e=n.length;t<e;t++){const e=n[t];e.onProgress&&e.onProgress(r)}t.enqueue(s),e()}}))}()}});return new Response(l)}throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)})).then((t=>{switch(o){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then((t=>(new DOMParser).parseFromString(t,a)));case"json":return t.json();default:if(void 0===a)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(a),n=e&&e[1]?e[1].toLowerCase():void 0,r=new TextDecoder(n);return t.arrayBuffer().then((t=>r.decode(t)))}}})).then((e=>{fh.add(t,e);const n=yh[t];delete yh[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onLoad&&r.onLoad(e)}})).catch((e=>{const n=yh[t];if(void 0===n)throw this.manager.itemError(t),e;delete yh[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];r.onError&&r.onError(e)}this.manager.itemError(t)})).finally((()=>{this.manager.itemEnd(t)})),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class bh extends xh{constructor(t){super(t)}load(t,e,n,r){const s=this,i=new vh(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,(function(n){try{e(s.parse(JSON.parse(n)))}catch(e){r?r(e):console.error(e),s.manager.itemError(t)}}),n,r)}parse(t){const e=[];for(let n=0;n<t.length;n++){const r=dh.parse(t[n]);e.push(r)}return e}}class wh extends xh{constructor(t){super(t)}load(t,e,n,r){const s=this,i=[],a=new yu,o=new vh(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(s.withCredentials);let l=0;function u(u){o.load(t[u],(function(t){const n=s.parse(t,!0);i[u]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(a.minFilter=wt),a.image=i,a.format=n.format,a.needsUpdate=!0,e&&e(a))}),n,r)}if(Array.isArray(t))for(let e=0,n=t.length;e<n;++e)u(e);else o.load(t,(function(t){const n=s.parse(t,!0);if(n.isCubemap){const t=n.mipmaps.length/n.mipmapCount;for(let e=0;e<t;e++){i[e]={mipmaps:[]};for(let t=0;t<n.mipmapCount;t++)i[e].mipmaps.push(n.mipmaps[e*n.mipmapCount+t]),i[e].format=n.format,i[e].width=n.width,i[e].height=n.height}a.image=i}else a.image.width=n.width,a.image.height=n.height,a.mipmaps=n.mipmaps;1===n.mipmapCount&&(a.minFilter=wt),a.format=n.format,a.needsUpdate=!0,e&&e(a)}),n,r);return a}}class Sh extends xh{constructor(t){super(t)}load(t,e,n,r){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,i=fh.get(t);if(void 0!==i)return s.manager.itemStart(t),setTimeout((function(){e&&e(i),s.manager.itemEnd(t)}),0),i;const a=$n("img");function o(){u(),fh.add(t,this),e&&e(this),s.manager.itemEnd(t)}function l(e){u(),r&&r(e),s.manager.itemError(t),s.manager.itemEnd(t)}function u(){a.removeEventListener("load",o,!1),a.removeEventListener("error",l,!1)}return a.addEventListener("load",o,!1),a.addEventListener("error",l,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(t),a.src=t,a}}class _h extends xh{constructor(t){super(t)}load(t,e,n,r){const s=new wi,i=new Sh(this.manager);i.setCrossOrigin(this.crossOrigin),i.setPath(this.path);let a=0;function o(n){i.load(t[n],(function(t){s.images[n]=t,a++,6===a&&(s.needsUpdate=!0,e&&e(s))}),void 0,r)}for(let e=0;e<t.length;++e)o(e);return s}}class Th extends xh{constructor(t){super(t)}load(t,e,n,r){const s=this,i=new Wl,a=new vh(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(s.withCredentials),a.load(t,(function(t){const n=s.parse(t);n&&(void 0!==n.image?i.image=n.image:void 0!==n.data&&(i.image.width=n.width,i.image.height=n.height,i.image.data=n.data),i.wrapS=void 0!==n.wrapS?n.wrapS:ft,i.wrapT=void 0!==n.wrapT?n.wrapT:ft,i.magFilter=void 0!==n.magFilter?n.magFilter:wt,i.minFilter=void 0!==n.minFilter?n.minFilter:wt,i.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(i.encoding=n.encoding),void 0!==n.flipY&&(i.flipY=n.flipY),void 0!==n.format&&(i.format=n.format),void 0!==n.type&&(i.type=n.type),void 0!==n.mipmaps&&(i.mipmaps=n.mipmaps,i.minFilter=Tt),1===n.mipmapCount&&(i.minFilter=wt),void 0!==n.generateMipmaps&&(i.generateMipmaps=n.generateMipmaps),i.needsUpdate=!0,e&&e(i,n))}),n,r),i}}class Mh extends xh{constructor(t){super(t)}load(t,e,n,r){const s=new tr,i=new Sh(this.manager);return i.setCrossOrigin(this.crossOrigin),i.setPath(this.path),i.load(t,(function(t){s.image=t,s.needsUpdate=!0,void 0!==e&&e(s)}),n,r),s}}class Eh extends hs{constructor(t,e=1){super(),this.type="Light",this.color=new Xn(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}Eh.prototype.isLight=!0;class kh extends Eh{constructor(t,e,n){super(t,n),this.type="HemisphereLight",this.position.copy(hs.DefaultUp),this.updateMatrix(),this.groundColor=new Xn(e)}copy(t){return Eh.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}kh.prototype.isHemisphereLight=!0;const Ih=new Br,Ch=new ur,Ah=new ur;class Rh{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Nn(512,512),this.map=null,this.mapPass=null,this.matrix=new Br,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Ci,this._frameExtents=new Nn(1,1),this._viewportCount=1,this._viewports=[new er(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Ch.setFromMatrixPosition(t.matrixWorld),e.position.copy(Ch),Ah.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Ah),e.updateMatrixWorld(),Ih.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ih),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const t={};return 0!==this.bias&&(t.bias=this.bias),0!==this.normalBias&&(t.normalBias=this.normalBias),1!==this.radius&&(t.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Nh extends Rh{constructor(){super(new yi(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,n=2*_n*t.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=t.distance||e.far;n===e.fov&&r===e.aspect&&s===e.far||(e.fov=n,e.aspect=r,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}Nh.prototype.isSpotLightShadow=!0;class Dh extends Eh{constructor(t,e,n=0,r=Math.PI/3,s=0,i=1){super(t,e),this.type="SpotLight",this.position.copy(hs.DefaultUp),this.updateMatrix(),this.target=new hs,this.distance=n,this.angle=r,this.penumbra=s,this.decay=i,this.shadow=new Nh}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Dh.prototype.isSpotLight=!0;const Lh=new Br,Fh=new ur,Ph=new ur;class $h extends Rh{constructor(){super(new yi(90,1,.5,500)),this._frameExtents=new Nn(4,2),this._viewportCount=6,this._viewports=[new er(2,1,1,1),new er(0,1,1,1),new er(3,1,1,1),new er(1,1,1,1),new er(3,0,1,1),new er(1,0,1,1)],this._cubeDirections=[new ur(1,0,0),new ur(-1,0,0),new ur(0,0,1),new ur(0,0,-1),new ur(0,1,0),new ur(0,-1,0)],this._cubeUps=[new ur(0,1,0),new ur(0,1,0),new ur(0,1,0),new ur(0,1,0),new ur(0,0,1),new ur(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,r=this.matrix,s=t.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),Fh.setFromMatrixPosition(t.matrixWorld),n.position.copy(Fh),Ph.copy(n.position),Ph.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(Ph),n.updateMatrixWorld(),r.makeTranslation(-Fh.x,-Fh.y,-Fh.z),Lh.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Lh)}}$h.prototype.isPointLightShadow=!0;class Oh extends Eh{constructor(t,e,n=0,r=1){super(t,e),this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new $h}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}Oh.prototype.isPointLight=!0;class zh extends Rh{constructor(){super(new Wi(-5,5,5,-5,.5,500))}}zh.prototype.isDirectionalLightShadow=!0;class Bh extends Eh{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(hs.DefaultUp),this.updateMatrix(),this.target=new hs,this.shadow=new zh}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}Bh.prototype.isDirectionalLight=!0;class Uh extends Eh{constructor(t,e){super(t,e),this.type="AmbientLight"}}Uh.prototype.isAmbientLight=!0;class Wh extends Eh{constructor(t,e,n=10,r=10){super(t,e),this.type="RectAreaLight",this.width=n,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}Wh.prototype.isRectAreaLight=!0;class Vh{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new ur)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,r=t.y,s=t.z,i=this.coefficients;return e.copy(i[0]).multiplyScalar(.282095),e.addScaledVector(i[1],.488603*r),e.addScaledVector(i[2],.488603*s),e.addScaledVector(i[3],.488603*n),e.addScaledVector(i[4],n*r*1.092548),e.addScaledVector(i[5],r*s*1.092548),e.addScaledVector(i[6],.315392*(3*s*s-1)),e.addScaledVector(i[7],n*s*1.092548),e.addScaledVector(i[8],.546274*(n*n-r*r)),e}getIrradianceAt(t,e){const n=t.x,r=t.y,s=t.z,i=this.coefficients;return e.copy(i[0]).multiplyScalar(.886227),e.addScaledVector(i[1],1.023328*r),e.addScaledVector(i[2],1.023328*s),e.addScaledVector(i[3],1.023328*n),e.addScaledVector(i[4],.858086*n*r),e.addScaledVector(i[5],.858086*r*s),e.addScaledVector(i[6],.743125*s*s-.247708),e.addScaledVector(i[7],.858086*n*s),e.addScaledVector(i[8],.429043*(n*n-r*r)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(t,e+3*r);return this}toArray(t=[],e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(t,e+3*r);return t}static getBasisAt(t,e){const n=t.x,r=t.y,s=t.z;e[0]=.282095,e[1]=.488603*r,e[2]=.488603*s,e[3]=.488603*n,e[4]=1.092548*n*r,e[5]=1.092548*r*s,e[6]=.315392*(3*s*s-1),e[7]=1.092548*n*s,e[8]=.546274*(n*n-r*r)}}Vh.prototype.isSphericalHarmonics3=!0;class Gh extends Eh{constructor(t=new Vh,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}Gh.prototype.isLightProbe=!0;class Hh extends xh{constructor(t){super(t),this.textures={}}load(t,e,n,r){const s=this,i=new vh(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(t,(function(n){try{e(s.parse(JSON.parse(n)))}catch(e){r?r(e):console.error(e),s.manager.itemError(t)}}),n,r)}parse(t){const e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}const r=Ts.fromType(t.type);if(void 0!==t.uuid&&(r.uuid=t.uuid),void 0!==t.name&&(r.name=t.name),void 0!==t.color&&void 0!==r.color&&r.color.setHex(t.color),void 0!==t.roughness&&(r.roughness=t.roughness),void 0!==t.metalness&&(r.metalness=t.metalness),void 0!==t.sheen&&(r.sheen=t.sheen),void 0!==t.sheenColor&&(r.sheenColor=(new Xn).setHex(t.sheenColor)),void 0!==t.sheenRoughness&&(r.sheenRoughness=t.sheenRoughness),void 0!==t.emissive&&void 0!==r.emissive&&r.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==r.specular&&r.specular.setHex(t.specular),void 0!==t.specularIntensity&&(r.specularIntensity=t.specularIntensity),void 0!==t.specularColor&&void 0!==r.specularColor&&r.specularColor.setHex(t.specularColor),void 0!==t.shininess&&(r.shininess=t.shininess),void 0!==t.clearcoat&&(r.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(r.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.transmission&&(r.transmission=t.transmission),void 0!==t.thickness&&(r.thickness=t.thickness),void 0!==t.attenuationDistance&&(r.attenuationDistance=t.attenuationDistance),void 0!==t.attenuationColor&&void 0!==r.attenuationColor&&r.attenuationColor.setHex(t.attenuationColor),void 0!==t.fog&&(r.fog=t.fog),void 0!==t.flatShading&&(r.flatShading=t.flatShading),void 0!==t.blending&&(r.blending=t.blending),void 0!==t.combine&&(r.combine=t.combine),void 0!==t.side&&(r.side=t.side),void 0!==t.shadowSide&&(r.shadowSide=t.shadowSide),void 0!==t.opacity&&(r.opacity=t.opacity),void 0!==t.transparent&&(r.transparent=t.transparent),void 0!==t.alphaTest&&(r.alphaTest=t.alphaTest),void 0!==t.depthTest&&(r.depthTest=t.depthTest),void 0!==t.depthWrite&&(r.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(r.colorWrite=t.colorWrite),void 0!==t.stencilWrite&&(r.stencilWrite=t.stencilWrite),void 0!==t.stencilWriteMask&&(r.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(r.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(r.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(r.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(r.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(r.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(r.stencilZPass=t.stencilZPass),void 0!==t.wireframe&&(r.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(r.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(r.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(r.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(r.rotation=t.rotation),1!==t.linewidth&&(r.linewidth=t.linewidth),void 0!==t.dashSize&&(r.dashSize=t.dashSize),void 0!==t.gapSize&&(r.gapSize=t.gapSize),void 0!==t.scale&&(r.scale=t.scale),void 0!==t.polygonOffset&&(r.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(r.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(r.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.dithering&&(r.dithering=t.dithering),void 0!==t.alphaToCoverage&&(r.alphaToCoverage=t.alphaToCoverage),void 0!==t.premultipliedAlpha&&(r.premultipliedAlpha=t.premultipliedAlpha),void 0!==t.visible&&(r.visible=t.visible),void 0!==t.toneMapped&&(r.toneMapped=t.toneMapped),void 0!==t.userData&&(r.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?r.vertexColors=t.vertexColors>0:r.vertexColors=t.vertexColors),void 0!==t.uniforms)for(const e in t.uniforms){const s=t.uniforms[e];switch(r.uniforms[e]={},s.type){case"t":r.uniforms[e].value=n(s.value);break;case"c":r.uniforms[e].value=(new Xn).setHex(s.value);break;case"v2":r.uniforms[e].value=(new Nn).fromArray(s.value);break;case"v3":r.uniforms[e].value=(new ur).fromArray(s.value);break;case"v4":r.uniforms[e].value=(new er).fromArray(s.value);break;case"m3":r.uniforms[e].value=(new Dn).fromArray(s.value);break;case"m4":r.uniforms[e].value=(new Br).fromArray(s.value);break;default:r.uniforms[e].value=s.value}}if(void 0!==t.defines&&(r.defines=t.defines),void 0!==t.vertexShader&&(r.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(r.fragmentShader=t.fragmentShader),void 0!==t.extensions)for(const e in t.extensions)r.extensions[e]=t.extensions[e];if(void 0!==t.shading&&(r.flatShading=1===t.shading),void 0!==t.size&&(r.size=t.size),void 0!==t.sizeAttenuation&&(r.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(r.map=n(t.map)),void 0!==t.matcap&&(r.matcap=n(t.matcap)),void 0!==t.alphaMap&&(r.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(r.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(r.bumpScale=t.bumpScale),void 0!==t.normalMap&&(r.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(r.normalMapType=t.normalMapType),void 0!==t.normalScale){let e=t.normalScale;!1===Array.isArray(e)&&(e=[e,e]),r.normalScale=(new Nn).fromArray(e)}return void 0!==t.displacementMap&&(r.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(r.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(r.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(r.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(r.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(r.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(r.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(r.specularMap=n(t.specularMap)),void 0!==t.specularIntensityMap&&(r.specularIntensityMap=n(t.specularIntensityMap)),void 0!==t.specularColorMap&&(r.specularColorMap=n(t.specularColorMap)),void 0!==t.envMap&&(r.envMap=n(t.envMap)),void 0!==t.envMapIntensity&&(r.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(r.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(r.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(r.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(r.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(r.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(r.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(r.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(r.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(r.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(r.clearcoatNormalScale=(new Nn).fromArray(t.clearcoatNormalScale)),void 0!==t.transmissionMap&&(r.transmissionMap=n(t.transmissionMap)),void 0!==t.thicknessMap&&(r.thicknessMap=n(t.thicknessMap)),void 0!==t.sheenColorMap&&(r.sheenColorMap=n(t.sheenColorMap)),void 0!==t.sheenRoughnessMap&&(r.sheenRoughnessMap=n(t.sheenRoughnessMap)),r}setTextures(t){return this.textures=t,this}}class jh{static decodeText(t){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(t);let e="";for(let n=0,r=t.length;n<r;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch(t){return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return-1===e?"./":t.slice(0,e+1)}static resolveURL(t,e){return"string"!=typeof t||""===t?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class qh extends js{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}qh.prototype.isInstancedBufferGeometry=!0;class Xh extends xh{constructor(t){super(t)}load(t,e,n,r){const s=this,i=new vh(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(t,(function(n){try{e(s.parse(JSON.parse(n)))}catch(e){r?r(e):console.error(e),s.manager.itemError(t)}}),n,r)}parse(t){const e={},n={};function r(t,r){if(void 0!==e[r])return e[r];const s=t.interleavedBuffers[r],i=function(t,e){if(void 0!==n[e])return n[e];const r=t.arrayBuffers[e],s=new Uint32Array(r).buffer;return n[e]=s,s}(t,s.buffer),a=Pn(s.type,i),o=new pl(a,s.stride);return o.uuid=s.uuid,e[r]=o,o}const s=t.isInstancedBufferGeometry?new qh:new js,i=t.data.index;if(void 0!==i){const t=Pn(i.type,i.array);s.setIndex(new Is(t,1))}const a=t.data.attributes;for(const e in a){const n=a[e];let i;if(n.isInterleavedBufferAttribute){const e=r(t.data,n.data);i=new ml(e,n.itemSize,n.offset,n.normalized)}else{const t=Pn(n.type,n.array);i=new(n.isInstancedBufferAttribute?jl:Is)(t,n.itemSize,n.normalized)}void 0!==n.name&&(i.name=n.name),void 0!==n.usage&&i.setUsage(n.usage),void 0!==n.updateRange&&(i.updateRange.offset=n.updateRange.offset,i.updateRange.count=n.updateRange.count),s.setAttribute(e,i)}const o=t.data.morphAttributes;if(o)for(const e in o){const n=o[e],i=[];for(let e=0,s=n.length;e<s;e++){const s=n[e];let a;if(s.isInterleavedBufferAttribute){const e=r(t.data,s.data);a=new ml(e,s.itemSize,s.offset,s.normalized)}else{const t=Pn(s.type,s.array);a=new Is(t,s.itemSize,s.normalized)}void 0!==s.name&&(a.name=s.name),i.push(a)}s.morphAttributes[e]=i}t.data.morphTargetsRelative&&(s.morphTargetsRelative=!0);const l=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==l)for(let t=0,e=l.length;t!==e;++t){const e=l[t];s.addGroup(e.start,e.count,e.materialIndex)}const u=t.data.boundingSphere;if(void 0!==u){const t=new ur;void 0!==u.center&&t.fromArray(u.center),s.boundingSphere=new Rr(t,u.radius)}return t.name&&(s.name=t.name),t.userData&&(s.userData=t.userData),s}}class Kh extends xh{constructor(t){super(t)}load(t,e,n,r){const s=this,i=""===this.path?jh.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||i;const a=new vh(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,(function(n){let i=null;try{i=JSON.parse(n)}catch(e){return void 0!==r&&r(e),void console.error("THREE:ObjectLoader: Can't parse "+t+".",e.message)}const a=i.metadata;void 0!==a&&void 0!==a.type&&"geometry"!==a.type.toLowerCase()?s.parse(i,e):console.error("THREE.ObjectLoader: Can't load "+t)}),n,r)}async loadAsync(t,e){const n=""===this.path?jh.extractUrlBase(t):this.path;this.resourcePath=this.resourcePath||n;const r=new vh(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const s=await r.loadAsync(t,e),i=JSON.parse(s),a=i.metadata;if(void 0===a||void 0===a.type||"geometry"===a.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+t);return await this.parseAsync(i)}parse(t,e){const n=this.parseAnimations(t.animations),r=this.parseShapes(t.shapes),s=this.parseGeometries(t.geometries,r),i=this.parseImages(t.images,(function(){void 0!==e&&e(l)})),a=this.parseTextures(t.textures,i),o=this.parseMaterials(t.materials,a),l=this.parseObject(t.object,s,o,a,n),u=this.parseSkeletons(t.skeletons,l);if(this.bindSkeletons(l,u),void 0!==e){let t=!1;for(const e in i)if(i[e]instanceof HTMLImageElement){t=!0;break}!1===t&&e(l)}return l}async parseAsync(t){const e=this.parseAnimations(t.animations),n=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,n),s=await this.parseImagesAsync(t.images),i=this.parseTextures(t.textures,s),a=this.parseMaterials(t.materials,i),o=this.parseObject(t.object,r,a,i,e),l=this.parseSkeletons(t.skeletons,o);return this.bindSkeletons(o,l),o}parseShapes(t){const e={};if(void 0!==t)for(let n=0,r=t.length;n<r;n++){const r=(new tc).fromJSON(t[n]);e[r.uuid]=r}return e}parseSkeletons(t,e){const n={},r={};if(e.traverse((function(t){t.isBone&&(r[t.uuid]=t)})),void 0!==t)for(let e=0,s=t.length;e<s;e++){const s=(new Hl).fromJSON(t[e],r);n[s.uuid]=s}return n}parseGeometries(t,e){const n={};if(void 0!==t){const r=new Xh;for(let s=0,i=t.length;s<i;s++){let i;const a=t[s];switch(a.type){case"BufferGeometry":case"InstancedBufferGeometry":i=r.parse(a);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:a.type in Uc?i=Uc[a.type].fromJSON(a,e):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)}i.uuid=a.uuid,void 0!==a.name&&(i.name=a.name),!0===i.isBufferGeometry&&void 0!==a.userData&&(i.userData=a.userData),n[a.uuid]=i}}return n}parseMaterials(t,e){const n={},r={};if(void 0!==t){const s=new Hh;s.setTextures(e);for(let e=0,i=t.length;e<i;e++){const i=t[e];if("MultiMaterial"===i.type){const t=[];for(let e=0;e<i.materials.length;e++){const r=i.materials[e];void 0===n[r.uuid]&&(n[r.uuid]=s.parse(r)),t.push(n[r.uuid])}r[i.uuid]=t}else void 0===n[i.uuid]&&(n[i.uuid]=s.parse(i)),r[i.uuid]=n[i.uuid]}}return r}parseAnimations(t){const e={};if(void 0!==t)for(let n=0;n<t.length;n++){const r=t[n],s=dh.parse(r);e[s.uuid]=s}return e}parseImages(t,e){const n=this,r={};let s;function i(t){if("string"==typeof t){const e=t;return function(t){return n.manager.itemStart(t),s.load(t,(function(){n.manager.itemEnd(t)}),void 0,(function(){n.manager.itemError(t),n.manager.itemEnd(t)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:n.resourcePath+e)}return t.data?{data:Pn(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){const n=new mh(e);s=new Sh(n),s.setCrossOrigin(this.crossOrigin);for(let e=0,n=t.length;e<n;e++){const n=t[e],s=n.url;if(Array.isArray(s)){const t=[];for(let e=0,n=s.length;e<n;e++){const n=i(s[e]);null!==n&&(n instanceof HTMLImageElement?t.push(n):t.push(new Wl(n.data,n.width,n.height)))}r[n.uuid]=new Jn(t)}else{const t=i(n.url);r[n.uuid]=new Jn(t)}}}return r}async parseImagesAsync(t){const e=this,n={};let r;async function s(t){if("string"==typeof t){const n=t,s=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(n)?n:e.resourcePath+n;return await r.loadAsync(s)}return t.data?{data:Pn(t.type,t.data),width:t.width,height:t.height}:null}if(void 0!==t&&t.length>0){r=new Sh(this.manager),r.setCrossOrigin(this.crossOrigin);for(let e=0,r=t.length;e<r;e++){const r=t[e],i=r.url;if(Array.isArray(i)){const t=[];for(let e=0,n=i.length;e<n;e++){const n=i[e],r=await s(n);null!==r&&(r instanceof HTMLImageElement?t.push(r):t.push(new Wl(r.data,r.width,r.height)))}n[r.uuid]=new Jn(t)}else{const t=await s(r.url);n[r.uuid]=new Jn(t)}}}return n}parseTextures(t,e){function n(t,e){return"number"==typeof t?t:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",t),e[t])}const r={};if(void 0!==t)for(let s=0,i=t.length;s<i;s++){const i=t[s];void 0===i.image&&console.warn('THREE.ObjectLoader: No "image" specified for',i.uuid),void 0===e[i.image]&&console.warn("THREE.ObjectLoader: Undefined image",i.image);const a=e[i.image],o=a.data;let l;Array.isArray(o)?(l=new wi,6===o.length&&(l.needsUpdate=!0)):(l=o&&o.data?new Wl:new tr,o&&(l.needsUpdate=!0)),l.source=a,l.uuid=i.uuid,void 0!==i.name&&(l.name=i.name),void 0!==i.mapping&&(l.mapping=n(i.mapping,Yh)),void 0!==i.offset&&l.offset.fromArray(i.offset),void 0!==i.repeat&&l.repeat.fromArray(i.repeat),void 0!==i.center&&l.center.fromArray(i.center),void 0!==i.rotation&&(l.rotation=i.rotation),void 0!==i.wrap&&(l.wrapS=n(i.wrap[0],Jh),l.wrapT=n(i.wrap[1],Jh)),void 0!==i.format&&(l.format=i.format),void 0!==i.type&&(l.type=i.type),void 0!==i.encoding&&(l.encoding=i.encoding),void 0!==i.minFilter&&(l.minFilter=n(i.minFilter,Zh)),void 0!==i.magFilter&&(l.magFilter=n(i.magFilter,Zh)),void 0!==i.anisotropy&&(l.anisotropy=i.anisotropy),void 0!==i.flipY&&(l.flipY=i.flipY),void 0!==i.premultiplyAlpha&&(l.premultiplyAlpha=i.premultiplyAlpha),void 0!==i.unpackAlignment&&(l.unpackAlignment=i.unpackAlignment),void 0!==i.userData&&(l.userData=i.userData),r[i.uuid]=l}return r}parseObject(t,e,n,r,s){let i,a,o;function l(t){return void 0===e[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),e[t]}function u(t){if(void 0!==t){if(Array.isArray(t)){const e=[];for(let r=0,s=t.length;r<s;r++){const s=t[r];void 0===n[s]&&console.warn("THREE.ObjectLoader: Undefined material",s),e.push(n[s])}return e}return void 0===n[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),n[t]}}function c(t){return void 0===r[t]&&console.warn("THREE.ObjectLoader: Undefined texture",t),r[t]}switch(t.type){case"Scene":i=new dl,void 0!==t.background&&(Number.isInteger(t.background)?i.background=new Xn(t.background):i.background=c(t.background)),void 0!==t.environment&&(i.environment=c(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?i.fog=new hl(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(i.fog=new cl(t.fog.color,t.fog.density)));break;case"PerspectiveCamera":i=new yi(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(i.focus=t.focus),void 0!==t.zoom&&(i.zoom=t.zoom),void 0!==t.filmGauge&&(i.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(i.filmOffset=t.filmOffset),void 0!==t.view&&(i.view=Object.assign({},t.view));break;case"OrthographicCamera":i=new Wi(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(i.zoom=t.zoom),void 0!==t.view&&(i.view=Object.assign({},t.view));break;case"AmbientLight":i=new Uh(t.color,t.intensity);break;case"DirectionalLight":i=new Bh(t.color,t.intensity);break;case"PointLight":i=new Oh(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":i=new Wh(t.color,t.intensity,t.width,t.height);break;case"SpotLight":i=new Dh(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":i=new kh(t.color,t.groundColor,t.intensity);break;case"LightProbe":i=(new Gh).fromJSON(t);break;case"SkinnedMesh":a=l(t.geometry),o=u(t.material),i=new Bl(a,o),void 0!==t.bindMode&&(i.bindMode=t.bindMode),void 0!==t.bindMatrix&&i.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(i.skeleton=t.skeleton);break;case"Mesh":a=l(t.geometry),o=u(t.material),i=new ci(a,o);break;case"InstancedMesh":a=l(t.geometry),o=u(t.material);const e=t.count,n=t.instanceMatrix,r=t.instanceColor;i=new Jl(a,o,e),i.instanceMatrix=new jl(new Float32Array(n.array),16),void 0!==r&&(i.instanceColor=new jl(new Float32Array(r.array),r.itemSize));break;case"LOD":i=new Ll;break;case"Line":i=new su(l(t.geometry),u(t.material));break;case"LineLoop":i=new lu(l(t.geometry),u(t.material));break;case"LineSegments":i=new ou(l(t.geometry),u(t.material));break;case"PointCloud":case"Points":i=new fu(l(t.geometry),u(t.material));break;case"Sprite":i=new Al(u(t.material));break;case"Group":i=new nl;break;case"Bone":i=new Ul;break;default:i=new hs}if(i.uuid=t.uuid,void 0!==t.name&&(i.name=t.name),void 0!==t.matrix?(i.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(i.matrixAutoUpdate=t.matrixAutoUpdate),i.matrixAutoUpdate&&i.matrix.decompose(i.position,i.quaternion,i.scale)):(void 0!==t.position&&i.position.fromArray(t.position),void 0!==t.rotation&&i.rotation.fromArray(t.rotation),void 0!==t.quaternion&&i.quaternion.fromArray(t.quaternion),void 0!==t.scale&&i.scale.fromArray(t.scale)),void 0!==t.castShadow&&(i.castShadow=t.castShadow),void 0!==t.receiveShadow&&(i.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(i.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(i.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(i.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&i.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(i.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(i.visible=t.visible),void 0!==t.frustumCulled&&(i.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(i.renderOrder=t.renderOrder),void 0!==t.userData&&(i.userData=t.userData),void 0!==t.layers&&(i.layers.mask=t.layers),void 0!==t.children){const a=t.children;for(let t=0;t<a.length;t++)i.add(this.parseObject(a[t],e,n,r,s))}if(void 0!==t.animations){const e=t.animations;for(let t=0;t<e.length;t++){const n=e[t];i.animations.push(s[n])}}if("LOD"===t.type){void 0!==t.autoUpdate&&(i.autoUpdate=t.autoUpdate);const e=t.levels;for(let t=0;t<e.length;t++){const n=e[t],r=i.getObjectByProperty("uuid",n.object);void 0!==r&&i.addLevel(r,n.distance)}}return i}bindSkeletons(t,e){0!==Object.keys(e).length&&t.traverse((function(t){if(!0===t.isSkinnedMesh&&void 0!==t.skeleton){const n=e[t.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",t.skeleton):t.bind(n,t.bindMatrix)}}))}setTexturePath(t){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(t)}}const Yh={UVMapping:ot,CubeReflectionMapping:lt,CubeRefractionMapping:ut,EquirectangularReflectionMapping:ct,EquirectangularRefractionMapping:ht,CubeUVReflectionMapping:dt},Jh={RepeatWrapping:pt,ClampToEdgeWrapping:ft,MirroredRepeatWrapping:mt},Zh={NearestFilter:gt,NearestMipmapNearestFilter:xt,NearestMipmapLinearFilter:vt,LinearFilter:wt,LinearMipmapNearestFilter:St,LinearMipmapLinearFilter:Tt};class Qh extends xh{constructor(t){super(t),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,r){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,i=fh.get(t);if(void 0!==i)return s.manager.itemStart(t),setTimeout((function(){e&&e(i),s.manager.itemEnd(t)}),0),i;const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",a.headers=this.requestHeader,fetch(t,a).then((function(t){return t.blob()})).then((function(t){return createImageBitmap(t,Object.assign(s.options,{colorSpaceConversion:"none"}))})).then((function(n){fh.add(t,n),e&&e(n),s.manager.itemEnd(t)})).catch((function(e){r&&r(e),s.manager.itemError(t),s.manager.itemEnd(t)})),s.manager.itemStart(t)}}let td;Qh.prototype.isImageBitmapLoader=!0;const ed={getContext:function(){return void 0===td&&(td=new(window.AudioContext||window.webkitAudioContext)),td},setContext:function(t){td=t}};class nd extends xh{constructor(t){super(t)}load(t,e,n,r){const s=this,i=new vh(this.manager);i.setResponseType("arraybuffer"),i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,(function(n){try{const t=n.slice(0);ed.getContext().decodeAudioData(t,(function(t){e(t)}))}catch(e){r?r(e):console.error(e),s.manager.itemError(t)}}),n,r)}}class rd extends Gh{constructor(t,e,n=1){super(void 0,n);const r=(new Xn).set(t),s=(new Xn).set(e),i=new ur(r.r,r.g,r.b),a=new ur(s.r,s.g,s.b),o=Math.sqrt(Math.PI),l=o*Math.sqrt(.75);this.sh.coefficients[0].copy(i).add(a).multiplyScalar(o),this.sh.coefficients[1].copy(i).sub(a).multiplyScalar(l)}}rd.prototype.isHemisphereLightProbe=!0;class sd extends Gh{constructor(t,e=1){super(void 0,e);const n=(new Xn).set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}sd.prototype.isAmbientLightProbe=!0;const id=new Br,ad=new Br,od=new Br;class ld{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new yi,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new yi,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(t){const e=this._cache;if(e.focus!==t.focus||e.fov!==t.fov||e.aspect!==t.aspect*this.aspect||e.near!==t.near||e.far!==t.far||e.zoom!==t.zoom||e.eyeSep!==this.eyeSep){e.focus=t.focus,e.fov=t.fov,e.aspect=t.aspect*this.aspect,e.near=t.near,e.far=t.far,e.zoom=t.zoom,e.eyeSep=this.eyeSep,od.copy(t.projectionMatrix);const n=e.eyeSep/2,r=n*e.near/e.focus,s=e.near*Math.tan(Sn*e.fov*.5)/e.zoom;let i,a;ad.elements[12]=-n,id.elements[12]=n,i=-s*e.aspect+r,a=s*e.aspect+r,od.elements[0]=2*e.near/(a-i),od.elements[8]=(a+i)/(a-i),this.cameraL.projectionMatrix.copy(od),i=-s*e.aspect-r,a=s*e.aspect-r,od.elements[0]=2*e.near/(a-i),od.elements[8]=(a+i)/(a-i),this.cameraR.projectionMatrix.copy(od)}this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(ad),this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(id)}}class ud{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=cd(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=cd();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function cd(){return("undefined"==typeof performance?Date:performance).now()}const hd=new ur,dd=new lr,pd=new ur,fd=new ur;class md extends hs{constructor(){super(),this.type="AudioListener",this.context=ed.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new ud}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(t){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=t,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}updateMatrixWorld(t){super.updateMatrixWorld(t);const e=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(hd,dd,pd),fd.set(0,0,-1).applyQuaternion(dd),e.positionX){const t=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(hd.x,t),e.positionY.linearRampToValueAtTime(hd.y,t),e.positionZ.linearRampToValueAtTime(hd.z,t),e.forwardX.linearRampToValueAtTime(fd.x,t),e.forwardY.linearRampToValueAtTime(fd.y,t),e.forwardZ.linearRampToValueAtTime(fd.z,t),e.upX.linearRampToValueAtTime(n.x,t),e.upY.linearRampToValueAtTime(n.y,t),e.upZ.linearRampToValueAtTime(n.z,t)}else e.setPosition(hd.x,hd.y,hd.z),e.setOrientation(fd.x,fd.y,fd.z,n.x,n.y,n.z)}}class gd extends hs{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),!0===this._connected?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(!1!==this.hasPlaybackControl)return this.playbackRate=t,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(!1!==this.hasPlaybackControl)return this.loop=t,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}const xd=new ur,yd=new lr,vd=new ur,bd=new ur;class wd extends gd{constructor(t){super(t),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(t){return this.panner.refDistance=t,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(t){return this.panner.rolloffFactor=t,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(t){return this.panner.distanceModel=t,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(t){return this.panner.maxDistance=t,this}setDirectionalCone(t,e,n){return this.panner.coneInnerAngle=t,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=n,this}updateMatrixWorld(t){if(super.updateMatrixWorld(t),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(xd,yd,vd),bd.set(0,0,1).applyQuaternion(yd);const e=this.panner;if(e.positionX){const t=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(xd.x,t),e.positionY.linearRampToValueAtTime(xd.y,t),e.positionZ.linearRampToValueAtTime(xd.z,t),e.orientationX.linearRampToValueAtTime(bd.x,t),e.orientationY.linearRampToValueAtTime(bd.y,t),e.orientationZ.linearRampToValueAtTime(bd.z,t)}else e.setPosition(xd.x,xd.y,xd.z),e.setOrientation(bd.x,bd.y,bd.z)}}class Sd{constructor(t,e=2048){this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let t=0;const e=this.getFrequencyData();for(let n=0;n<e.length;n++)t+=e[n];return t/e.length}}class _d{constructor(t,e,n){let r,s,i;switch(this.binding=t,this.valueSize=n,e){case"quaternion":r=this._slerp,s=this._slerpAdditive,i=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,i=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:r=this._lerp,s=this._lerpAdditive,i=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=i,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,r=this.valueSize,s=t*r+r;let i=this.cumulativeWeight;if(0===i){for(let t=0;t!==r;++t)n[s+t]=n[t];i=e}else{i+=e;const t=e/i;this._mixBufferRegion(n,s,0,t,r)}this.cumulativeWeight=i}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,r=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,r=t*e+e,s=this.cumulativeWeight,i=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const t=e*this._origIndex;this._mixBufferRegion(n,r,t,1-s,e)}i>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*e,1,e);for(let t=e,s=e+e;t!==s;++t)if(n[t]!==n[t+e]){a.setValue(n,r);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,r=n*this._origIndex;t.getValue(e,r);for(let t=n,s=r;t!==s;++t)e[t]=e[r+t%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=3*this.valueSize;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,r,s){if(r>=.5)for(let r=0;r!==s;++r)t[e+r]=t[n+r]}_slerp(t,e,n,r){lr.slerpFlat(t,e,t,e,t,n,r)}_slerpAdditive(t,e,n,r,s){const i=this._workIndex*s;lr.multiplyQuaternionsFlat(t,i,t,e,t,n),lr.slerpFlat(t,e,t,e,t,i,r)}_lerp(t,e,n,r,s){const i=1-r;for(let a=0;a!==s;++a){const s=e+a;t[s]=t[s]*i+t[n+a]*r}}_lerpAdditive(t,e,n,r,s){for(let i=0;i!==s;++i){const s=e+i;t[s]=t[s]+t[n+i]*r}}}const Td=new RegExp("[\\[\\]\\.:\\/]","g"),Md="[^\\[\\]\\.:\\/]",Ed="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",kd=/((?:WC+[\/:])*)/.source.replace("WC",Md),Id=/(WCOD+)?/.source.replace("WCOD",Ed),Cd=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Md),Ad=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Md),Rd=new RegExp("^"+kd+Id+Cd+Ad+"$"),Nd=["material","materials","bones"];class Dd{constructor(t,e,n){this.path=e,this.parsedPath=n||Dd.parseTrackName(e),this.node=Dd.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new Dd.Composite(t,e,n):new Dd(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Td,"")}static parseTrackName(t){const e=Rd.exec(t);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){const t=n.nodeName.substring(r+1);-1!==Nd.indexOf(t)&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=t)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(void 0===e||""===e||"."===e||-1===e||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(void 0!==n)return n}if(t.children){const n=function(t){for(let r=0;r<t.length;r++){const s=t[r];if(s.name===e||s.uuid===e)return s;const i=n(s.children);if(i)return i}return null},r=n(t.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)t[e++]=n[r]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,r=e.propertyName;let s=e.propertyIndex;if(t||(t=Dd.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let r=e.objectIndex;switch(n){case"materials":if(!t.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!t.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);t=t.material.materials;break;case"bones":if(!t.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);t=t.skeleton.bones;for(let e=0;e<t.length;e++)if(t[e].name===r){r=e;break}break;default:if(void 0===t[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);t=t[n]}if(void 0!==r){if(void 0===t[r])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);t=t[r]}}const i=t[r];if(void 0===i){const n=e.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+r+" but it wasn't found.",t)}let a=this.Versioning.None;this.targetObject=t,void 0!==t.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==t.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==s){if("morphTargetInfluences"===r){if(!t.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!t.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!t.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==t.morphTargetDictionary[s]&&(s=t.morphTargetDictionary[s])}o=this.BindingType.ArrayElement,this.resolvedProperty=i,this.propertyIndex=s}else void 0!==i.fromArray&&void 0!==i.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=i):Array.isArray(i)?(o=this.BindingType.EntireArray,this.resolvedProperty=i):this.propertyName=r;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Dd.Composite=class{constructor(t,e,n){const r=n||Dd.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,r)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];void 0!==r&&r.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=n.length;r!==s;++r)n[r].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}},Dd.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Dd.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Dd.prototype.GetterByBindingType=[Dd.prototype._getValue_direct,Dd.prototype._getValue_array,Dd.prototype._getValue_arrayElement,Dd.prototype._getValue_toArray],Dd.prototype.SetterByBindingTypeAndVersioning=[[Dd.prototype._setValue_direct,Dd.prototype._setValue_direct_setNeedsUpdate,Dd.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Dd.prototype._setValue_array,Dd.prototype._setValue_array_setNeedsUpdate,Dd.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Dd.prototype._setValue_arrayElement,Dd.prototype._setValue_arrayElement_setNeedsUpdate,Dd.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Dd.prototype._setValue_fromArray,Dd.prototype._setValue_fromArray_setNeedsUpdate,Dd.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Ld{constructor(){this.uuid=Tn(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const t={};this._indicesByUUID=t;for(let e=0,n=arguments.length;e!==n;++e)t[arguments[e].uuid]=e;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}add(){const t=this._objects,e=this._indicesByUUID,n=this._paths,r=this._parsedPaths,s=this._bindings,i=s.length;let a,o=t.length,l=this.nCachedObjects_;for(let u=0,c=arguments.length;u!==c;++u){const c=arguments[u],h=c.uuid;let d=e[h];if(void 0===d){d=o++,e[h]=d,t.push(c);for(let t=0,e=i;t!==e;++t)s[t].push(new Dd(c,n[t],r[t]))}else if(d<l){a=t[d];const o=--l,u=t[o];e[u.uuid]=d,t[d]=u,e[h]=o,t[o]=c;for(let t=0,e=i;t!==e;++t){const e=s[t],i=e[o];let a=e[d];e[d]=i,void 0===a&&(a=new Dd(c,n[t],r[t])),e[o]=a}}else t[d]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,r=n.length;let s=this.nCachedObjects_;for(let i=0,a=arguments.length;i!==a;++i){const a=arguments[i],o=a.uuid,l=e[o];if(void 0!==l&&l>=s){const i=s++,u=t[i];e[u.uuid]=l,t[l]=u,e[o]=i,t[i]=a;for(let t=0,e=r;t!==e;++t){const e=n[t],r=e[i],s=e[l];e[l]=r,e[i]=s}}}this.nCachedObjects_=s}uncache(){const t=this._objects,e=this._indicesByUUID,n=this._bindings,r=n.length;let s=this.nCachedObjects_,i=t.length;for(let a=0,o=arguments.length;a!==o;++a){const o=arguments[a].uuid,l=e[o];if(void 0!==l)if(delete e[o],l<s){const a=--s,o=t[a],u=--i,c=t[u];e[o.uuid]=l,t[l]=o,e[c.uuid]=a,t[a]=c,t.pop();for(let t=0,e=r;t!==e;++t){const e=n[t],r=e[a],s=e[u];e[l]=r,e[a]=s,e.pop()}}else{const s=--i,a=t[s];s>0&&(e[a.uuid]=l),t[l]=a,t.pop();for(let t=0,e=r;t!==e;++t){const e=n[t];e[l]=e[s],e.pop()}}}this.nCachedObjects_=s}subscribe_(t,e){const n=this._bindingsIndicesByPath;let r=n[t];const s=this._bindings;if(void 0!==r)return s[r];const i=this._paths,a=this._parsedPaths,o=this._objects,l=o.length,u=this.nCachedObjects_,c=new Array(l);r=s.length,n[t]=r,i.push(t),a.push(e),s.push(c);for(let n=u,r=o.length;n!==r;++n){const r=o[n];c[n]=new Dd(r,t,e)}return c}unsubscribe_(t){const e=this._bindingsIndicesByPath,n=e[t];if(void 0!==n){const r=this._paths,s=this._parsedPaths,i=this._bindings,a=i.length-1,o=i[a];e[t[a]]=n,i[n]=o,i.pop(),s[n]=s[a],s.pop(),r[n]=r[a],r.pop()}}}Ld.prototype.isAnimationObjectGroup=!0;class Fd{constructor(t,e,n=null,r=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=r;const s=e.tracks,i=s.length,a=new Array(i),o={endingStart:ke,endingEnd:ke};for(let t=0;t!==i;++t){const e=s[t].createInterpolant(null);a[t]=e,e.settings=o}this._interpolantSettings=o,this._interpolants=a,this._propertyBindings=new Array(i),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Se,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const n=this._clip.duration,r=t._clip.duration,s=r/n,i=n/r;t.warp(1,s,e),this.warp(i,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const r=this._mixer,s=r.time,i=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=s,o[1]=s+n,l[0]=t/i,l[1]=e/i,this}stopWarping(){const t=this._timeScaleInterpolant;return null!==t&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,r){if(!this.enabled)return void this._updateWeight(t);const s=this._startTime;if(null!==s){const r=(t-s)*n;if(r<0||0===n)return;this._startTime=null,e=n*r}e*=this._updateTimeScale(t);const i=this._updateTime(e),a=this._updateWeight(t);if(a>0){const t=this._interpolants,e=this._propertyBindings;if(this.blendMode===Re)for(let n=0,r=t.length;n!==r;++n)t[n].evaluate(i),e[n].accumulateAdditive(a);else for(let n=0,s=t.length;n!==s;++n)t[n].evaluate(i),e[n].accumulate(r,a)}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(null!==n){const r=n.evaluate(t)[0];e*=r,t>n.parameterPositions[1]&&(this.stopFading(),0===r&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let r=this.time+t,s=this._loopCount;const i=n===_e;if(0===t)return-1===s?r:i&&1==(1&s)?e-r:r;if(n===we){-1===s&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(r>=e)r=e;else{if(!(r<0)){this.time=r;break t}r=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(-1===s&&(t>=0?(s=0,this._setEndings(!0,0===this.repetitions,i)):this._setEndings(0===this.repetitions,!0,i)),r>=e||r<0){const n=Math.floor(r/e);r-=e*n,s+=Math.abs(n);const a=this.repetitions-s;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?e:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(1===a){const e=t<0;this._setEndings(e,!e,i)}else this._setEndings(!1,!1,i);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=r;if(i&&1==(1&s))return e-r}return r}_setEndings(t,e,n){const r=this._interpolantSettings;n?(r.endingStart=Ie,r.endingEnd=Ie):(r.endingStart=t?this.zeroSlopeAtStart?Ie:ke:Ce,r.endingEnd=e?this.zeroSlopeAtEnd?Ie:ke:Ce)}_scheduleFading(t,e,n){const r=this._mixer,s=r.time;let i=this._weightInterpolant;null===i&&(i=r._lendControlInterpolant(),this._weightInterpolant=i);const a=i.parameterPositions,o=i.sampleValues;return a[0]=s,o[0]=e,a[1]=s+t,o[1]=n,this}}class Pd extends vn{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,r=t._clip.tracks,s=r.length,i=t._propertyBindings,a=t._interpolants,o=n.uuid,l=this._bindingsByRootAndName;let u=l[o];void 0===u&&(u={},l[o]=u);for(let t=0;t!==s;++t){const s=r[t],l=s.name;let c=u[l];if(void 0!==c)++c.referenceCount,i[t]=c;else{if(c=i[t],void 0!==c){null===c._cacheIndex&&(++c.referenceCount,this._addInactiveBinding(c,o,l));continue}const r=e&&e._propertyBindings[t].binding.parsedPath;c=new _d(Dd.create(n,l,r),s.ValueTypeName,s.getValueSize()),++c.referenceCount,this._addInactiveBinding(c,o,l),i[t]=c}a[t].resultBuffer=c.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(null===t._cacheIndex){const e=(t._localRoot||this._root).uuid,n=t._clip.uuid,r=this._actionsByClip[n];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,n,e)}const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return null!==e&&e<this._nActiveActions}_addInactiveAction(t,e,n){const r=this._actions,s=this._actionsByClip;let i=s[e];if(void 0===i)i={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,s[e]=i;else{const e=i.knownActions;t._byClipCacheIndex=e.length,e.push(t)}t._cacheIndex=r.length,r.push(t),i.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],r=t._cacheIndex;n._cacheIndex=r,e[r]=n,e.pop(),t._cacheIndex=null;const s=t._clip.uuid,i=this._actionsByClip,a=i[s],o=a.knownActions,l=o[o.length-1],u=t._byClipCacheIndex;l._byClipCacheIndex=u,o[u]=l,o.pop(),t._byClipCacheIndex=null,delete a.actionByRoot[(t._localRoot||this._root).uuid],0===o.length&&delete i[s],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let t=0,n=e.length;t!==n;++t){const n=e[t];0==--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,r=this._nActiveActions++,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,r=--this._nActiveActions,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_addInactiveBinding(t,e,n){const r=this._bindingsByRootAndName,s=this._bindings;let i=r[e];void 0===i&&(i={},r[e]=i),i[n]=t,t._cacheIndex=s.length,s.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,r=n.rootNode.uuid,s=n.path,i=this._bindingsByRootAndName,a=i[r],o=e[e.length-1],l=t._cacheIndex;o._cacheIndex=l,e[l]=o,e.pop(),delete a[s],0===Object.keys(a).length&&delete i[r]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,r=this._nActiveBindings++,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,r=--this._nActiveBindings,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return void 0===n&&(n=new nh(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,r=--this._nActiveControlInterpolants,s=e[r];t.__cacheIndex=r,e[r]=t,s.__cacheIndex=n,e[n]=s}clipAction(t,e,n){const r=e||this._root,s=r.uuid;let i="string"==typeof t?dh.findByName(r,t):t;const a=null!==i?i.uuid:t,o=this._actionsByClip[a];let l=null;if(void 0===n&&(n=null!==i?i.blendMode:Ae),void 0!==o){const t=o.actionByRoot[s];if(void 0!==t&&t.blendMode===n)return t;l=o.knownActions[0],null===i&&(i=l._clip)}if(null===i)return null;const u=new Fd(this,i,e,n);return this._bindAction(u,l),this._addInactiveAction(u,a,s),u}existingAction(t,e){const n=e||this._root,r=n.uuid,s="string"==typeof t?dh.findByName(n,t):t,i=s?s.uuid:t,a=this._actionsByClip[i];return void 0!==a&&a.actionByRoot[r]||null}stopAllAction(){const t=this._actions;for(let e=this._nActiveActions-1;e>=0;--e)t[e].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,r=this.time+=t,s=Math.sign(t),i=this._accuIndex^=1;for(let a=0;a!==n;++a)e[a]._update(r,t,s,i);const a=this._bindings,o=this._nActiveBindings;for(let t=0;t!==o;++t)a[t].apply(i);return this}setTime(t){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,r=this._actionsByClip,s=r[n];if(void 0!==s){const t=s.knownActions;for(let n=0,r=t.length;n!==r;++n){const r=t[n];this._deactivateAction(r);const s=r._cacheIndex,i=e[e.length-1];r._cacheIndex=null,r._byClipCacheIndex=null,i._cacheIndex=s,e[s]=i,e.pop(),this._removeInactiveBindingsForAction(r)}delete r[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const t in n){const r=n[t].actionByRoot[e];void 0!==r&&(this._deactivateAction(r),this._removeInactiveAction(r))}const r=this._bindingsByRootAndName[e];if(void 0!==r)for(const t in r){const e=r[t];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(t,e){const n=this.existingAction(t,e);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}Pd.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class $d{constructor(t){"string"==typeof t&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),t=arguments[1]),this.value=t}clone(){return new $d(void 0===this.value.clone?this.value:this.value.clone())}}class Od extends pl{constructor(t,e,n=1){super(t,e),this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}Od.prototype.isInstancedInterleavedBuffer=!0;class zd{constructor(t,e,n,r,s){this.buffer=t,this.type=e,this.itemSize=n,this.elementSize=r,this.count=s,this.version=0}set needsUpdate(t){!0===t&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}zd.prototype.isGLBufferAttribute=!0;class Bd{constructor(t,e,n=0,r=1/0){this.ray=new zr(t,e),this.near=n,this.far=r,this.camera=null,this.layers=new Jr,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}intersectObject(t,e=!0,n=[]){return Wd(t,this,n,e),n.sort(Ud),n}intersectObjects(t,e=!0,n=[]){for(let r=0,s=t.length;r<s;r++)Wd(t[r],this,n,e);return n.sort(Ud),n}}function Ud(t,e){return t.distance-e.distance}function Wd(t,e,n,r){if(t.layers.test(e.layers)&&t.raycast(e,n),!0===r){const r=t.children;for(let t=0,s=r.length;t<s;t++)Wd(r[t],e,n,!0)}}class Vd{constructor(t=1,e=0,n=0){return this.radius=t,this.phi=e,this.theta=n,this}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}makeSafe(){const t=1e-6;return this.phi=Math.max(t,Math.min(Math.PI-t,this.phi)),this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+e*e+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,n),this.phi=Math.acos(Mn(e/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class Gd{constructor(t=1,e=0,n=0){return this.radius=t,this.theta=e,this.y=n,this}set(t,e,n){return this.radius=t,this.theta=e,this.y=n,this}copy(t){return this.radius=t.radius,this.theta=t.theta,this.y=t.y,this}setFromVector3(t){return this.setFromCartesianCoords(t.x,t.y,t.z)}setFromCartesianCoords(t,e,n){return this.radius=Math.sqrt(t*t+n*n),this.theta=Math.atan2(t,n),this.y=e,this}clone(){return(new this.constructor).copy(this)}}const Hd=new Nn;class jd{constructor(t=new Nn(1/0,1/0),e=new Nn(-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Hd.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Hd.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}jd.prototype.isBox2=!0;const qd=new ur,Xd=new ur;class Kd{constructor(t=new ur,e=new ur){this.start=t,this.end=e}set(t,e){return this.start.copy(t),this.end.copy(e),this}copy(t){return this.start.copy(t.start),this.end.copy(t.end),this}getCenter(t){return t.addVectors(this.start,this.end).multiplyScalar(.5)}delta(t){return t.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,e){return this.delta(e).multiplyScalar(t).add(this.start)}closestPointToPointParameter(t,e){qd.subVectors(t,this.start),Xd.subVectors(this.end,this.start);const n=Xd.dot(Xd);let r=Xd.dot(qd)/n;return e&&(r=Mn(r,0,1)),r}closestPointToPoint(t,e,n){const r=this.closestPointToPointParameter(t,e);return this.delta(n).multiplyScalar(r).add(this.start)}applyMatrix4(t){return this.start.applyMatrix4(t),this.end.applyMatrix4(t),this}equals(t){return t.start.equals(this.start)&&t.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const Yd=new ur;class Jd extends hs{constructor(t,e){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=e;const n=new js,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let t=0,e=1,n=32;t<n;t++,e++){const s=t/n*Math.PI*2,i=e/n*Math.PI*2;r.push(Math.cos(s),Math.sin(s),1,Math.cos(i),Math.sin(i),1)}n.setAttribute("position",new $s(r,3));const s=new Zl({fog:!1,toneMapped:!1});this.cone=new ou(n,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const t=this.light.distance?this.light.distance:1e3,e=t*Math.tan(this.light.angle);this.cone.scale.set(e,e,t),Yd.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Yd),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Zd=new ur,Qd=new Br,tp=new Br;class ep extends ou{constructor(t){const e=np(t),n=new js,r=[],s=[],i=new Xn(0,0,1),a=new Xn(0,1,0);for(let t=0;t<e.length;t++){const n=e[t];n.parent&&n.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(i.r,i.g,i.b),s.push(a.r,a.g,a.b))}n.setAttribute("position",new $s(r,3)),n.setAttribute("color",new $s(s,3)),super(n,new Zl({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,r=n.getAttribute("position");tp.copy(this.root.matrixWorld).invert();for(let t=0,n=0;t<e.length;t++){const s=e[t];s.parent&&s.parent.isBone&&(Qd.multiplyMatrices(tp,s.matrixWorld),Zd.setFromMatrixPosition(Qd),r.setXYZ(n,Zd.x,Zd.y,Zd.z),Qd.multiplyMatrices(tp,s.parent.matrixWorld),Zd.setFromMatrixPosition(Qd),r.setXYZ(n+1,Zd.x,Zd.y,Zd.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function np(t){const e=[];!0===t.isBone&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,np(t.children[n]));return e}class rp extends ci{constructor(t,e,n){super(new Lc(e,4,2),new Ms({wireframe:!0,fog:!1,toneMapped:!1})),this.light=t,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const sp=new ur,ip=new Xn,ap=new Xn;class op extends hs{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const r=new Rc(e);r.rotateY(.5*Math.PI),this.material=new Ms({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const s=r.getAttribute("position"),i=new Float32Array(3*s.count);r.setAttribute("color",new Is(i,3)),this.add(new ci(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const t=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const e=t.geometry.getAttribute("color");ip.copy(this.light.color),ap.copy(this.light.groundColor);for(let t=0,n=e.count;t<n;t++){const r=t<n/2?ip:ap;e.setXYZ(t,r.r,r.g,r.b)}e.needsUpdate=!0}t.lookAt(sp.setFromMatrixPosition(this.light.matrixWorld).negate())}}class lp extends ou{constructor(t=10,e=10,n=4473924,r=8947848){n=new Xn(n),r=new Xn(r);const s=e/2,i=t/e,a=t/2,o=[],l=[];for(let t=0,u=0,c=-a;t<=e;t++,c+=i){o.push(-a,0,c,a,0,c),o.push(c,0,-a,c,0,a);const e=t===s?n:r;e.toArray(l,u),u+=3,e.toArray(l,u),u+=3,e.toArray(l,u),u+=3,e.toArray(l,u),u+=3}const u=new js;u.setAttribute("position",new $s(o,3)),u.setAttribute("color",new $s(l,3)),super(u,new Zl({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}class up extends ou{constructor(t=10,e=16,n=8,r=64,s=4473924,i=8947848){s=new Xn(s),i=new Xn(i);const a=[],o=[];for(let n=0;n<=e;n++){const r=n/e*(2*Math.PI),l=Math.sin(r)*t,u=Math.cos(r)*t;a.push(0,0,0),a.push(l,0,u);const c=1&n?s:i;o.push(c.r,c.g,c.b),o.push(c.r,c.g,c.b)}for(let e=0;e<=n;e++){const l=1&e?s:i,u=t-t/n*e;for(let t=0;t<r;t++){let e=t/r*(2*Math.PI),n=Math.sin(e)*u,s=Math.cos(e)*u;a.push(n,0,s),o.push(l.r,l.g,l.b),e=(t+1)/r*(2*Math.PI),n=Math.sin(e)*u,s=Math.cos(e)*u,a.push(n,0,s),o.push(l.r,l.g,l.b)}}const l=new js;l.setAttribute("position",new $s(a,3)),l.setAttribute("color",new $s(o,3)),super(l,new Zl({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}}const cp=new ur,hp=new ur,dp=new ur;class pp extends hs{constructor(t,e,n){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,void 0===e&&(e=1);let r=new js;r.setAttribute("position",new $s([-e,e,0,e,e,0,e,-e,0,-e,-e,0,-e,e,0],3));const s=new Zl({fog:!1,toneMapped:!1});this.lightPlane=new su(r,s),this.add(this.lightPlane),r=new js,r.setAttribute("position",new $s([0,0,0,0,0,1],3)),this.targetLine=new su(r,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){cp.setFromMatrixPosition(this.light.matrixWorld),hp.setFromMatrixPosition(this.light.target.matrixWorld),dp.subVectors(hp,cp),this.lightPlane.lookAt(hp),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(hp),this.targetLine.scale.z=dp.length()}}const fp=new ur,mp=new xi;class gp extends ou{constructor(t){const e=new js,n=new Zl({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],s=[],i={},a=new Xn(16755200),o=new Xn(16711680),l=new Xn(43775),u=new Xn(16777215),c=new Xn(3355443);function h(t,e,n){d(t,n),d(e,n)}function d(t,e){r.push(0,0,0),s.push(e.r,e.g,e.b),void 0===i[t]&&(i[t]=[]),i[t].push(r.length/3-1)}h("n1","n2",a),h("n2","n4",a),h("n4","n3",a),h("n3","n1",a),h("f1","f2",a),h("f2","f4",a),h("f4","f3",a),h("f3","f1",a),h("n1","f1",a),h("n2","f2",a),h("n3","f3",a),h("n4","f4",a),h("p","n1",o),h("p","n2",o),h("p","n3",o),h("p","n4",o),h("u1","u2",l),h("u2","u3",l),h("u3","u1",l),h("c","t",u),h("p","c",c),h("cn1","cn2",c),h("cn3","cn4",c),h("cf1","cf2",c),h("cf3","cf4",c),e.setAttribute("position",new $s(r,3)),e.setAttribute("color",new $s(s,3)),super(e,n),this.type="CameraHelper",this.camera=t,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=i,this.update()}update(){const t=this.geometry,e=this.pointMap;mp.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),xp("c",e,t,mp,0,0,-1),xp("t",e,t,mp,0,0,1),xp("n1",e,t,mp,-1,-1,-1),xp("n2",e,t,mp,1,-1,-1),xp("n3",e,t,mp,-1,1,-1),xp("n4",e,t,mp,1,1,-1),xp("f1",e,t,mp,-1,-1,1),xp("f2",e,t,mp,1,-1,1),xp("f3",e,t,mp,-1,1,1),xp("f4",e,t,mp,1,1,1),xp("u1",e,t,mp,.7,1.1,-1),xp("u2",e,t,mp,-.7,1.1,-1),xp("u3",e,t,mp,0,2,-1),xp("cf1",e,t,mp,-1,0,1),xp("cf2",e,t,mp,1,0,1),xp("cf3",e,t,mp,0,-1,1),xp("cf4",e,t,mp,0,1,1),xp("cn1",e,t,mp,-1,0,-1),xp("cn2",e,t,mp,1,0,-1),xp("cn3",e,t,mp,0,-1,-1),xp("cn4",e,t,mp,0,1,-1),t.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function xp(t,e,n,r,s,i,a){fp.set(s,i,a).unproject(r);const o=e[t];if(void 0!==o){const t=n.getAttribute("position");for(let e=0,n=o.length;e<n;e++)t.setXYZ(o[e],fp.x,fp.y,fp.z)}}const yp=new dr;class vp extends ou{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(24),s=new js;s.setIndex(new Is(n,1)),s.setAttribute("position",new Is(r,3)),super(s,new Zl({color:e,toneMapped:!1})),this.object=t,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(t){if(void 0!==t&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&yp.setFromObject(this.object),yp.isEmpty())return;const e=yp.min,n=yp.max,r=this.geometry.attributes.position,s=r.array;s[0]=n.x,s[1]=n.y,s[2]=n.z,s[3]=e.x,s[4]=n.y,s[5]=n.z,s[6]=e.x,s[7]=e.y,s[8]=n.z,s[9]=n.x,s[10]=e.y,s[11]=n.z,s[12]=n.x,s[13]=n.y,s[14]=e.z,s[15]=e.x,s[16]=n.y,s[17]=e.z,s[18]=e.x,s[19]=e.y,s[20]=e.z,s[21]=n.x,s[22]=e.y,s[23]=e.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(t){return this.object=t,this.update(),this}copy(t){return ou.prototype.copy.call(this,t),this.object=t.object,this}}class bp extends ou{constructor(t,e=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new js;r.setIndex(new Is(n,1)),r.setAttribute("position",new $s([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(r,new Zl({color:e,toneMapped:!1})),this.box=t,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(t){const e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(t))}}class wp extends su{constructor(t,e=1,n=16776960){const r=n,s=new js;s.setAttribute("position",new $s([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),s.computeBoundingSphere(),super(s,new Zl({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=t,this.size=e;const i=new js;i.setAttribute("position",new $s([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),i.computeBoundingSphere(),this.add(new ci(i,new Ms({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(t){let e=-this.plane.constant;Math.abs(e)<1e-8&&(e=1e-8),this.scale.set(.5*this.size,.5*this.size,e),this.children[0].material.side=e<0?y:x,this.lookAt(this.plane.normal),super.updateMatrixWorld(t)}}const Sp=new ur;let _p,Tp;class Mp extends hs{constructor(t=new ur(0,0,1),e=new ur(0,0,0),n=1,r=16776960,s=.2*n,i=.2*s){super(),this.type="ArrowHelper",void 0===_p&&(_p=new js,_p.setAttribute("position",new $s([0,0,0,0,1,0],3)),Tp=new Hu(0,.5,1,5,1),Tp.translate(0,-.5,0)),this.position.copy(e),this.line=new su(_p,new Zl({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new ci(Tp,new Ms({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t),this.setLength(n,s,i)}setDirection(t){if(t.y>.99999)this.quaternion.set(0,0,0,1);else if(t.y<-.99999)this.quaternion.set(1,0,0,0);else{Sp.set(t.z,0,-t.x).normalize();const e=Math.acos(t.y);this.quaternion.setFromAxisAngle(Sp,e)}}setLength(t,e=.2*t,n=.2*e){this.line.scale.set(1,Math.max(1e-4,t-e),1),this.line.updateMatrix(),this.cone.scale.set(n,e,n),this.cone.position.y=t,this.cone.updateMatrix()}setColor(t){this.line.material.color.set(t),this.cone.material.color.set(t)}copy(t){return super.copy(t,!1),this.line.copy(t.line),this.cone.copy(t.cone),this}}class Ep extends ou{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],n=new js;n.setAttribute("position",new $s(e,3)),n.setAttribute("color",new $s([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3)),super(n,new Zl({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(t,e,n){const r=new Xn,s=this.geometry.attributes.color.array;return r.set(t),r.toArray(s,0),r.toArray(s,3),r.set(e),r.toArray(s,6),r.toArray(s,9),r.set(n),r.toArray(s,12),r.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class kp{constructor(){this.type="ShapePath",this.color=new Xn,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new Uu,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,r){return this.currentPath.quadraticCurveTo(t,e,n,r),this}bezierCurveTo(t,e,n,r,s,i){return this.currentPath.bezierCurveTo(t,e,n,r,s,i),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t,e){function n(t){const e=[];for(let n=0,r=t.length;n<r;n++){const r=t[n],s=new tc;s.curves=r.curves,e.push(s)}return e}function r(t,e){const n=e.length;let r=!1;for(let s=n-1,i=0;i<n;s=i++){let n=e[s],a=e[i],o=a.x-n.x,l=a.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=e[i],o=-o,a=e[s],l=-l),t.y<n.y||t.y>a.y)continue;if(t.y===n.y){if(t.x===n.x)return!0}else{const e=l*(t.x-n.x)-o*(t.y-n.y);if(0===e)return!0;if(e<0)continue;r=!r}}else{if(t.y!==n.y)continue;if(a.x<=t.x&&t.x<=n.x||n.x<=t.x&&t.x<=a.x)return!0}}return r}const s=Mc.isClockWise,i=this.subPaths;if(0===i.length)return[];if(!0===e)return n(i);let a,o,l;const u=[];if(1===i.length)return o=i[0],l=new tc,l.curves=o.curves,u.push(l),u;let c=!s(i[0].getPoints());c=t?!c:c;const h=[],d=[];let p,f,m=[],g=0;d[g]=void 0,m[g]=[];for(let e=0,n=i.length;e<n;e++)o=i[e],p=o.getPoints(),a=s(p),a=t?!a:a,a?(!c&&d[g]&&g++,d[g]={s:new tc,p},d[g].s.curves=o.curves,c&&g++,m[g]=[]):m[g].push({h:o,p:p[0]});if(!d[0])return n(i);if(d.length>1){let t=!1,e=0;for(let t=0,e=d.length;t<e;t++)h[t]=[];for(let n=0,s=d.length;n<s;n++){const s=m[n];for(let i=0;i<s.length;i++){const a=s[i];let o=!0;for(let s=0;s<d.length;s++)r(a.p,d[s].p)&&(n!==s&&e++,o?(o=!1,h[s].push(a)):t=!0);o&&h[n].push(a)}}e>0&&!1===t&&(m=h)}for(let t=0,e=d.length;t<e;t++){l=d[t].s,u.push(l),f=m[t];for(let t=0,e=f.length;t<e;t++)l.holes.push(f[t].h)}return u}}class Ip{static toHalfFloat(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=Mn(t,-65504,65504),Ap[0]=t;const e=Rp[0],n=e>>23&511;return Np[n]+((8388607&e)>>Dp[n])}static fromHalfFloat(t){const e=t>>10;return Rp[0]=Lp[Pp[e]+(1023&t)]+Fp[e],Ap[0]}}const Cp=new ArrayBuffer(4),Ap=new Float32Array(Cp),Rp=new Uint32Array(Cp),Np=new Uint32Array(512),Dp=new Uint32Array(512);for(let t=0;t<256;++t){const e=t-127;e<-27?(Np[t]=0,Np[256|t]=32768,Dp[t]=24,Dp[256|t]=24):e<-14?(Np[t]=1024>>-e-14,Np[256|t]=1024>>-e-14|32768,Dp[t]=-e-1,Dp[256|t]=-e-1):e<=15?(Np[t]=e+15<<10,Np[256|t]=e+15<<10|32768,Dp[t]=13,Dp[256|t]=13):e<128?(Np[t]=31744,Np[256|t]=64512,Dp[t]=24,Dp[256|t]=24):(Np[t]=31744,Np[256|t]=64512,Dp[t]=13,Dp[256|t]=13)}const Lp=new Uint32Array(2048),Fp=new Uint32Array(64),Pp=new Uint32Array(64);for(let t=1;t<1024;++t){let e=t<<13,n=0;for(;0==(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,Lp[t]=e|n}for(let t=1024;t<2048;++t)Lp[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)Fp[t]=t<<23;Fp[31]=1199570944,Fp[32]=2147483648;for(let t=33;t<63;++t)Fp[t]=2147483648+(t-32<<23);Fp[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(Pp[t]=1024);const $p=0,Op=1,zp=0,Bp=1,Up=2;function Wp(t){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),t}function Vp(t=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),t.isMultiMaterial=!0,t.materials=t,t.clone=function(){return t.slice()},t}class Gp extends fu{constructor(t,e){console.warn("THREE.PointCloud has been renamed to THREE.Points."),super(t,e)}}class Hp extends Al{constructor(t){console.warn("THREE.Particle has been renamed to THREE.Sprite."),super(t)}}class jp extends fu{constructor(t,e){console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),super(t,e)}}class qp extends uu{constructor(t){console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),super(t)}}class Xp extends uu{constructor(t){console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),super(t)}}class Kp extends uu{constructor(t){console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),super(t)}}class Yp extends ur{constructor(t,e,n){console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),super(t,e,n)}}class Jp extends Is{constructor(t,e){console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),super(t,e),this.setUsage(ln)}}class Zp extends Cs{constructor(t,e){console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),super(t,e)}}class Qp extends As{constructor(t,e){console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),super(t,e)}}class tf extends Rs{constructor(t,e){console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),super(t,e)}}class ef extends Ns{constructor(t,e){console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),super(t,e)}}class nf extends Ds{constructor(t,e){console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),super(t,e)}}class rf extends Ls{constructor(t,e){console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),super(t,e)}}class sf extends Fs{constructor(t,e){console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),super(t,e)}}class af extends $s{constructor(t,e){console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),super(t,e)}}class of extends Os{constructor(t,e){console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),super(t,e)}}bu.create=function(t,e){return console.log("THREE.Curve.create() has been deprecated"),t.prototype=Object.create(bu.prototype),t.prototype.constructor=t,t.prototype.getPoint=e,t},Uu.prototype.fromPoints=function(t){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)};class lf extends Ep{constructor(t){console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),super(t)}}class uf extends vp{constructor(t,e){console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),super(t,e)}}class cf extends ou{constructor(t,e){console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),super(new Qu(t.geometry),new Zl({color:void 0!==e?e:16777215}))}}lp.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},ep.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};class hf extends ou{constructor(t,e){console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),super(new zc(t.geometry),new Zl({color:void 0!==e?e:16777215}))}}xh.prototype.extractUrlBase=function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),jh.extractUrlBase(t)},xh.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};class df extends vh{constructor(t){console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),super(t)}}class pf extends Th{constructor(t){console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),super(t)}}jd.prototype.center=function(t){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(t)},jd.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},jd.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},jd.prototype.size=function(t){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(t)},dr.prototype.center=function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},dr.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},dr.prototype.isIntersectionBox=function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},dr.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},dr.prototype.size=function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)},Yr.prototype.toVector3=function(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")},Rr.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Ci.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},Kd.prototype.center=function(t){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(t)},Dn.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},Dn.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},Dn.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},Dn.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},Dn.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},Dn.prototype.getInverse=function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},Br.prototype.extractPosition=function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},Br.prototype.flattenToArrayOffset=function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},Br.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new ur).setFromMatrixColumn(this,3)},Br.prototype.setRotationFromQuaternion=function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},Br.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},Br.prototype.multiplyVector3=function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Br.prototype.multiplyVector4=function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Br.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},Br.prototype.rotateAxis=function(t){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),t.transformDirection(this)},Br.prototype.crossVector=function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Br.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},Br.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},Br.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},Br.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},Br.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},Br.prototype.applyToBufferAttribute=function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},Br.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},Br.prototype.makeFrustum=function(t,e,n,r,s,i){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(t,e,r,n,s,i)},Br.prototype.getInverse=function(t){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()},Ei.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},lr.prototype.multiplyVector3=function(t){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),t.applyQuaternion(this)},lr.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},zr.prototype.isIntersectionBox=function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},zr.prototype.isIntersectionPlane=function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},zr.prototype.isIntersectionSphere=function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},Ss.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},Ss.prototype.barycoordFromPoint=function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},Ss.prototype.midpoint=function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},Ss.prototypenormal=function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},Ss.prototype.plane=function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)},Ss.barycoordFromPoint=function(t,e,n,r,s){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Ss.getBarycoord(t,e,n,r,s)},Ss.normal=function(t,e,n,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Ss.getNormal(t,e,n,r)},tc.prototype.extractAllPoints=function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},tc.prototype.extrude=function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Ic(this,t)},tc.prototype.makeGeometry=function(t){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Dc(this,t)},Nn.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},Nn.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},Nn.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},ur.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},ur.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},ur.prototype.getPositionFromMatrix=function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},ur.prototype.getScaleFromMatrix=function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},ur.prototype.getColumnFromMatrix=function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},ur.prototype.applyProjection=function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},ur.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},ur.prototype.distanceToManhattan=function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},ur.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},er.prototype.fromAttribute=function(t,e,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},er.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},hs.prototype.getChildByName=function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},hs.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},hs.prototype.translate=function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},hs.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},hs.prototype.applyMatrix=function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(hs.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),ci.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(ci.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Ne},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Bl.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},yi.prototype.setLens=function(t,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==e&&(this.filmGauge=e),this.setFocalLength(t)},Object.defineProperties(Eh.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(Is.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===ln},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(ln)}}}),Is.prototype.setDynamic=function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?ln:on),this},Is.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Is.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},js.prototype.addIndex=function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},js.prototype.addAttribute=function(t,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),e&&e.isBufferAttribute||e&&e.isInterleavedBufferAttribute?"index"===t?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(t,e):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(t,new Is(arguments[1],arguments[2])))},js.prototype.addDrawCall=function(t,e,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(t,e)},js.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},js.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},js.prototype.removeAttribute=function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},js.prototype.applyMatrix=function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)},Object.defineProperties(js.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),pl.prototype.setDynamic=function(t){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?ln:on),this},pl.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Ic.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},Ic.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},Ic.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},dl.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},$d.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(Ts.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Xn}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=t===b}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(t){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=t}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(gi.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),ll.prototype.clearTarget=function(t,e,n,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(t),this.clear(e,n,r)},ll.prototype.animate=function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},ll.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},ll.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},ll.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},ll.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},ll.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},ll.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},ll.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},ll.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},ll.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},ll.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},ll.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},ll.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},ll.prototype.enableScissorTest=function(t){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(t)},ll.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},ll.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},ll.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},ll.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},ll.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},ll.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},ll.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},ll.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},ll.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},ll.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(ll.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(t){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===t?Pe:Fe}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}}),Object.defineProperties(Jo.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});class ff extends Si{constructor(t,e,n){console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),super(t,n)}}function mf(){console.error("THREE.CanvasRenderer has been removed")}function gf(){console.error("THREE.JSONLoader has been removed.")}Object.defineProperties(nr.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(t){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=t}}}),gd.prototype.load=function(t){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return(new nd).load(t,(function(t){e.setBuffer(t)})),this},Sd.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},bi.prototype.updateCubeMap=function(t,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(t,e)},bi.prototype.clear=function(t,e,n,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(t,e,n,r)},Yn.crossOrigin=void 0,Yn.loadTexture=function(t,e,n,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const s=new Mh;s.setCrossOrigin(this.crossOrigin);const i=s.load(t,n,void 0,r);return e&&(i.mapping=e),i},Yn.loadTextureCube=function(t,e,n,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const s=new _h;s.setCrossOrigin(this.crossOrigin);const i=s.load(t,n,void 0,r);return e&&(i.mapping=e),i},Yn.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Yn.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const xf={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function yf(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}class vf extends js{constructor(){console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"),super()}}class bf extends js{constructor(){console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"),super()}}function wf(){console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")}function Sf(){console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")}function _f(){console.error("THREE.ImmediateRenderObject has been removed.")}class Tf extends nr{constructor(t,e,n){console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),super(t,e,n),this.samples=4}}class Mf extends rr{constructor(t,e,n,r){console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),super(t,e,n,r)}}class Ef extends ir{constructor(t,e,n,r){console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),super(t,e,n,r)}}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:a}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=a);const kf=new ur,If=new lr,Cf=new ur;class Af extends hs{constructor(t=document.createElement("div")){super(),this.element=t,this.element.style.position="absolute",this.element.style.pointerEvents="auto",this.element.style.userSelect="none",this.element.setAttribute("draggable",!1),this.addEventListener("removed",(function(){this.traverse((function(t){t.element instanceof Element&&null!==t.element.parentNode&&t.element.parentNode.removeChild(t.element)}))}))}copy(t,e){return super.copy(t,e),this.element=t.element.cloneNode(!0),this}}Af.prototype.isCSS3DObject=!0,class extends Af{constructor(t){super(t),this.rotation2D=0}copy(t,e){return super.copy(t,e),this.rotation2D=t.rotation2D,this}}.prototype.isCSS3DSprite=!0;const Rf=new Br,Nf=new Br;class Df{constructor(t={}){const e=this;let n,r,s,i;const a={camera:{fov:0,style:""},objects:new WeakMap},o=void 0!==t.element?t.element:document.createElement("div");o.style.overflow="hidden",this.domElement=o;const l=document.createElement("div");function u(t){return Math.abs(t)<1e-10?0:t}function c(t){const e=t.elements;return"matrix3d("+u(e[0])+","+u(-e[1])+","+u(e[2])+","+u(e[3])+","+u(e[4])+","+u(-e[5])+","+u(e[6])+","+u(e[7])+","+u(e[8])+","+u(-e[9])+","+u(e[10])+","+u(e[11])+","+u(e[12])+","+u(-e[13])+","+u(e[14])+","+u(e[15])+")"}function h(t){const e=t.elements;return"translate(-50%,-50%)matrix3d("+u(e[0])+","+u(e[1])+","+u(e[2])+","+u(e[3])+","+u(-e[4])+","+u(-e[5])+","+u(-e[6])+","+u(-e[7])+","+u(e[8])+","+u(e[9])+","+u(e[10])+","+u(e[11])+","+u(e[12])+","+u(e[13])+","+u(e[14])+","+u(e[15])+")"}function d(t,n,r,s){if(t.isCSS3DObject){const s=!0===t.visible&&!0===t.layers.test(r.layers);if(t.element.style.display=!0===s?"":"none",!0===s){let s;t.onBeforeRender(e,n,r),t.isCSS3DSprite?(Rf.copy(r.matrixWorldInverse),Rf.transpose(),0!==t.rotation2D&&Rf.multiply(Nf.makeRotationZ(t.rotation2D)),t.matrixWorld.decompose(kf,If,Cf),Rf.setPosition(kf),Rf.scale(Cf),Rf.elements[3]=0,Rf.elements[7]=0,Rf.elements[11]=0,Rf.elements[15]=1,s=h(Rf)):s=h(t.matrixWorld);const i=t.element,o=a.objects.get(t);if(void 0===o||o.style!==s){i.style.transform=s;const e={style:s};a.objects.set(t,e)}i.parentNode!==l&&l.appendChild(i),t.onAfterRender(e,n,r)}}for(let e=0,i=t.children.length;e<i;e++)d(t.children[e],n,r,s)}l.style.transformStyle="preserve-3d",l.style.pointerEvents="none",o.appendChild(l),this.getSize=function(){return{width:n,height:r}},this.render=function(t,e){const n=e.projectionMatrix.elements[5]*i;let r,h;a.camera.fov!==n&&(o.style.perspective=e.isPerspectiveCamera?n+"px":"",a.camera.fov=n),!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),e.isOrthographicCamera&&(r=-(e.right+e.left)/2,h=(e.top+e.bottom)/2);const p=e.isOrthographicCamera?"scale("+n+")translate("+u(r)+"px,"+u(h)+"px)"+c(e.matrixWorldInverse):"translateZ("+n+"px)"+c(e.matrixWorldInverse),f=p+"translate("+s+"px,"+i+"px)";a.camera.style!==f&&(l.style.transform=f,a.camera.style=f),d(t,t,e,p)},this.setSize=function(t,e){n=t,r=e,s=n/2,i=r/2,o.style.width=t+"px",o.style.height=e+"px",l.style.width=t+"px",l.style.height=e+"px"}}}class Lf{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Ff{refCount(t){return Pf("refCount")}incRef(t){return Pf("incRef")}timerAvailable(){return!0}time(t){return Pf("time")}read(t){return Pf("read")}readSync(t){return Pf("readSync")}readToGPU(t,e){return Pf("readToGPU")}numDataIds(){return Pf("numDataIds")}disposeData(t,e){return Pf("disposeData")}write(t,e,n){return Pf("write")}move(t,e,n,r,s){return Pf("move")}memory(){return Pf("memory")}floatPrecision(){return Pf("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Pf("dispose")}}function Pf(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function $f(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,Bf(t,e,n)}function Of(t,e,n){return Math.max(t,Math.min(e,n))}function zf(t){return t%2==0?t:t+1}function Bf(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function Uf(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function Wf(t,e,n=""){Uf(jf(t,e),(()=>n+` Shapes ${t} and ${e} must match`))}function Vf(t){Uf(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function Gf(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||rm(t)&&!n)for(let r=0;r<t.length;++r)Gf(t[r],e,n);else e.push(t);return e}function Hf(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function jf(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function qf(t){return t%1==0}function Xf(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Kf(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function Yf(t,e=(t=>0),n){return new Promise(((r,s)=>{let i=0;const a=()=>{if(t())return void r();i++;const o=e(i);null!=n&&i>=n?s():setTimeout(a,o)};a()}))}function Jf(t,e){let n=1,r=-1;for(let e=0;e<t.length;++e)if(t[e]>=0)n*=t[e];else if(-1===t[e]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${e}`);r=e}else if(t[e]<0)throw Error(`Shapes can not be < 0. Found ${t[e]} at dim ${e}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function Zf(t,e){const n=e.length;return Uf((t=null==t?e.map(((t,e)=>e)):[].concat(t)).every((t=>t>=-n&&t<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`)),Uf(t.every((t=>qf(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?n+t:t))}function Qf(t,e){const n=[],r=[],s=null!=e&&Array.isArray(e)&&0===e.length,i=null==e||s?null:Zf(e,t).sort();let a=0;for(let e=0;e<t.length;++e){if(null!=i){if(i[a]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==i[a]||i[a]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),i[a]<=e&&a++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function tm(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function em(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function nm(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function rm(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function sm(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function im(t){return"string"==typeof t||t instanceof String}function am(t){return"number"==typeof t}function om(t){return Array.isArray(t)?om(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":am(t)?"float32":im(t)?"string":"boolean"==typeof t?"bool":"float32"}function lm(t){return!!(t&&t.constructor&&t.call&&t.apply)}function um(t,e){for(let n=e;n<t;++n)if(t%n==0)return n;return t}function cm(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function hm(t,e,n,r=!1){const s=new Array;if(1===e.length){const i=e[0]*(r?2:1);for(let e=0;e<i;e++)s[e]=n[t+e]}else{const i=e[0],a=e.slice(1),o=a.reduce(((t,e)=>t*e))*(r?2:1);for(let e=0;e<i;e++)s[e]=hm(t+e*o,a,n,r)}return s}function dm(t,e,n=!1){if(0===t.length)return e[0];const r=t.reduce(((t,e)=>t*e))*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return hm(0,t,e,n)}function pm(t,e){const n=fm(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function fm(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function mm(t,e){const n=t.reduce(((t,e)=>t*e),1);if(null==e||"float32"===e)return dm(t,new Float32Array(n));if("int32"===e)return dm(t,new Int32Array(n));if("bool"===e)return dm(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function gm(t){t.forEach((e=>{Uf(Number.isInteger(e)&&e>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}function xm(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let e=0;e<t.length-1;++e)r+=n[e]*t[e];return r}function ym(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let e=0;e<r.length-1;++e)r[e]=Math.floor(t/n[e]),t-=r[e]*n[e];return r[r.length-1]=t,r}function vm(t){return t&&t.then&&"function"==typeof t.then}class bm{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=wm,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(Sm().getBool("IS_TEST")||Sm().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];Sm().getBool("IS_TEST")||Sm().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(vm(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);"tfjsflags"in t&&t.tfjsflags.split(",").forEach((t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)}))}}function wm(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("=")))),e}function Sm(){return Tm}let _m,Tm=null;function Mm(){if(null==_m){let t;if("undefined"!=typeof window)t=window;else if(void 0!==n.g)t=n.g;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}_m=t}return _m}function Em(t,e){const n=function(){const t=Mm();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const km="Abs",Im="Acos",Cm="Acosh",Am="Add",Rm="AddN",Nm="All",Dm="Any",Lm="ArgMax",Fm="ArgMin",Pm="Asin",$m="Asinh",Om="Atan",zm="Atanh",Bm="Atan2",Um="AvgPool",Wm="AvgPoolGrad",Vm="AvgPool3D",Gm="AvgPool3DGrad",Hm="BatchMatMul",jm="BatchToSpaceND",qm="Bincount",Xm="BroadcastArgs",Km="Cast",Ym="Ceil",Jm="ClipByValue",Zm="Complex",Qm="ComplexAbs",tg="Concat",eg="Conv2D",ng="Conv2DBackpropFilter",rg="Conv2DBackpropInput",sg="Conv3D",ig="Conv3DBackpropFilterV2",ag="Conv3DBackpropInputV2",og="Cos",lg="Cosh",ug="Cumprod",cg="Cumsum",hg="CropAndResize",dg="DenseBincount",pg="DepthToSpace",fg="DepthwiseConv2dNative",mg="DepthwiseConv2dNativeBackpropFilter",gg="DepthwiseConv2dNativeBackpropInput",xg="Diag",yg="Dilation2D",vg="Dilation2DBackpropInput",bg="Dilation2DBackpropFilter",wg="RealDiv",Sg="Einsum",_g="Elu",Tg="EluGrad",Mg="Erf",Eg="Equal",kg="Exp",Ig="ExpandDims",Cg="Expm1",Ag="FFT",Rg="Fill",Ng="FlipLeftRight",Dg="Floor",Lg="FloorDiv",Fg="FusedBatchNorm",Pg="GatherV2",$g="GatherNd",Og="Greater",zg="GreaterEqual",Bg="Identity",Ug="IFFT",Wg="Imag",Vg="IsFinite",Gg="IsInf",Hg="IsNan",jg="LeakyRelu",qg="Less",Xg="LessEqual",Kg="LinSpace",Yg="Log",Jg="Log1p",Zg="LogicalAnd",Qg="LogicalNot",tx="LogicalOr",ex="LRN",nx="LRNGrad",rx="Max",sx="Maximum",ix="MaxPool",ax="MaxPoolGrad",ox="MaxPool3D",lx="MaxPool3DGrad",ux="MaxPoolWithArgmax",cx="Mean",hx="Min",dx="Minimum",px="MirrorPad",fx="Mod",mx="Multinomial",gx="Multiply",xx="Neg",yx="NotEqual",vx="NonMaxSuppressionV3",bx="NonMaxSuppressionV4",wx="NonMaxSuppressionV5",Sx="OnesLike",_x="OneHot",Tx="Pack",Mx="PadV2",Ex="Pow",kx="Prelu",Ix="Prod",Cx="Range",Ax="Real",Rx="Reciprocal",Nx="Relu",Dx="Reshape",Lx="ResizeNearestNeighbor",Fx="ResizeNearestNeighborGrad",Px="ResizeBilinear",$x="ResizeBilinearGrad",Ox="Relu6",zx="Reverse",Bx="Round",Ux="Rsqrt",Wx="ScatterNd",Vx="SearchSorted",Gx="Select",Hx="Selu",jx="Slice",qx="Sin",Xx="Sinh",Kx="Sign",Yx="Sigmoid",Jx="Softplus",Zx="Sqrt",Qx="Sum",ty="SpaceToBatchND",ey="SplitV",ny="Softmax",ry="SparseFillEmptyRows",sy="SparseReshape",iy="SparseSegmentMean",ay="SparseSegmentSum",oy="SparseToDense",ly="SquaredDifference",uy="Square",cy="StridedSlice",hy="StringNGrams",dy="StringSplit",py="StringToHashBucketFast",fy="Sub",my="Tan",gy="Tanh",xy="Tile",yy="TopK",vy="Transform",by="Transpose",wy="Unique",Sy="Unpack",_y="UnsortedSegmentSum",Ty="ZerosLike",My="Step",Ey="RotateWithOffset",ky="_FusedMatMul",Iy="FusedConv2D",Cy="FusedDepthwiseConv2D";function Ay(...t){Sm().getBool("IS_TEST")||Sm().getBool("PROD")||console.warn(...t)}function Ry(...t){Sm().getBool("IS_TEST")||Sm().getBool("PROD")||console.log(...t)}const Ny=Em("kernelRegistry",(()=>new Map)),Dy=Em("gradRegistry",(()=>new Map));function Ly(t,e){const n=zy(t,e);return Ny.get(n)}function Fy(t){return Dy.get(t)}function Py(t){const e=Ny.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,a]=s,[o]=i.split("_");o===t&&n.push(a)}return n}function $y(t){const{kernelName:e,backendName:n}=t,r=zy(e,n);Ny.has(r)&&Ay(`The kernel '${e}' for backend '${n}' is already registered`),Ny.set(r,t)}function Oy(t){const{kernelName:e}=t;Dy.has(e)&&Sm().getBool("DEBUG")&&Ay(`Overriding the gradient for '${e}'`),Dy.set(e,t)}function zy(t,e){return`${e}_${t}`}var By=n(3720);const Uy=n.n(By)()||By;function Wy(t){return Uy.fromString(t,!0,16)}const Vy=Wy("c3a5c85c97cb3127"),Gy=Wy("b492b66fbe98f273"),Hy=Wy("9ae16a3b2f90404f");function jy(t){return t.xor(t.shru(47))}function qy(t,e,n){const r=t.slice(e,e+n);return Uy.fromBytes(Array.from(r),!0,!0)}function Xy(t,e){return qy(t,e,8)}function Ky(t,e){return qy(t,e,4)}function Yy(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function Jy(t,e,n=Wy("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Zy(t,e,n,r){return function(t,e,n,r,s,i){s=s.add(t),i=Yy(i.add(s).add(r),21);const a=s;return s=(s=s.add(e)).add(n),i=i.add(Yy(s,44)),[s.add(r),i.add(a)]}(Xy(t,e),Xy(t,e+8),Xy(t,e+16),Xy(t,e+24),n,r)}function Qy(t,e=t.length){const n=Uy.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=Hy.add(2*e),r=Xy(t,0).add(Hy),s=Xy(t,e-8);return Jy(Yy(s,37).mul(n).add(r),Yy(r,25).add(s).mul(n),n)}if(e>=4){const n=Hy.add(2*e);return Jy(Ky(t,0).shl(3).add(e),Ky(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),r=e+(t[e-1]<<2);return jy(Hy.mul(n).xor(Vy.mul(r))).mul(Hy)}return Hy}(t,e):function(t,e=t.length){const n=Hy.add(2*e),r=Xy(t,0).mul(Gy),s=Xy(t,8),i=Xy(t,e-8).mul(n),a=Xy(t,e-16).mul(Hy);return Jy(Yy(r.add(s),43).add(Yy(i,30)).add(a),r.add(Yy(s.add(Hy),18)).add(i),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=Hy.add(2*e),r=Xy(t,0).mul(Hy),s=Xy(t,8),i=Xy(t,e-8).mul(n),a=Xy(t,e-16).mul(Hy),o=Yy(r.add(s),43).add(Yy(i,30)).add(a),l=Jy(o,r.add(Yy(s.add(Hy),18)).add(i),n),u=Xy(t,16).mul(n),c=Xy(t,24),h=o.add(Xy(t,e-32)).mul(n),d=l.add(Xy(t,e-24)).mul(n);return Jy(Yy(u.add(c),43).add(Yy(h,30)).add(d),u.add(Yy(c.add(r),18)).add(h),n)}(t,e);let r=n,s=n.mul(Gy).add(113),i=jy(s.mul(Hy).add(113)).mul(Hy),a=[Uy.UZERO,Uy.UZERO],o=[Uy.UZERO,Uy.UZERO];r=r.mul(Hy).add(Xy(t,0));let l=0;const u=64*(e-1>>6),c=u+(e-1&63)-63;do{r=Yy(r.add(s).add(a[0]).add(Xy(t,l+8)),37).mul(Gy),s=Yy(s.add(a[1]).add(Xy(t,l+48)),42).mul(Gy),r=r.xor(o[1]),s=s.add(a[0]).add(Xy(t,l+40)),i=Yy(i.add(o[0]),33).mul(Gy),a=Zy(t,l,a[1].mul(Gy),r.add(o[0])),o=Zy(t,l+32,i.add(o[1]),s.add(Xy(t,l+16))),[i,r]=[r,i],l+=64}while(l!==u);const h=Gy.add(i.and(255).shl(1));return l=c,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),r=Yy(r.add(s).add(a[0]).add(Xy(t,l+8)),37).mul(h),s=Yy(s.add(a[1]).add(Xy(t,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),s=s.add(a[0].mul(9).add(Xy(t,l+40))),i=Yy(i.add(o[0]),33).mul(h),a=Zy(t,l,a[1].mul(h),r.add(o[0])),o=Zy(t,l+32,i.add(o[1]),s.add(Xy(t,l+16))),[i,r]=[r,i],Jy(Jy(a[0],o[0],h).add(jy(s).mul(Vy)).add(i),Jy(a[1],o[1],h).add(r),h)}function tv(t,e){return"string"===e?rv(t):ev([t],e)}function ev(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Gf(t)),Sm().getBool("DEBUG")&&function(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function nv(){return Sm().platform.now()}function rv(t,e="utf-8"){return e=e||"utf-8",Sm().platform.encode(t,e)}function sv(t,e="utf-8"){return e=e||"utf-8",Sm().platform.decode(t,e)}class iv{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new ov)}profileKernel(t,e,n){let r;const s=()=>{r=n()};let i;const a=nv();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(const t of r)t.dataSync();i=Promise.resolve({kernelMs:nv()-a})}if(Sm().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<r.length;e++){const n=r[e];n.data().then((e=>{av(e,n.dtype,t)}))}return{kernelName:t,outputs:r,inputs:e,timeMs:i.then((t=>t.kernelMs)),extraInfo:i.then((t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():""))}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:s,extraInfo:i}=t;n.forEach((t=>{Promise.all([t.data(),r,i]).then((n=>{this.logger.logKernelProfile(e,t,n[0],n[1],s,n[2])}))}))}}function av(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class ov{logKernelProfile(t,e,n,r,s,i){const a="number"==typeof r?Kf(`${r}ms`,9):r.error,o=Kf(t,25),l=e.rank,u=e.size,c=Kf(e.shape.toString(),14);let h="";for(const t in s){const n=s[t];if(null!=n){const r=n.shape||e.shape,s=r.length;h+=`${t}: ${s}D ${s>0?r:""} `}}console.log(`%c${o}\t%c${a}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function lv(t,e,n,r){const s=cm(e),i=function(t,e,n,r){const s=Hf(e),i=r[r.length-1],a=new Array(i).fill(0),o=e.length,l="complex64"===n?dv(t):t;if(o>1)for(let t=0;t<s/i;t++){const e=t*i;for(let t=0;t<i;t++)a[t]=Math.max(a[t],uv(l[e+t],0,n).length)}return a}(t,e,n,s),a=e.length,o=hv(t,e,n,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map((t=>"    "+t)).join("\n")),l.join("\n")}function uv(t,e,n){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:im(t)?`'${t}'`:"bool"===n?cv(t):parseFloat(t.toFixed(7)).toString(),Kf(r,e)}function cv(t){return 0===t?"false":"true"}function hv(t,e,n,r,s,i=!0){const a="complex64"===n?2:1,o=e[0],l=e.length;if(0===l)return"complex64"===n?[uv(dv(t)[0],0,n)]:"bool"===n?[cv(t[0])]:[t[0].toString()];if(1===l){if(o>20){const e=3*a;let r=Array.from(t.slice(0,e)),i=Array.from(t.slice((o-3)*a,o*a));return"complex64"===n&&(r=dv(r),i=dv(i)),["["+r.map(((t,e)=>uv(t,s[e],n))).join(", ")+", ..., "+i.map(((t,e)=>uv(t,s[o-3+e],n))).join(", ")+"]"]}return["["+("complex64"===n?dv(t):Array.from(t)).map(((t,e)=>uv(t,s[e],n))).join(", ")+"]"]}const u=e.slice(1),c=r.slice(1),h=r[0]*a,d=[];if(o>20){for(let e=0;e<3;e++){const r=e*h,i=r+h;d.push(...hv(t.slice(r,i),u,n,c,s,!1))}d.push("...");for(let e=o-3;e<o;e++){const r=e*h,i=r+h;d.push(...hv(t.slice(r,i),u,n,c,s,e===o-1))}}else for(let e=0;e<o;e++){const r=e*h,i=r+h;d.push(...hv(t.slice(r,i),u,n,c,s,e===o-1))}const p=2===l?",":"";d[0]="["+d[0]+p;for(let t=1;t<d.length-1;t++)d[t]=" "+d[t]+p;let f=",\n";for(let t=2;t<l;t++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function dv(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}class pv{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=Hf(t),null!=n){const t=n.length;Uf(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||em(e,this.size),this.strides=cm(t)}set(t,...e){0===e.length&&(e=[0]),Uf(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return fv().makeTensor(this.values,this.shape,this.dtype)}}let fv=null,mv=null,gv=null;class xv{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Hf(t),this.strides=cm(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return mv.buffer(this.shape,this.dtype,t)}bufferSync(){return mv.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return dm(this.shape,t,"complex64"===this.dtype)}arraySync(){return dm(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=fv().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map((t=>sv(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),fv().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=fv().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>sv(t)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await fv().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(fv().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return mv.print(this,t)}clone(){return this.throwIfDisposed(),mv.clone(this)}toString(t=!1){return lv(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),mv.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),fv().makeVariable(this,t,e,n)}}function yv(){return Em("Tensor",(()=>xv))}Object.defineProperty(xv,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),yv();class vv extends xv{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!jf(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);fv().disposeTensor(this),this.dataId=t.dataId,fv().incRef(this,null)}dispose(){fv().disposeVariable(this),this.isDisposedInternal=!0}}var bv,wv,Sv,_v,Tv;Object.defineProperty(vv,Symbol.hasInstance,{value:t=>t instanceof xv&&null!=t.assign&&t.assign instanceof Function}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(bv||(bv={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(wv||(wv={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(Sv||(Sv={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(_v||(_v={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(Tv||(Tv={}));const Mv={float32:_v,int32:wv,bool:Sv,complex64:Tv};function Ev(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return Mv[t][e]}function kv(t){return Ev(t,"int32")}function Iv(t,e){if(t.dtype===e.dtype)return[t,e];const n=Ev(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function Cv(t,e){return e.some((e=>e.id===t.id))}function Av(t){const e=[];return Rv(t,e,new Set),e}function Rv(t,e,n){if(null==t)return;if(t instanceof xv)return void e.push(t);if(r=t,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=t;for(const t in s){const r=s[t];n.has(r)||(n.add(r),Rv(r,e,n))}}function Nv(t){return null!=t.kernelName}class Dv{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((t=>t.name))))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Lv{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Dv}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(Ay(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new iv(this.backendInstance),!0}setupRegisteredKernels(){Py(this.backendName).forEach((t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(t){Py(t).forEach((e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])}))}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof Ff||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then((n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0)))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,Ay(`Initialization of backend ${t} failed`),Ay(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return Ay(`Initialization of backend ${t} failed`),Ay(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority))}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,s=this.readSync(e),i=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,s,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return Lv.nextTensorId++}nextVariableId(){return Lv.nextVariableId++}clone(t){const e=Pv.runKernel(Bg,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],(t=>({x:()=>{const e={x:t};return Pv.runKernel(Km,e,{dtype:"float32"})}})),[],{}),e}runKernel(t,e,n){if(null==this.backendName&&this.backend,null==Ly(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let s=0;n.forEach((t=>{s+="complex64"===t.dtype?3:1}));const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-e-s-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;let a,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=Nv(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Nv(t)){const{kernelName:e,inputs:s,attrs:i}=t;null==this.backendName&&this.backend;const l=Ly(e,this.backendName);Uf(null!=l,(()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`)),a=()=>{const t=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:i,backend:this.backend});const a=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,a);const u=a.map((t=>null!=t.rank?t:this.makeTensorFromTensorInfo(t)));if(r){const t=this.getTensorsForGradient(e,s,u);n=this.saveTensorsForBackwardMode(t)}return u}}else{const{forwardFunc:e}=t,s=t=>{r&&(n=t.map((t=>this.keep(this.clone(t)))))};a=()=>{const t=this.backend.numDataIds();o=this.tidy((()=>e(this.backend,s)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,t,n),n}}const{inputs:u,attrs:c}=t,h=Nv(t)?null:t.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,(()=>a())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs):e=a()})),r&&this.addTapeNode(l,u,e,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((t=>null!=u[t]?u[t].shape:null)),outputShapes:e.map((t=>t.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?e:e[0]}saveTensorsForBackwardMode(t){return t.map((t=>this.keep(this.clone(t))))}getTensorsForGradient(t,e,n){const r=Fy(t);if(null!=r){const t=r.inputsToSave||[],s=r.outputsToSave||[];let i;r.saveAllInputs?(Uf(Array.isArray(e),(()=>"saveAllInputs is true, expected inputs to be an array.")),i=Object.keys(e).map((t=>e[t]))):i=t.map((t=>e[t]));const a=n.filter(((t,e)=>s[e]));return i.concat(a)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=t;"string"===n&&im(t[0])&&(s=t.map((t=>rv(t))));const i=r.write(s,e,n),a=new xv(e,n,i,this.nextTensorId());if(this.trackTensor(a,r),"string"===n){const t=this.state.tensorInfo.get(i),e=function(t){if(null==t)return 0;let e=0;return t.forEach((t=>e+=t.length)),e}(s);this.state.numBytes+=e-t.bytes,t.bytes=e}return a}makeTensorFromDataId(t,e,n,r){const s={dataId:t,shape:e,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(t,e){const{dataId:n,shape:r,dtype:s}=t,i=new xv(r,s,n,this.nextTensorId());return this.trackTensor(i,e),i}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const s=new vv(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*sm(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof vv||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*sm(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((t=>t.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,s,i){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:s},o=Fy(t);null!=o&&(r=o.gradFunc),null!=r&&(a.gradient=t=>(t=t.map(((t,e)=>{if(null==t){const t=n[e],r=fm(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t})),r(t.length>1?t:t[0],s,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Av(t),n=new Set(e.map((t=>t.id)));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach((t=>{t.kept||t.scopeId!==r.id||this.track(t)}))}gradients(t,e,n,r=!1){if(Uf(e.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",t)));Uf(s instanceof xv,(()=>"The result y returned by f() must be a tensor."));const i=function(t,e,n){const r={},s={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const i=t[n],a=i.inputs;for(const t in a){const n=a[t];let o=!1;for(let t=0;t<e.length;t++)if(r[n.id]){i.outputs.forEach((t=>r[t.id]=!0)),o=!0,s[i.id]=!0;break}if(o)break}}const i={};i[n.id]=!0;const a={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(i[n.outputs[t].id]){for(const t in r)i[r[t].id]=!0,a[n.id]=!0;break}}const o=[];for(let e=0;e<t.length;e++){const n=t[e];if(s[n.id]&&a[n.id]){const t={};for(const e in n.inputs){const s=n.inputs[e];r[s.id]&&(t[e]=s)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,o.push(e)}}return o}(this.state.activeTape,e,s);if(!r&&0===i.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const t={};t[s.id]=null==n?function(t){const e=pm(Hf(t),"float32");return Pv.makeTensor(e,t,"float32")}(s.shape):n,function(t,e,n,r){for(let s=e.length-1;s>=0;s--){const i=e[s],a=[];if(i.outputs.forEach((e=>{const n=t[e.id];null!=n?a.push(n):a.push(null)})),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const e in i.inputs){if(!(e in o))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(o)}.`);const s=n((()=>o[e]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${s.dtype}'`);const a=i.inputs[e];if(!jf(s.shape,a.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${e}' has shape '${s.shape}', which does not match the shape of the input '${a.shape}'`);if(null==t[a.id])t[a.id]=s;else{const e=t[a.id];t[a.id]=r(e,s),e.dispose()}}}}(t,i,(t=>this.tidy(t)),$v);const r=e.map((e=>t[e.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((t=>{for(const e of t.saved)e.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(t){return Uf(lm(t),(()=>"The f passed in customGrad(f) must be a function.")),(...e)=>{let n;Uf(e.every((t=>t instanceof xv)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return e.forEach(((t,e)=>{r[e]=t})),this.runKernelFunc({forwardFunc:(r,s)=>(n=t(...e,s),Uf(n.value instanceof xv,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Uf(lm(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(t,r)=>{const s=n.gradFunc(t,r),i=Array.isArray(s)?s:[s];Uf(i.length===e.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Uf(i.every((t=>t instanceof xv)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const a={};return i.forEach(((t,e)=>{a[e]=()=>t})),a},inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=nv(),n=await this.backend.time(t);return n.wallMs=nv()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Dv;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Fv(){const t=Mm();if(null==t._tfengine){const e=new bm(t);t._tfengine=new Lv(e)}var e;return e=t._tfengine.ENV,Tm=e,fv=()=>t._tfengine,t._tfengine}Lv.nextTensorId=0,Lv.nextVariableId=0;const Pv=Fv();function $v(t,e){const n={a:t,b:e};return Pv.runKernel(Am,n)}function Ov(t){if(t||"undefined"!=typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||("undefined"!=typeof window?window.opera:"");if(!e){const e=t;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function zv(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const Bv=Sm();function Uv(t,e){let n=t;if(rm(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||rm(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&Sm().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Wv(t,r,[]),r}function Wv(t,e,n){if(n=n||[],!Array.isArray(t)&&!rm(t))return void Uf(0===e.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));Uf(e.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),Uf(t.length===e[0],(()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const r=e.slice(1);for(let e=0;e<t.length;++e)Wv(t[e],r,n.concat(e))}function Vv(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function Gv(t,e,n,r="numeric"){if(t instanceof xv)return Vv(r,t.dtype,e,n),t;let s=om(t);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Vv(r,s,e,n),null==t||!rm(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const i=Uv(t,s);rm(t)||Array.isArray(t)||(t=[t]);const a="string"!==s?ev(t,s):Gf(t,[],!0);return Pv.makeTensor(a,i,s)}function Hv(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,s)=>Gv(t,`${e}[${s}]`,n,r)))}function jv(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const s=(...t)=>{Pv.startScope(n);try{const e=r(...t);return vm(e)&&console.error("Cannot return a Promise inside of tidy."),Pv.endScope(e),e}catch(t){throw Pv.endScope(null),t}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}Bv.registerFlag("DEBUG",(()=>!1),(t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Bv.registerFlag("IS_BROWSER",(()=>zv())),Bv.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),Bv.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Bv.registerFlag("PROD",(()=>!1)),Bv.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Bv.getBool("DEBUG"))),Bv.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Bv.registerFlag("IS_TEST",(()=>!1)),Bv.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),Bv.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Bv.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const qv=jv({complex_:function(t,e){const n=Gv(t,"real","complex"),r=Gv(e,"imag","complex");Wf(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return Pv.runKernel(Zm,s)}});function Xv(t,e,n,r){if(null==r&&(r=om(t)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!rm(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){gm(e);const t=Hf(e),r=Hf(n);Uf(t===r,(()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`));for(let t=0;t<n.length;++t){const r=n[t],s=t!==n.length-1||r!==Hf(e.slice(t));Uf(n[t]===e[t]||!s,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `))}}return rm(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==r?ev(t,r):Gf(t,[],!0),Pv.makeTensor(t,e,r)}function Kv(t,e,n){return Xv(t,e,Uv(t,n),n)}async function Yv(t,e){const n=[],r=[],s=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);for(let i=0;i<s.length;++i){const a=s[i],o=Array.isArray(t)?t[i].tensor:t[a];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${o.dtype}`);const l={name:a,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const t=new Promise((async t=>{const e=await o.bytes(),n=e.reduce(((t,e)=>t+e.length),0)+4*e.length,r=new Uint8Array(n);let s=0;for(let t=0;t<e.length;t++){const n=e[t],i=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(i,s),s+=4,r.set(n,s),s+=n.length}t(r)}));r.push(t)}else r.push(o.data());null!=e&&(l.group=e),n.push(l)}return{data:Jv(await Promise.all(r)),specs:n}}function Jv(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach((t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)}));const r=new Uint8Array(e);let s=0;return n.forEach((t=>{r.set(new Uint8Array(t.buffer),s),s+=t.byteLength})),r.buffer}const Zv="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Qv(t){return Zv?Buffer.byteLength(t):new Blob([t]).size}function tb(t){if(1===t.length)return t[0];let e=0;t.forEach((t=>{e+=t.byteLength}));const n=new Uint8Array(e);let r=0;return t.forEach((t=>{n.set(new Uint8Array(t),r),r+=t.byteLength})),n.buffer}function eb(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}function nb(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:Qv(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:Qv(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}class rb{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==rb.instance&&(rb.instance=new rb),rb.instance}static registerSaveRouter(t){rb.getInstance().saveRouters.push(t)}static registerLoadRouter(t){rb.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return rb.getHandlers(t,"save")}static getLoadHandlers(t,e){return rb.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?rb.getInstance().loadRouters:rb.getInstance().saveRouters).forEach((e=>{const s=e(t,n);null!==s&&r.push(s)})),r}}const sb="tensorflowjs",ib="models_store",ab="model_info_store";function ob(){if(!Sm().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function lb(t){const e=t.result;e.createObjectStore(ib,{keyPath:"modelPath"}),e.createObjectStore(ab,{keyPath:"modelPath"})}class ub{constructor(t){if(this.indexedDB=ob(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise(((t,n)=>{const r=this.indexedDB.open(sb,1);r.onupgradeneeded=()=>lb(r),r.onsuccess=()=>{const s=r.result;if(null==e){const e=s.transaction(ib,"readonly"),r=e.objectStore(ib).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(s.close(),n(r.error)),e.oncomplete=()=>s.close()}else{const r=nb(e),i=s.transaction(ab,"readwrite");let a=i.objectStore(ab);const o=a.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;o.onsuccess=()=>{l=s.transaction(ib,"readwrite");const o=l.objectStore(ib).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});o.onsuccess=()=>t({modelArtifactsInfo:r}),o.onerror=t=>{a=i.objectStore(ab);const e=a.delete(this.modelPath);e.onsuccess=()=>(s.close(),n(o.error)),e.onerror=t=>(s.close(),n(o.error))}},o.onerror=t=>(s.close(),n(o.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},r.onerror=t=>n(r.error)}))}}ub.URL_SCHEME="indexeddb://";const cb=t=>{return Sm().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ub.URL_SCHEME)?(e=t.slice(ub.URL_SCHEME.length),new ub(e)):null;var e};rb.registerSaveRouter(cb),rb.registerLoadRouter(cb);class hb{constructor(){this.indexedDB=ob()}async listModels(){return new Promise(((t,e)=>{const n=this.indexedDB.open(sb,1);n.onupgradeneeded=()=>lb(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(ab,"readonly"),i=s.objectStore(ab).getAll();i.onsuccess=()=>{const e={};for(const t of i.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},i.onerror=t=>(r.close(),e(i.error)),s.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)}))}async removeModel(t){var e;return t=(e=t).startsWith(ub.URL_SCHEME)?e.slice(ub.URL_SCHEME.length):e,new Promise(((e,n)=>{const r=this.indexedDB.open(sb,1);r.onupgradeneeded=()=>lb(r),r.onsuccess=()=>{const s=r.result,i=s.transaction(ab,"readwrite"),a=i.objectStore(ab),o=a.get(t);let l;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=a.delete(t),i=()=>{l=s.transaction(ib,"readwrite");const r=l.objectStore(ib).delete(t);r.onsuccess=()=>e(o.result.modelArtifactsInfo),r.onerror=t=>n(o.error)};r.onsuccess=i,r.onerror=t=>(i(),s.close(),n(o.error))}},o.onerror=t=>(s.close(),n(o.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=t=>n(r.error)}))}}const db="/",pb="tensorflowjs_models",fb="info",mb="model_topology",gb="weight_specs",xb="weight_data",yb="model_metadata";function vb(t){return{info:[pb,t,fb].join(db),topology:[pb,t,mb].join(db),weightSpecs:[pb,t,gb].join(db),weightData:[pb,t,xb].join(db),modelMetadata:[pb,t,yb].join(db)}}function bb(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function wb(t){const e=t.split(db);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(db)}class Sb{constructor(t){if(!Sm().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=vb(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=nb(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(Zv)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let t=0,r=e.length;t<r;t++)n+=String.fromCharCode(e[t]);return btoa(n)}(t.weightData));const s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(t){throw bb(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const t=JSON.parse(s);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(Zv){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)n.set([e.charCodeAt(t)],t);return n.buffer}(i),e}}Sb.URL_SCHEME="localstorage://";const _b=t=>{return Sm().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Sb.URL_SCHEME)?(e=t.slice(Sb.URL_SCHEME.length),new Sb(e)):null;var e};rb.registerSaveRouter(_b),rb.registerLoadRouter(_b);class Tb{constructor(){Uf(Sm().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Uf("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const t={},e=pb+db,n=db+fb;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(e)&&s.endsWith(n)&&(t[wb(s)]=JSON.parse(this.LS.getItem(s)))}return t}async removeModel(t){var e;const n=vb(t=(e=t).startsWith(Sb.URL_SCHEME)?e.slice(Sb.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return bb(n),r}}class Mb{constructor(){this.managers={}}static getInstance(){return null==Mb.instance&&(Mb.instance=new Mb),Mb.instance}static registerManager(t,e){Uf(null!=t,(()=>"scheme must not be undefined or null.")),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),Uf(t.length>0,(()=>"scheme must not be an empty string."));const n=Mb.getInstance();Uf(null==n.managers[t],(()=>`A model store manager is already registered for scheme '${t}'.`)),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}class Eb{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(Sm().get("IS_BROWSER")){Sm().setPlatform("browser",new Eb);try{Mb.registerManager(Sb.URL_SCHEME,new Tb)}catch(t){}try{Mb.registerManager(ub.URL_SCHEME,new hb)}catch(t){}}let kb;function Ib(t,e="float32",n){return e=e||"float32",gm(t),new pv(t,e,n)}Sm().get("IS_NODE")&&!Sm().get("IS_BROWSER")&&Sm().setPlatform("node",new class{constructor(){this.util=n(8628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=Sm().global.fetch?Sm().global.fetch(t,e):(null==kb&&(kb=n(5410)),kb(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const Cb=jv({cast_:function(t,e){const n=Gv(t,"x","cast");if(!function(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:e};return Pv.runKernel(Km,r,s)}}),Ab=jv({clone_:function(t){const e={x:Gv(t,"x","clone","string_or_numeric")};return Pv.runKernel(Bg,e)}});function Rb(t){return new Promise((t=>setTimeout(t))).then(t)}Fv(),mv={buffer:Ib,cast:Cb,clone:Ab,print:function(t,e=!1){console.log(t.toString(e))}};class Nb{constructor(t){if(!Sm().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Nb.URL_SCHEME)&&(t=t.slice(Nb.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=eb(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await Rb((()=>s.dispatchEvent(new MouseEvent("click")))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await Rb((()=>t.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:nb(t)}}}}function Db(t,e,n,r){!function(t){Uf(null!=t&&Array.isArray(t)&&t.length>0,(()=>"promises must be a none empty array"))}(t),function(t,e){Uf(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`)),Uf(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`)),Uf(e>=t,(()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(t.map((i=>(i.then((i=>{const a=n+ ++s/t.length*(r-n);return e(a),i})),i))))}async function Lb(t,e){null==e&&(e={});const n=null==e.fetchFunc?Sm().platform.fetch:e.fetchFunc,r=t.map((t=>n(t,e.requestInit,{isBinary:!0}))),s=(null==e.onProgress?await Promise.all(r):await Db(r,e.onProgress,0,.5)).map((t=>t.arrayBuffer()));return null==e.onProgress?await Promise.all(s):await Db(s,e.onProgress,.5,1)}Nb.URL_SCHEME="downloads://",rb.registerSaveRouter((t=>Sm().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Nb.URL_SCHEME)?function(t="model"){return new Nb(t)}(t.slice(Nb.URL_SCHEME.length)):null));class Fb{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(Uf("function"==typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Sm().platform.fetch,Uf(null!=t&&t.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(t)&&Uf(2===t.length,(()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`)),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=eb(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:nb(t),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return async function(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),null!=t.weightsManifest){const[r,s]=await e(t.weightsManifest);n.weightSpecs=r,n.weightData=s}return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),n}(e,(t=>this.loadWeights(t)))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),s=this.weightPathPrefix||n,i=[];for(const e of t)i.push(...e.weights);const a=[],o=[];for(const e of t)for(const t of e.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(t)):a.push(s+t+r);return this.weightUrlConverter&&a.push(...await Promise.all(o)),[i,tb(await Lb(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function Pb(t){return null!=t.match(Fb.URL_SCHEME_REGEX)}Fb.URL_SCHEME_REGEX=/^https?:\/\//;const $b=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every((t=>Pb(t))):Pb(t),n)return function(t,e){return new Fb(t,e)}(t,e)}return null};function Ob(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const i=n-1-s,a=t[i]||1;(e[e.length-1-s]||1)>1&&1===a&&r.unshift(i)}return r}function zb(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],i=e.length-r-1,a=e[i];(null==s||1===s&&a>1)&&n.unshift(i)}return n}function Bb(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let r=t[t.length-s-1];null==r&&(r=1);let i=e[e.length-s-1];if(null==i&&(i=1),1===r)n.unshift(i);else if(1===i)n.unshift(r);else{if(r!==i)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(r)}}return n}function Ub(t,e,n){const r=t.shape.length;Uf(r===e.length,(()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`)),Uf(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)Uf(e[s]+n[s]<=t.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+n[s]}) would overflow input.shape[${s}] (${t.shape[s]})`))}function Wb(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function Vb(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function Gb(t,e,n,r){const s=[...t];for(let t=s.length;t<r.length;t++)s.push(1);for(let t=0;t<n;t++)0===t?s[e]=1:(s.splice(e,0,1),s.pop());return s}function Hb(t,e,n){return n<=t?n:n-(e-1)}function jb(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function qb(t,e,n,r,s,i,a,o,l){const u=t.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&n>0){const l=e[0],u=n+1;c=Xb(a,l,u,r,t),h=Kb(o,l,u,s,t),d=Gb(i,l,u,t)}else for(let e=0;e<u;e++)c[e]=Jb(a,r,i,t,e,l),h[e]=Zb(o,s,i,t,e,l),d[e]=Yb(i,e,l);return{begin:c,end:h,strides:d}}function Xb(t,e,n,r,s){const i=[...s],a=jb(n,e);for(let s=0;s<i.length;s++)if(a.indexOf(s)>-1)i[s]=0;else{const a=Hb(e,n,s);let o=r[a];t&1<<a&&(o=0),i[s]=o}return i}function Kb(t,e,n,r,s){const i=[...s],a=jb(n,e);for(let s=0;s<i.length;s++)if(a.indexOf(s)>-1)i[s]=Number.MAX_SAFE_INTEGER;else{const a=Hb(e,n,s);let o=r[a];t&1<<a&&(o=Number.MAX_SAFE_INTEGER),i[s]=o}for(let t=0;t<i.length;t++){const e=s[t];i[t]<0&&(i[t]+=e),i[t]=Of(0,i[t],s[t])}return i}function Yb(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function Jb(t,e,n,r,s,i){let a=e[s];const o=n[s]||1;(t&1<<s||i&1<<s||null==a)&&(a=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return a<0&&(a+=l),a=Of(0,a,l-1),a}function Zb(t,e,n,r,s,i){let a=e[s];const o=n[s]||1;(t&1<<s||i&1<<s||null==a)&&(a=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return a<0&&(a+=l),a=o>0?Of(0,a,l):Of(-1,a,l-1),a}function Qb(t,e,n){let r=n.length;for(let t=0;t<n.length;t++)if(n[t]>1){r=t;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function tw(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function ew(t,e,n){let r;const s=t.shape.length;let i;return r="number"==typeof e?[e,...new Array(s-1).fill(0)]:e.length<s?e.concat(new Array(s-e.length).fill(0)):e.slice(),r.forEach((t=>{Uf(-1!==t,(()=>"slice() does not support negative begin indexing."))})),i=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,i=i.map(((e,n)=>e>=0?e:(Uf(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`)),t.shape[n]-r[n]))),[r,i]}function nw(t,e,n,r,s,i,a,o,l){let u;if(null==r?(u=new Array(e.length),u.fill(1)):u=r,null!=a&&0!=(a&a-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let t=0;t<h.dims;t++)c&&0!=(1<<t&o)&&h.numAddAxisAfterEllipsis++,1<<t&a&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=null!=t.begin,e.endValid=null!=t.end,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(-2),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);null!=t.begin&&(e.begin[n]=t.begin[r]),null!=t.end&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(-1),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],x=[];for(let e=0;e<t.length;++e){if(0===d.strides[e])throw Error(`strides[${e}] must be non-zero`);const n=!!(d.shrinkAxisMask&1<<e),r=t[e];if(-1===r){g.push(n?1:-1);continue}const s=[d.beginMask&1<<e,d.endMask&1<<e],i=[d.strides[e]>0?0:-1,d.strides[e]>0?r:r-1];if(n&&d.strides[e]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[e];const a=!!(d.beginMask&1<<e&&d.endMask&1<<e);if(d.beginValid&&d.endValid){if(n){const t=d.begin[e]<0?r+d.begin[e]:d.begin[e];if(d.begin[e]=t,d.end[e]=d.begin[e]+1,t<0||t>=r)throw Error(`slice index ${d.begin[e]} of dimension ${e} out of bounds.`)}else d.begin[e]=rw(d.begin[e],0,d.strides[e],r,s,i),d.end[e]=rw(d.end[e],1,d.strides[e],r,s,i);const t=1===d.strides[e]&&0===d.begin[e]&&d.end[e]===r;p=p&&t,f=f&&(0===e&&1===d.strides[e]||t)}else p=p&&1===d.strides[e]&&a,f=f&&(0===e&&1===d.strides[e]||a);let o,l=!1;if(d.beginValid&&d.endValid?(o=d.end[e]-d.begin[e],l=!0):n?(o=1,l=!0):a&&r>=0&&(o=d.strides[e]<0?-r:r,l=!0),l){let t;t=0===o||o<0!=d.strides[e]<0?0:Math.trunc(o/d.strides[e])+(o%d.strides[e]!=0?1:0),g.push(t)}else g.push(-1)}for(let t=0;t<d.finalShapeGatherIndices.length;++t){const e=d.finalShapeGatherIndices[t];e>=0?x.push(g[e]):-2===e&&x.push(1)}return{finalShapeSparse:x.filter(((t,e)=>-2!==d.finalShapeGatherIndices[e])),finalShape:x,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function rw(t,e,n,r,s,i){if(s[e])return n>0?i[e]:i[e+1&1];{const e=t<0?r+t:t;return e<i[0]?i[0]:e>i[1]?i[1]:e}}rb.registerSaveRouter($b),rb.registerLoadRouter($b);class sw{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class iw{constructor(){this.classNameMap={}}static getMap(){return null==iw.instance&&(iw.instance=new iw),iw.instance}static register(t){iw.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function aw(t){Uf(null!=t.className,(()=>"Class being registered does not have the static className property defined.")),Uf("string"==typeof t.className,(()=>"className is required to be a string, but got type "+typeof t.className)),Uf(t.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),iw.register(t)}function ow(){return Pv}function lw(){return Pv.memory()}function uw(t,e){return Pv.tidy(t,e)}function cw(t){Av(t).forEach((t=>t.dispose()))}function hw(t){return Pv.keep(t)}function dw(t,e,n=1){return Pv.registerBackend(t,e,n)}function pw(){return Pv.backend}function fw(t){return Pv.customGrad(t)}function mw(t,e){if((rm(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&rm(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Xv(t,[],[],e)}gv=function(t){Sm().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};class gw extends sw{minimize(t,e=!1,n){const{value:r,grads:s}=this.computeGradients(t,n);if(null!=n){const t=n.map((t=>({name:t.name,tensor:s[t.name]})));this.applyGradients(t)}else this.applyGradients(s);return cw(s),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function(t,e){Uf(lm(t),(()=>"The f passed in variableGrads(f) must be a function")),Uf(null==e||Array.isArray(e)&&e.every((t=>t instanceof vv)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=e;if(!n){e=[];for(const t in Pv.registeredVariables)e.push(Pv.registeredVariables[t])}const r=n?e.filter((t=>!t.trainable)):null,s=e.length;Uf((e=e.filter((t=>t.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const{value:i,grads:a}=Pv.gradients(t,e,null,!0);Uf(a.some((t=>null!=t)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Uf(0===i.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));const o={};return e.forEach(((t,e)=>{null!=a[e]&&(o[t.name]=a[e])})),null!=r&&r.forEach((t=>o[t.name]=null)),{value:i,grads:o}}(t,e)}dispose(){null!=this.iterations_&&cw(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:mw(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(gw,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});const xw=jv({abs_:function(t){const e=Gv(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return Pv.runKernel(Qm,t)}{const t={x:e};return Pv.runKernel(km,t)}}}),yw=jv({add_:function(t,e){let n=Gv(t,"a","add"),r=Gv(e,"b","add");[n,r]=Iv(n,r);const s={a:n,b:r};return Pv.runKernel(Am,s)}}),vw=jv({all_:function(t,e=null,n=!1){const r={x:Gv(t,"x","all","bool")},s={axis:e,keepDims:n};return Pv.runKernel(Nm,r,s)}}),bw=jv({any_:function(t,e=null,n=!1){const r={x:Gv(t,"x","any","bool")},s={axis:e,keepDims:n};return Pv.runKernel(Dm,r,s)}}),ww=jv({argMax_:function(t,e=0){const n={x:Gv(t,"x","argMax")},r={axis:e};return Pv.runKernel(Lm,n,r)}});function Sw(t,e,n,r,s="NHWC",i){return Mw(t,[...e,t[3]],n,i,r,null,null,Lw(s))}function _w(t,e,n,r,s,i,a="channelsLast"){const[o,l]=Iw(e);let u;if("channelsLast"===a)u=[o,l,t[3],t[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);u=[o,l,t[1],t[1]]}return Mw(t,u,n,r,s,i,!1,a)}function Tw(t,e,n,r,s,i,a="NDHWC"){const[o,l,u]=Cw(e);let c,h;if("NDHWC"===a)h="channelsLast",c=[o,l,u,t[4],t[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);h="channelsFirst",c=[o,l,u,t[1],t[1]]}return Ew(t,c,n,r,s,!1,h,i)}function Mw(t,e,n,r,s,i,a=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=t;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=t}const[d,p,,f]=e,[m,g]=Iw(n),[x,y]=Iw(r),v=Aw(d,x),b=Aw(p,y),{padInfo:w,outHeight:S,outWidth:_}=function(t,e,n,r,s,i,a,o,l){let u,c,h;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,s){null==r&&(r=kw(t,e,n));const i=t[1];return[Rw((t[0]-e+2*r)/n+1,s),Rw((i-e+2*r)/n+1,s)]}([e,n],i,r,t,o);c=s[0],h=s[1]}else if("same"===t){c=Math.ceil(e/r),h=Math.ceil(n/s);const t=Math.max(0,(c-1)*r+i-e),o=Math.max(0,(h-1)*s+a-n),l=Math.floor(t/2),d=t-l,p=Math.floor(o/2);u={top:l,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/r),h=Math.ceil((n-a+1)/s);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const d="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],f="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Rw((e-i+d+p)/r+1,o),h=Rw((n-a+f+m)/s+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(s,u,c,m,g,v,b,i,o),T=a?f*h:f;let M;return"channelsFirst"===o?M=[l,T,S,_]:"channelsLast"===o&&(M=[l,S,_,T]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:S,outWidth:_,outChannels:T,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:b,dilationHeight:x,dilationWidth:y,inShape:t,outShape:M,filterShape:e}}function Ew(t,e,n,r,s,i=!1,a="channelsLast",o){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,h,d]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c,h]=t}const[p,f,m,,g]=e,[x,y,v]=Cw(n),[b,w,S]=Cw(r),_=Aw(p,b),T=Aw(f,w),M=Aw(m,S),{padInfo:E,outDepth:k,outHeight:I,outWidth:C}=function(t,e,n,r,s,i,a,o,l,u,c){let h,d,p,f;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const i=function(t,e,n,r,s,i){null==s&&(s=kw(t,e,r));const a=t[1],o=t[2];return[Rw((t[0]-e+2*s)/r+1,i),Rw((a-e+2*s)/r+1,i),Rw((o-e+2*s)/r+1,i),1]}([e,n,r,1],o,0,s,t,c);d=i[0],p=i[1],f=i[2]}else if("same"===t){d=Math.ceil(e/s),p=Math.ceil(n/i),f=Math.ceil(r/a);const t=(d-1)*s+o-e,c=(p-1)*i+l-n,m=(f-1)*a+u-r,g=Math.floor(t/2),x=t-g,y=Math.floor(c/2),v=c-y,b=Math.floor(m/2);h={top:y,bottom:v,left:b,right:m-b,front:g,back:x,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-o+1)/s),p=Math.ceil((n-l+1)/i),f=Math.ceil((r-u+1)/a)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,u,c,h,x,y,v,_,T,M,o),A=i?g*d:g;let R;return"channelsFirst"===a?R=[l,A,k,I,C]:"channelsLast"===a&&(R=[l,k,I,C,A]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:k,outHeight:I,outWidth:C,outChannels:A,padInfo:E,strideDepth:x,strideHeight:y,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:_,effectiveFilterHeight:T,effectiveFilterWidth:M,dilationDepth:b,dilationHeight:w,dilationWidth:S,inShape:t,outShape:R,filterShape:e}}function kw(t,e,n,r=1){const s=Aw(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function Iw(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function Cw(t){return"number"==typeof t?[t,t,t]:t}function Aw(t,e){return e<=1?t:t+(t-1)*(e-1)}function Rw(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Nw(t){const[e,n,r]=Iw(t);return 1===e&&1===n&&1===r}function Dw(t,e){return Nw(t)||Nw(e)}function Lw(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function Fw(t,e,n){if(null!=n){if("string"==typeof e)throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if("number"==typeof e)Uf(qf(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`));else{if("object"!=typeof e)throw Error(`Error in ${t}: Unknown padding parameter: ${e}`);e.forEach((e=>{e.forEach((e=>{Uf(qf(e),(()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`))}))}))}}}const Pw=jv({reshape_:function(t,e){const n={x:Gv(t,"x","reshape","string_or_numeric")},r={shape:e};return Pv.runKernel(Dx,n,r)}}),$w=jv({avgPool_:function(t,e,n,r,s){const i=Gv(t,"x","avgPool","float32");Uf(Dw(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let a=i,o=!1;3===i.rank&&(o=!0,a=Pw(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Uf(4===a.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`)),Fw("avgPool",r,s);const l={x:a},u={filterSize:e,strides:n,pad:r,dimRoundingMode:s};let c=Pv.runKernel(Um,l,u);return c=Cb(c,i.dtype),o?Pw(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Ow=jv({avgPool3d_:function(t,e,n,r,s,i="NDHWC"){const a=Gv(t,"x","avgPool3d","float32");let o=a,l=!1;4===a.rank&&(l=!0,o=Pw(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Uf(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),Uf("NDHWC"===i,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`)),Fw("avgPool3d",r,s);const u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:i};let h=Pv.runKernel(Vm,u,c);return h=Cb(h,o.dtype),l?Pw(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),zw=jv({batchNorm_:function(t,e,n,r,s,i){null==i&&(i=.001);const a=Gv(t,"x","batchNorm"),o=Gv(e,"mean","batchNorm"),l=Gv(n,"variance","batchNorm");let u,c;null!=s&&(u=Gv(s,"scale","batchNorm")),null!=r&&(c=Gv(r,"offset","batchNorm")),Uf(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Uf(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Uf(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h=function(t){let e;return e=0===t.rank||1===t.rank?Pw(t,[1,1,1,t.size]):2===t.rank?Pw(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?Pw(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(a),d={x:h,scale:u,offset:c,mean:o,variance:l},p={varianceEpsilon:i},f=Pv.runKernel(Fg,d,p);return Pw(f,a.shape)}}),Bw=jv({batchNorm2d_:function(t,e,n,r,s,i){const a=Gv(t,"x","batchNorm"),o=Gv(e,"mean","batchNorm"),l=Gv(n,"variance","batchNorm");let u,c;return null!=s&&(u=Gv(s,"scale","batchNorm")),null!=r&&(c=Gv(r,"offset","batchNorm")),Uf(2===a.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`)),Uf(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),Uf(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&Uf(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&Uf(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),zw(a,o,l,c,u,i)}}),Uw=jv({batchNorm3d_:function(t,e,n,r,s,i){const a=Gv(t,"x","batchNorm"),o=Gv(e,"mean","batchNorm"),l=Gv(n,"variance","batchNorm");let u,c;return null!=s&&(u=Gv(s,"scale","batchNorm")),null!=r&&(c=Gv(r,"offset","batchNorm")),Uf(3===a.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`)),Uf(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),Uf(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&Uf(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&Uf(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),zw(a,o,l,c,u,i)}}),Ww=jv({batchNorm4d_:function(t,e,n,r,s,i){const a=Gv(t,"x","batchNorm"),o=Gv(e,"mean","batchNorm"),l=Gv(n,"variance","batchNorm");let u,c;return null!=s&&(u=Gv(s,"scale","batchNorm")),null!=r&&(c=Gv(r,"offset","batchNorm")),Uf(4===a.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`)),Uf(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),Uf(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&Uf(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&Uf(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),zw(a,o,l,c,u,i)}}),Vw=jv({clipByValue_:function(t,e,n){const r=Gv(t,"x","clipByValue");Uf(e<=n,(()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`));const s={x:r},i={clipValueMin:e,clipValueMax:n};return Pv.runKernel(Jm,s,i)}}),Gw=jv({concat_:function(t,e=0){Uf(t.length>=1,(()=>"Pass at least one tensor to concat"));const n=Hv(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)})),1===n.length)return Ab(n[0]);const r=n,s={axis:e};return Pv.runKernel(tg,r,s)}}),Hw=jv({concat1d_:function(t){return Gw(t,0)}}),jw=jv({concat2d_:function(t,e){return Gw(t,e)}}),qw=jv({concat3d_:function(t,e){return Gw(t,e)}}),Xw=jv({concat4d_:function(t,e){return Gw(t,e)}}),Kw=jv({conv2d_:function(t,e,n,r,s="NHWC",i=[1,1],a){const o=Gv(t,"x","conv2d","float32"),l=Gv(e,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Pw(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Uf(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),Uf(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Fw("conv2d",r,a);const h="NHWC"===s?u.shape[3]:u.shape[1];Uf(h===l.shape[2],(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`)),Uf(Dw(n,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`));const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:a},f=Pv.runKernel(eg,d,p);return c?Pw(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Yw=jv({conv1d_:function(t,e,n,r,s="NWC",i=1,a){const o=Gv(t,"x","conv1d"),l=Gv(e,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=Pw(o,[1,o.shape[0],o.shape[1]])),Uf(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),Uf(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Fw("conv1d",r,a),Uf(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),Uf(Dw(n,i),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`)),Uf("NWC"===s,(()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`));const h=Pw(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=Pw(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=Kw(d,h,[1,n],r,"NHWC",[1,i],a);return Pw(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),Jw=jv({conv2DBackpropInput_:function(t,e,n,r,s,i="NHWC",a){Uf(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let o=t,l=e,u=!1;3===e.rank&&(u=!0,l=Pw(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,t[0],t[1],t[2]]),Uf(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),Uf(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),Uf(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===i?o[3]:o[1],h="NHWC"===i?l.shape[3]:l.shape[1];Uf(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),Uf(h===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`)),Fw("conv2dDerInput",s,a);const d={dy:l,filter:n},p={strides:r,pad:s,dataFormat:i,dimRoundingMode:a,inputShape:o},f=Pv.runKernel(rg,d,p);return u?Pw(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Zw=jv({conv2dTranspose_:function(t,e,n,r,s,i){const a=Gv(t,"x","conv2dTranspose"),o=Gv(e,"filter","conv2dTranspose");return Jw(n,a,o,r,s,"NHWC",i)}}),Qw=jv({conv3d_:function(t,e,n,r,s="NDHWC",i=[1,1,1]){const a=Gv(t,"x","conv3d"),o=Gv(e,"filter","conv3d");let l=a,u=!1;4===a.rank&&(u=!0,l=Pw(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Uf(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),Uf(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),Uf(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),Uf(Dw(n,i),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),Uf("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`));const c={x:l,filter:o},h={strides:n,pad:r,dataFormat:s,dilations:i},d=Pv.runKernel(sg,c,h);return u?Pw(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),tS=jv({conv3DBackpropInput_:function(t,e,n,r,s){Uf(t.length===e.rank,(()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`));let i=t,a=e,o=!1;4===e.rank&&(o=!0,a=Pw(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,t[0],t[1],t[2],t[3]]);const l=i[4],u=a.shape[4];Uf(5===i.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`)),Uf(5===a.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`)),Uf(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Uf(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),Uf(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:a,filter:n},h={pad:s,strides:r,inputShape:i},d=Pv.runKernel(ag,c,h);return o?Pw(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),eS=jv({conv3dTranspose_:function(t,e,n,r,s){const i=Gv(t,"x","conv3dTranspose"),a=Gv(e,"filter","conv3dTranspose");return tS(n,i,a,r,s)}}),nS=jv({depthwiseConv2d_:function(t,e,n,r,s="NHWC",i=[1,1],a){const o=Gv(t,"x","depthwiseConv2d","float32"),l=Gv(e,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Pw(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Uf(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),Uf(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`)),Uf(u.shape[3]===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Fw("depthwiseConv2d",r,a);const h={x:u,filter:l},d={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:a},p=Pv.runKernel(fg,h,d);return c?Pw(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),rS=jv({floorDiv_:function(t,e){let n=Gv(t,"a","floorDiv"),r=Gv(e,"b","floorDiv");[n,r]=Iv(n,r);const s={a:n,b:r};return Pv.runKernel(Lg,s)}}),sS=jv({div_:function(t,e){let n=Gv(t,"a","div"),r=Gv(e,"b","div");if([n,r]=Iv(n,r),"int32"===n.dtype&&"int32"===r.dtype)return rS(n,r);const s={a:n,b:r};return Pv.runKernel(wg,s,{})}}),iS=jv({elu_:function(t){const e={x:Gv(t,"x","elu","float32")};return Pv.runKernel(_g,e)}}),aS=jv({equal_:function(t,e){let n=Gv(t,"a","equal","string_or_numeric"),r=Gv(e,"b","equal","string_or_numeric");[n,r]=Iv(n,r),Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(Eg,s)}}),oS=jv({exp_:function(t){const e={x:Gv(t,"x","exp")};return Pv.runKernel(kg,e)}}),lS=jv({expandDims_:function(t,e=0){const n=Gv(t,"x","expandDims","string_or_numeric");Uf(e<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},s={dim:e};return Pv.runKernel(Ig,r,s)}}),uS=jv({tile_:function(t,e){const n=Gv(t,"x","tile","string_or_numeric");Uf(n.rank===e.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`));const r={x:n},s={reps:e};return Pv.runKernel(xy,r,s)}}),cS=jv({eye_:function(t,e,n,r="float32"){null==e&&(e=t);const s=Ib([t,e],r),i=t<=e?t:e;for(let t=0;t<i;++t)s.set(1,t,t);const a=Pw(s.toTensor(),[t,e]);if(null==n)return a;if(1===n.length)return uS(lS(a,0),[n[0],1,1]);if(2===n.length)return uS(lS(lS(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return uS(lS(lS(lS(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});function hS(t,e,n){const r={shape:t,value:e,dtype:n};return Pv.runKernel(Rg,{},r)}const dS=jv({floor_:function(t){const e={x:Gv(t,"x","floor","float32")};return Pv.runKernel(Dg,e)}}),pS=jv({gather_:function(t,e,n=0,r=0){const s={x:Gv(t,"x","gather"),indices:Gv(e,"indices","gather","int32")},i={axis:n,batchDims:r};return Pv.runKernel(Pg,s,i)}}),fS=jv({greater_:function(t,e){let n=Gv(t,"a","greater","string_or_numeric"),r=Gv(e,"b","greater","string_or_numeric");[n,r]=Iv(n,r),Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(Og,s)}}),mS=jv({greaterEqual_:function(t,e){let n=Gv(t,"a","greaterEqual","string_or_numeric"),r=Gv(e,"b","greaterEqual","string_or_numeric");[n,r]=Iv(n,r),Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(zg,s)}}),gS=jv({leakyRelu_:function(t,e=.2){const n={x:Gv(t,"x","leakyRelu")},r={alpha:e};return Pv.runKernel(jg,n,r)}}),xS=jv({log_:function(t){const e={x:Gv(t,"x","log","float32")};return Pv.runKernel(Yg,e)}}),yS=jv({log1p_:function(t){const e={x:Gv(t,"x","log1p")};return Pv.runKernel(Jg,e)}}),vS=jv({max_:function(t,e=null,n=!1){const r={x:Gv(t,"x","max")},s={reductionIndices:e,keepDims:n};return Pv.runKernel(rx,r,s)}}),bS=jv({mul_:function(t,e){let n=Gv(t,"a","mul"),r=Gv(e,"b","mul");[n,r]=Iv(n,r);const s={a:n,b:r};return Pv.runKernel(gx,s)}}),wS=jv({sub_:function(t,e){let n=Gv(t,"a","sub"),r=Gv(e,"b","sub");[n,r]=Iv(n,r);const s={a:n,b:r};return Pv.runKernel(fy,s)}}),SS=jv({sum_:function(t,e=null,n=!1){let r=Gv(t,"x","sum");"bool"===r.dtype&&(r=Cb(r,"int32"));const s={x:r},i={axis:e,keepDims:n};return Pv.runKernel(Qx,s,i)}}),_S=jv({logSoftmax_:function(t,e=-1){const n=Gv(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);const r=fw(((t,n)=>{const r=vS(t,e,!0),s=wS(t,r),i=wS(Cb(s,"float32"),xS(SS(oS(s),e,!0)));return n([i]),{value:i,gradFunc:(t,n)=>{const[r]=n,s=oS(r);return wS(t,bS(SS(t,e,!0),s))}}}));return r(n)}}),TS=jv({logicalAnd_:function(t,e){const n=Gv(t,"a","logicalAnd","bool"),r=Gv(e,"b","logicalAnd","bool");Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(Zg,s)}}),MS=jv({matMul_:function(t,e,n=!1,r=!1){let s=Gv(t,"a","matMul"),i=Gv(e,"b","matMul");[s,i]=Iv(s,i);const a={a:s,b:i},o={transposeA:n,transposeB:r};return Pv.runKernel(Hm,a,o)}}),ES=jv({maxPool_:function(t,e,n,r,s){const i=Gv(t,"x","maxPool");let a=i,o=!1;3===i.rank&&(o=!0,a=Pw(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Uf(4===a.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`)),Uf(Dw(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),Fw("maxPool",r,s);const l={x:a},u={filterSize:e,strides:n,pad:r,dimRoundingMode:s},c=Pv.runKernel(ix,l,u);return o?Pw(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),kS=jv({maxPool3d_:function(t,e=[1,1,1],n,r,s,i="NDHWC"){const a=Gv(t,"x","maxPool3d");let o=a,l=!1;4===a.rank&&(l=!0,o=Pw(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),Uf(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),Uf("NDHWC"===i,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`)),Fw("maxPool3d",r,s);const u={x:o},c={filterSize:e,strides:n,pad:r,dimRoundingMode:s,dataFormat:i},h=Pv.runKernel(ox,u,c);return l?Pw(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),IS=jv({maximum_:function(t,e){let n=Gv(t,"a","maximum"),r=Gv(e,"b","maximum");[n,r]=Iv(n,r),"bool"===n.dtype&&(n=Cb(n,"int32"),r=Cb(r,"int32")),Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(sx,s)}}),CS=jv({mean_:function(t,e=null,n=!1){const r={x:Gv(t,"x","mean")},s={axis:e,keepDims:n};return Pv.runKernel(cx,r,s)}}),AS=jv({minimum_:function(t,e){let n=Gv(t,"a","minimum"),r=Gv(e,"b","minimum");[n,r]=Iv(n,r),"bool"===n.dtype&&(n=Cb(n,"int32"),r=Cb(r,"int32")),Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(dx,s)}});function RS(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function NS(t,e,n){const r=t.length+e.length,s=[];let i=0,a=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(t[i++]):s.push(e[a++]);return s}function DS(t,e){const n=[],r=t.length;for(let s=0;s<r;s++)-1===e.indexOf(s)&&n.push(t[s]);return[n,e.map((e=>t[e]))]}function LS(t,e){return NS(t,e.map((t=>1)),e)}function FS(t,e,n){Uf(RS(e,n),(()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`))}function PS(t,e){if(RS(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach((t=>n.push(t))),n}function $S(t){return t.map(((t,e)=>[e,t])).sort(((t,e)=>t[1]-e[1])).map((t=>t[0]))}function OS(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}const zS=jv({square_:function(t){const e=Gv(t,"x","square");return Pv.runKernel("Square",{x:e},{})}}),BS=jv({moments_:function(t,e=null,n=!1){const r=Zf(e,(t=Gv(t,"x","moments")).shape),s=CS(t,r,n);let i=s.shape;n||(i=LS(s.shape,r));const a=zS(wS(Cb(t,"float32"),Pw(s,i)));return{mean:s,variance:CS(a,r,n)}}}),US=jv({neg_:function(t){const e={x:Gv(t,"x","neg")};return Pv.runKernel(xx,e)}}),WS=jv({notEqual_:function(t,e){let n=Gv(t,"a","notEqual","string_or_numeric"),r=Gv(e,"b","notEqual","string_or_numeric");[n,r]=Iv(n,r),Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(yx,s)}}),VS=jv({oneHot_:function(t,e,n=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const s={indices:Gv(t,"indices","oneHot","int32")},i={depth:e,onValue:n,offValue:r};return Pv.runKernel(_x,s,i)}});function GS(t,e="float32"){if("complex64"===e){const e=GS(t,"float32"),n=GS(t,"float32");return qv(e,n)}const n=fm(Hf(t),e);return Pv.makeTensor(n,t,e)}function HS(t,e="float32"){if("complex64"===e){const e=HS(t,"float32"),n=GS(t,"float32");return qv(e,n)}const n=pm(Hf(t),e);return Pv.makeTensor(n,t,e)}const jS=jv({onesLike_:function(t){const e={x:Gv(t,"x","onesLike")};return Pv.runKernel(Sx,e)}}),qS=jv({pad_:function(t,e,n=0){const r=Gv(t,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:n},i={x:r};return Pv.runKernel(Mx,i,s)}}),XS=jv({prelu_:function(t,e){const n={x:Gv(t,"x","prelu"),alpha:Gv(e,"alpha","prelu")};return Pv.runKernel(kx,n)}});var KS=n(3129);class YS{constructor(t,e,n,r,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=s||Math.random();this.random=KS.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,s,i;do{r=2*this.random()-1,s=2*this.random()-1,i=r*r+s*s}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*r*a,e=this.mean+this.stdDev*s*a,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class JS{constructor(t=0,e=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=KS.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const ZS=jv({randomNormal_:function(t,e=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const i=new YS(e,n,r,!1,s),a=Ib(t,r);for(let t=0;t<a.values.length;t++)a.values[t]=i.nextValue();return a.toTensor()}}),QS=jv({randomUniform_:function(t,e=0,n=1,r="float32",s){const i=Ib(t,r),a=new JS(e,n,null,s);for(let t=0;t<i.values.length;t++)i.values[t]=a.nextValue();return i.toTensor()}}),t_=jv({relu_:function(t){const e={x:Gv(t,"x","relu")};return Pv.runKernel(Nx,e)}}),e_=jv({reverse_:function(t,e){const n={x:Gv(t,"x","reverse")},r={dims:e};return Pv.runKernel(zx,n,r)}}),n_=jv({selu_:function(t){const e={x:Gv(t,"x","selu")};return Pv.runKernel(Hx,e)}}),r_=jv({separableConv2d_:function(t,e,n,r,s,i=[1,1],a="NHWC"){const o=Gv(t,"x","separableConv2d"),l=Gv(e,"depthwiseFilter","separableConv2d"),u=Gv(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=Pw(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===a)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Uf(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),Uf(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),Uf(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),Uf(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),Uf(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const d=l.shape[2],p=l.shape[3];Uf(u.shape[2]===d*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`));const f=nS(c,l,r,s,a,i),m=Kw(f,u,1,"valid",a);return h?Pw(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),s_=jv({sigmoid_:function(t){const e={x:Gv(t,"x","sigmoid","float32")};return Pv.runKernel(Yx,e)}}),i_=jv({slice_:function(t,e,n){const r=Gv(t,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},i={begin:e,size:n};return Pv.runKernel(jx,s,i)}}),a_=jv({slice1d_:function(t,e,n){const r=Gv(t,"x","slice1d");return Uf(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),i_(r,[e],[n])}}),o_=jv({slice2d_:function(t,e,n){const r=Gv(t,"x","slice2d");return Uf(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),i_(r,e,n)}}),l_=jv({slice3d_:function(t,e,n){const r=Gv(t,"x","slice3d");return Uf(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),i_(r,e,n)}}),u_=jv({slice4d_:function(t,e,n){const r=Gv(t,"x","slice4d");return Uf(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),i_(r,e,n)}}),c_=jv({softmax_:function(t,e=-1){const n=Gv(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},s={dim:e};return Pv.runKernel(ny,r,s)}}),h_=jv({softplus_:function(t){const e={x:Gv(t,"x","softplus")};return Pv.runKernel(Jx,e)}}),d_=jv({split_:function(t,e,n=0){const r={x:Gv(t,"x","split")},s={numOrSizeSplits:e,axis:n};return Pv.runKernel(ey,r,s)}}),p_=jv({sqrt_:function(t){const e={x:Gv(t,"x","sqrt","float32")};return Pv.runKernel(Zx,e)}}),f_=jv({squeeze_:function(t,e){const n=Gv(t,"x","squeeze");return Pw(n,Qf(n.shape,e).newShape)}}),m_=jv({stack_:function(t,e=0){const n=Hv(t,"tensors","stack","string_or_numeric");Uf(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Uf(e<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,s={axis:e};return Pv.runKernel(Tx,r,s)}}),g_=jv({tanh_:function(t){const e={x:Gv(t,"x","tanh","float32")};return Pv.runKernel(gy,e)}});function x_(t,e){Vf(t);const n=Uv(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Xv(t,null,n,e)}const y_=jv({truncatedNormal_:function(t,e=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const i=new YS(e,n,r,!0,s),a=Ib(t,r);for(let t=0;t<a.values.length;t++)a.values[t]=i.nextValue();return a.toTensor()}}),v_=jv({unstack_:function(t,e=0){const n=Gv(t,"x","unstack","string_or_numeric");Uf(e>=-n.shape.length&&e<n.shape.length,(()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},s={axis:e};return Pv.runKernel(Sy,r,s)}}),b_=jv({broadcastTo_:function(t,e){let n=Gv(t,"broadcastTo","x");const r=n.shape;if(e.some((t=>!(t>0)||t%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=Pw(n,t)}const s=n.shape,i=Array.from(e);for(let t=e.length-1;t>=0;t--)if(s[t]===e[t])i[t]=1;else if(1!==n.shape[t])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(0===i.map(((t,e)=>t>1?e:-1)).filter((t=>t>=0)).length)return Ab(n);const a={x:n},o={reps:i};return Pv.runKernel(xy,a,o)}}),w_=jv({where_:function(t,e,n){const r=Gv(e,"a","where"),s=Gv(n,"b","where"),i=Gv(t,"condition","where","bool"),a=Bb(Bb(i.shape,r.shape),s.shape),o={condition:b_(i,a),t:b_(r,a),e:b_(s,a)};return Pv.runKernel(Gx,o)}}),S_=jv({zerosLike_:function(t){const e={x:Gv(t,"x","zerosLike")};return Pv.runKernel(Ty,e)}}),__=jv({imag_:function(t){const e={input:Gv(t,"input","imag")};return Pv.runKernel(Wg,e)}}),T_=jv({real_:function(t){const e={input:Gv(t,"input","real")};return Pv.runKernel(Ax,e)}}),M_=jv({transpose_:function(t,e,n){const r=Gv(t,"x","transpose");if(null==e&&(e=r.shape.map(((t,e)=>e)).reverse()),Uf(r.rank===e.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`)),e.forEach((t=>{Uf(t>=0&&t<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${e}`))})),r.rank<=1)return r.clone();const s={x:r},i={perm:e};return"complex64"===r.dtype?uw((()=>{let t=T_(r),e=__(r);return t=Pv.runKernel(by,{x:t},i),e=Pv.runKernel(by,{x:e},i),n&&(e=US(e)),qv(t,e)})):Pv.runKernel(by,s,i)}}),E_=jv({dropout_:function(t,e,n,r){const s=Gv(t,"x","dropout");if(Uf("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),Uf(e>=0&&e<1,(()=>`rate must be a float in the range [0, 1), but got ${e}.`)),0===e)return t instanceof xv?s.clone():s;const i=function(t,e){if(null==e)return t.shape.slice();if(jf(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(s,n),a=1-e,o=sS(dS(yw(QS(i,0,1,"float32",r),a)),a);return bS(s,o)}}),k_=jv({fft_:function(t){Uf("complex64"===t.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`));const e={input:t};return Pv.runKernel(Ag,e)}}),I_=jv({rfft_:function(t,e){Uf("float32"===t.dtype,(()=>`The dtype for rfft() must be real value but got ${t.dtype}`));let n=t.shape[t.shape.length-1];const r=t.size/n;let s;if(null!=e&&e<n){const r=t.shape.map((t=>0)),i=t.shape.map((t=>t));i[t.shape.length-1]=e,s=i_(t,r,i),n=e}else if(null!=e&&e>n){const r=t.shape.map((t=>t));r[t.shape.length-1]=e-n,s=Gw([t,GS(r)],t.shape.length-1),n=e}else s=t;const i=S_(s),a=Pw(qv(s,i),[r,n]),o=k_(a),l=Math.floor(n/2)+1,u=T_(o),c=__(o),h=d_(u,[l,n-l],u.shape.length-1),d=d_(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,Pw(qv(h[0],d[0]),p)}}),C_=jv({ifft_:function(t){Uf("complex64"===t.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`));const e={input:t};return Pv.runKernel(Ug,e)}}),A_=jv({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const s=Pw(t,[n,e]);r=C_(s)}else{const s=[n,2*(e-1)],i=Pw(T_(t),[n,e]),a=Pw(__(t),[n,e]),o=e_(i_(i,[0,1],[n,e-2]),1),l=bS(e_(i_(a,[0,1],[n,e-2]),1),mw(-1)),u=Gw([i,o],1),c=Gw([a,l],1),h=Pw(qv(u,c),[s[0],s[1]]);r=C_(h)}if(r=T_(r),3===t.rank&&0!==t.shape[0]){const e=r,n=t.shape[0];r=Pw(r,[n,r.shape[0]/n,r.shape[1]]),e.dispose()}return r}}),R_=jv({conv2DBackpropFilter_:function(t,e,n,r,s,i="NHWC",a){let o=t;3===t.rank&&(o=Pw(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=Pw(e,[1,e.shape[0],e.shape[1],e.shape[2]])),Uf(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),Uf(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),Uf(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===i?o.shape[3]:o.shape[1],c="NHWC"===i?l.shape[3]:l.shape[1];Uf(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),Uf(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),Fw("conv2dDerFilter",s,a);const h={x:o,dy:l},d={strides:r,pad:s,dataFormat:i,dimRoundingMode:a,filterShape:n};return Pv.runKernel(ng,h,d)}}),N_=jv({relu6_:function(t){const e={x:Gv(t,"x","relu6")};return Pv.runKernel(Ox,e)}}),D_=jv({step_:function(t,e=0){const n={x:Gv(t,"x","step")},r={alpha:e};return Pv.runKernel(My,n,r)}});function L_(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return bS(t,D_(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function F_(t,e){let n=e;const r=zb(t.shape,e.shape);return r.length>0&&(n=SS(n,r)),Pw(n,t.shape)}function P_(t,e,n,r){if("linear"===e)return t;if("relu"===e)return t_(t);if("elu"===e)return iS(t);if("relu6"===e)return N_(t);if("prelu"===e)return XS(t,n);if("leakyrelu"===e)return gS(t,r);if("sigmoid"===e)return s_(t);throw new Error(`Unknown fused activation ${e}.`)}const $_=(t,e)=>!(t>0)||"linear"===e,O_=jv({fusedConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",!1===$_(Pv.state.gradientDepth,l)){Uf("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let h=Kw(t,e,n,r,s,i,a);return null!=o&&(h=yw(h,o)),P_(h,l,u,c)}const h=Gv(t,"x","conv2d","float32"),d=Gv(e,"filter","conv2d","float32");let p=h,f=!1;3===h.rank&&(f=!0,p=Pw(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Uf(4===p.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`)),Uf(4===d.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`)),Fw("fused conv2d",r,a);const m="NHWC"===s?p.shape[3]:p.shape[1];Uf(d.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`)),Uf(Dw(n,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`));const g=Mw(p.shape,d.shape,n,i,r,a);let x,y;if(null!=o&&(x=Gv(o,"bias","fused conv2d"),[x]=Iv(x,h),"NHWC"===s?Bb(g.outShape,x.shape):(Uf(x.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`)),Uf(0===x.shape.length||x.shape[0]===g.outChannels||1===x.shape[0],(()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${g.outChannels})`)))),null!=u){const t=u.shape;if(Uf(t.length<=1||3===t.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${t.length}.`)),1===t.length)Uf(1===t[0]||t[0]===g.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${t}) is not compatible with the number of output channels (${g.outChannels}).`));else if(3===t.length)try{Bb(t,g.outShape)}catch(e){const n=`Error in fused conv2d: PReLU activation weights (${t}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(n)}y=Gv(u,"prelu weights","fused conv2d")}const v=(t,e)=>{Uf("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));const[a,o,u,c]=e,h=L_(t,u,l);Uf(Nw(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const d=[Jw(o.shape,h,a,n,r),R_(o,h,a.shape,n,r)];if(null!=c){const t=F_(c,h);d.push(t)}return d},b={x:p,filter:d,bias:x,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:c};if(null==o){const t=fw(((t,e,n)=>{let r=Pv.runKernel(Iy,b,w);return n([e,t,r]),f&&(r=Pw(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return t(p,d)}{const t=fw(((t,e,n,r)=>{let s=Pv.runKernel(Iy,b,w);return r([e,t,s,n]),f&&(s=Pw(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:v}}));return t(p,d,x)}}}),z_=jv({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,r,s,i=[1,1],a){let o=t;3===t.rank&&(o=Pw(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;3===l.rank&&(l=Pw(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:a,dilations:i,filterShape:n};return Pv.runKernel(mg,u,c)}}),B_=jv({depthwiseConv2dNativeBackpropInput_:function(t,e,n,r,s,i=[1,1],a){let o=e,l=!1;3===e.rank&&(l=!0,o=Pw(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:a,dilations:i,inputShape:t},h=Pv.runKernel(gg,u,c);return l?Pw(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});jv({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===$_(Pv.state.gradientDepth,l)){let h=nS(t,e,n,r,s,i,a);return null!=o&&(h=yw(h,o)),P_(h,l,u,c)}const h=Gv(t,"x","depthwiseConv2d","float32"),d=Gv(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;3===h.rank&&(f=!0,p=Pw(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Uf(4===p.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`)),Uf(4===d.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`)),Uf(p.shape[3]===d.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`)),null==i&&(i=[1,1]),Uf(Dw(n,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),Fw("fused depthwiseConv2d",r,a);const m=Mw(p.shape,d.shape,n,i,r,a,!0);let g,x;null!=o&&(g=Gv(o,"bias","fused conv2d"),[g]=Iv(g,h),Bb(m.outShape,g.shape)),null!=u&&(x=Gv(u,"prelu weights","fused depthwiseConv2d"));const y=(t,e)=>{Uf(Nw(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[s,o,u,c]=e,h=L_(t,u,l),d=B_(o.shape,h,s,n,r,i,a),p=z_(o,h,s.shape,n,r,i,a);return null!=c?[d,p,F_(g,h)]:[d,p]},v={x:p,filter:d,bias:g,preluActivationWeights:x},b={strides:n,pad:r,dataFormat:s,dilations:i,dimRoundingMode:a,activation:l,leakyreluAlpha:c};if(null==o){const t=fw(((t,e,n)=>{let r=Pv.runKernel(Cy,v,b);return n([e,t,r]),f&&(r=Pw(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}}));return t(p,d)}{const t=fw(((t,e,n,r)=>{let s=Pv.runKernel(Cy,v,b);return r([e,t,s,n]),f&&(s=Pw(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:y}}));return t(p,d,g)}}});const U_=jv({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o}){if(!1===$_(Pv.state.gradientDepth,i)){let l=MS(t,e,n,r);return null!=s&&(l=yw(l,s)),P_(l,i,a,o)}let l=Gv(t,"a","fused matMul"),u=Gv(e,"b","fused matMul");[l,u]=Iv(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=Hf(f),x=Hf(m);Uf(c===h,(()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));const y=Bb(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),v=Pw(l,n?[g,c,d]:[g,d,c]),b=Pw(u,r?[x,p,h]:[x,h,p]);let w,S;null!=s&&(w=Gv(s,"bias","fused matMul"),[w]=Iv(w,l),Bb(y,w.shape)),null!=a&&(S=Gv(a,"prelu weights","fused matMul"));const _=(t,e)=>{const[a,o,l,u]=e,c=L_(Pw(t,l.shape),l,i);let h,d;return n||r?!n&&r?(h=MS(c,o,!1,!1),d=MS(c,a,!0,!1)):n&&!r?(h=MS(o,c,!1,!0),d=MS(a,c,!1,!1)):(h=MS(o,c,!0,!0),d=MS(c,a,!0,!0)):(h=MS(c,o,!1,!0),d=MS(a,c,!0,!1)),null!=s?[h,d,F_(u,c)]:[h,d]},T={a:v,b,bias:w,preluActivationWeights:S},M={transposeA:n,transposeB:r,activation:i,leakyreluAlpha:o};if(null==s){const t=fw(((t,e,n)=>{const r=Pv.runKernel(ky,T,M);return n([t,e,r]),{value:Pw(r,y),gradFunc:_}}));return t(v,b)}{const t=fw(((t,e,n,r)=>{const s=Pv.runKernel(ky,T,M);return r([t,e,s,n]),{value:Pw(s,y),gradFunc:_}}));return t(v,b,w)}}});function W_(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let i=0;i<t;++i){const a=2*Math.PI*i/(t+r-1);s[i]=e-n*Math.cos(a)}return x_(s,"float32")}jv({hammingWindow_:function(t){return W_(t,.54,.46)}});const V_=jv({hannWindow_:function(t){return W_(t,.5,.5)}});function G_(t,e,n){if(Vf(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Uv(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Xv(t,e,r,n)}const H_=jv({frame_:function(t,e,n,r=!1,s=0){let i=0;const a=[];for(;i+e<=t.size;)a.push(i_(t,i,e)),i+=n;if(r)for(;i<t.size;){const r=i+e-t.size,o=Gw([i_(t,i,e-r),hS([r],s)]);a.push(o),i+=n}return 0===a.length?G_([],[0,e]):Pw(Gw(a),[a.length,e])}});jv({stft_:function(t,e,n,r,s=V_){var i;null==r&&(i=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(i)/Math.log(2)))));const a=H_(t,e,n),o=bS(a,s(e));return I_(o,r)}});const j_=jv({cropAndResize_:function(t,e,n,r,s="bilinear",i=0){const a=Gv(t,"image","cropAndResize"),o=Gv(e,"boxes","cropAndResize","float32"),l=Gv(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Uf(4===a.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`)),Uf(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),Uf(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),Uf(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Uf(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Uf("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const c={image:a,boxes:o,boxInd:l},h={method:s,extrapolationValue:i,cropSize:r};return Pv.runKernel(hg,c,h)}}),q_=jv({flipLeftRight_:function(t){const e=Gv(t,"image","flipLeftRight","float32");Uf(4===e.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`));const n={image:e};return Pv.runKernel(Ng,n,{})}}),X_=jv({grayscaleToRGB_:function(t){const e=Gv(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];Uf(e.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`)),Uf(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,uS(e,s)}}),K_=jv({rotateWithOffset_:function(t,e,n=0,r=.5){const s=Gv(t,"image","rotateWithOffset","float32");Uf(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const i={image:s},a={radians:e,fillValue:n,center:r};return Pv.runKernel(Ey,i,a)}});function Y_(t,e,n,r,s,i){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==i&&(i=0);const a=t.shape[0];return n=Math.min(n,a),Uf(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Uf(2===t.rank,(()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`)),Uf(4===t.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`)),Uf(1===e.rank,(()=>"scores must be a 1D tensor")),Uf(e.shape[0]===a,(()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`)),Uf(0<=i&&i<=1,(()=>`softNmsSigma must be in [0, 1], but was '${i}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}const J_=jv({nonMaxSuppression_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const i=Gv(t,"boxes","nonMaxSuppression","float32"),a=Gv(e,"scores","nonMaxSuppression","float32"),o=Y_(i,a,n,r,s),l={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold};return Pv.runKernel(vx,{boxes:i,scores:a},l)}});function Z_(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,s=t.length,i=0,a=!1;for(;r<s;){i=r+(s-r>>>1);const o=n(e,t[i]);o>0?r=i+1:(s=i,a=!o)}return a?r:-r-1}(t,e,n||Q_)}(t,e,n),s=r<0?-(r+1):r;t.splice(s,0,e)}function Q_(t,e){return t>e?1:t<e?-1:0}function tT(t,e,n,r,s){return rT(t,e,n,r,s,0)}function eT(t,e,n,r,s,i){return rT(t,e,n,r,s,0,!1,i,!0)}function nT(t,e,n,r,s,i){return rT(t,e,n,r,s,i,!0)}function rT(t,e,n,r,s,i,a=!1,o=!1,l=!1){const u=[];for(let t=0;t<e.length;t++)e[t]>s&&u.push({score:e[t],boxIndex:t,suppressBeginIndex:0});u.sort(aT);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<n&&u.length>0;){const e=u.pop(),{score:n,boxIndex:i,suppressBeginIndex:a}=e;if(n<s)break;let o=!1;for(let n=h.length-1;n>=a;--n){const a=sT(t,i,h[n]);if(a>=r){o=!0;break}if(e.score=e.score*iT(r,c,a),e.score<=s)break}e.suppressBeginIndex=h.length,o||(e.score===n?(h.push(i),d.push(e.score)):e.score>s&&Z_(u,e,aT))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return a&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function sT(t,e,n){const r=t.subarray(4*e,4*e+4),s=t.subarray(4*n,4*n+4),i=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-i)*(l-a),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(i,u),g=Math.max(a,c),x=Math.min(o,h),y=Math.min(l,d),v=Math.max(x-m,0)*Math.max(y-g,0);return v/(p+f-v)}function iT(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function aT(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}const oT=jv({nonMaxSuppressionWithScore_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const a=Gv(t,"boxes","nonMaxSuppression"),o=Gv(e,"scores","nonMaxSuppression"),l=Y_(a,o,n,r,s,i),u={boxes:a,scores:o},c={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma},h=Pv.runKernel(wx,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}}),lT=jv({nonMaxSuppressionPadded_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const a=Gv(t,"boxes","nonMaxSuppression"),o=Gv(e,"scores","nonMaxSuppression"),l=Y_(a,o,n,r,s,null),u={boxes:a,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i},h=Pv.runKernel(bx,u,c);return{selectedIndices:h[0],validOutputs:h[1]}}}),uT=jv({resizeBilinear_:function(t,e,n=!1,r=!1){const s=Gv(t,"images","resizeBilinear");Uf(3===s.rank||4===s.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`)),Uf(2===e.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`)),Uf(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let i=s,a=!1;3===s.rank&&(a=!0,i=Pw(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=e,o={images:i},l={alignCorners:n,halfPixelCenters:r,size:e},u=Pv.runKernel(Px,o,l);return a?Pw(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),cT=jv({resizeNearestNeighbor_:function(t,e,n=!1,r=!1){const s=Gv(t,"images","resizeNearestNeighbor");Uf(3===s.rank||4===s.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`)),Uf(2===e.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`)),Uf("float32"===s.dtype||"int32"===s.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Uf(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let i=s,a=!1;3===s.rank&&(a=!0,i=Pw(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=e,o={images:i},l={alignCorners:n,halfPixelCenters:r,size:e},u=Pv.runKernel(Lx,o,l);return a?Pw(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),hT=jv({bincount_:function(t,e,n){const r=Gv(t,"x","bincount"),s=Gv(e,"weights","bincount");Uf("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Uf(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Uf(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const i={x:r,weights:s},a={size:n};return Pv.runKernel(qm,i,a)}}),dT=jv({lessEqual_:function(t,e){let n=Gv(t,"a","lessEqual","string_or_numeric"),r=Gv(e,"b","lessEqual","string_or_numeric");[n,r]=Iv(n,r),Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(Xg,s)}}),pT=jv({round_:function(t){const e={x:Gv(t,"x","round")};return Pv.runKernel(Bx,e)}});function fT(t,e,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:t,stop:e,step:n,dtype:r};return Pv.runKernel(Cx,{},s)}const mT=jv({threshold_:function(t,e="binary",n=!1,r=.5){const s=Gv(t,"image","threshold"),i=s.shape[0]*s.shape[1];let a,o,l,u,c=bS(x_([r]),255);if(Uf(3===s.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`)),Uf(3===s.shape[2]||1===s.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`)),Uf("int32"===s.dtype||"float32"===s.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`)),Uf("otsu"===e||"binary"===e,(()=>`Method must be binary or otsu, but was ${e}`)),3===s.shape[2]){[a,o,l]=d_(s,[1,1,1],-1);const t=bS(a,.2989),e=bS(o,.587),n=bS(l,.114);u=yw(yw(t,e),n)}else u=t;"otsu"===e&&(c=function(t,e){let n,r,s,i,a,o,l=x_([-1]),u=x_([0]),c=x_([0]);for(let h=0;h<t.size-1;h++){n=i_(t,0,h+1),r=i_(t,h+1),a=sS(SS(n),e),o=sS(SS(r),e);const d=SS(bS(n,fT(0,n.size)));s=sS(d,SS(n));const p=hS(r.shape,n.size),f=yw(fT(0,r.size),p),m=bS(r,f);i=sS(SS(m),SS(r));const g=wS(s,i),x=wS(s,i),y=bS(a,o);c=bS(bS(y,g),x);const v=fS(c,u);u=w_(v,c,u),l=w_(v,x_([h]),l)}return l}(hT(Cb(pT(u),"int32"),Kv([]),256),i));const h=n?dT(u,c):fS(u,c);return Cb(bS(h,255),"int32")}}),gT=jv({transform_:function(t,e,n="nearest",r="constant",s=0,i){const a=Gv(t,"image","transform","float32"),o=Gv(e,"transforms","transform","float32");Uf(4===a.rank,(()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`)),Uf(2===o.rank&&(o.shape[0]===a.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Uf(null==i||2===i.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`));const l={image:a,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:i};return Pv.runKernel(vy,l,u)}}),xT=jv({bandPart_:function(t,e,n){Uf(e%1==0,(()=>`bandPart(): numLower must be an integer, got ${e}.`)),Uf(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));const r=Gv(t,"a","bandPart");Uf(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[i,a]=r.shape.slice(-2);if(!(e<=i))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=i),n<0&&(n=a);const o=Pw(fT(0,i,1,"int32"),[-1,1]),l=fT(0,a,1,"int32"),u=wS(o,l),c=TS(dT(u,mw(+e,"int32")),mS(u,mw(-n,"int32"))),h=GS([i,a],r.dtype);return Pw(m_(v_(Pw(r,[-1,i,a])).map((t=>w_(c,t,h)))),s)}}),yT=jv({min_:function(t,e=null,n=!1){const r={x:Gv(t,"x","min")},s={axis:e,keepDims:n};return Pv.runKernel(hx,r,s)}}),vT=jv({pow_:function(t,e){let n=Gv(t,"base","pow"),r=Gv(e,"exp","pow");[n,r]=Iv(n,r);const s={a:n,b:r};return Pv.runKernel(Ex,s)}});function bT(t,e,n=null){if(0===t.rank)return xw(t);if(1!==t.rank&&null===n)return bT(Pw(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return SS(xw(t),n);if(e===1/0)return vS(xw(t),n);if(e===-1/0)return yT(xw(t),n);if("euclidean"===e||2===e)return p_(SS(vT(xw(t),mw(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return vS(SS(xw(t),n[0]),n[1]-1);if(e===1/0)return vS(SS(xw(t),n[1]),n[0]);if(e===-1/0)return yT(SS(xw(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return p_(SS(zS(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const wT=jv({norm_:function(t,e="euclidean",n=null,r=!1){const s=bT(t=Gv(t,"x","norm"),e,n);let i=s.shape;if(r){const e=Zf(n,t.shape);i=LS(s.shape,e)}return Pw(s,i)}}),ST=jv({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,Uf(null!=t&&t.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=t[0].shape[0];for(let e=1;e<t.length;++e)Uf(t[e].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`))}else e=!0,t=d_(t,t.shape[0],0).map((t=>f_(t,[0])));Uf(t.length<=t[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`));const n=[],r=t;for(let e=0;e<t.length;++e)n.push(Pv.tidy((()=>{let t=r[e];if(e>0)for(let r=0;r<e;++r){const e=bS(SS(bS(n[r],t)),n[r]);t=wS(t,e)}return sS(t,wT(t,"euclidean"))})));return e?m_(n,0):n}});function _T(t,e=!1){return Pv.tidy((()=>{Uf(2===t.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`));const n=t.shape[0],r=t.shape[1];let s=cS(n),i=Ab(t);const a=G_([[1]],[1,1]);let o=Ab(a);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=i,l=o,u=s;[o,i,s]=Pv.tidy((()=>{const e=i_(i,[t,t],[n-t,1]),l=wT(e),u=i_(i,[t,t],[1,1]),c=w_(fS(u,0),G_([[-1]]),G_([[1]])),h=wS(u,bS(c,l)),d=sS(e,h);o=1===d.shape[0]?Ab(a):Gw([a,i_(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=US(sS(MS(c,h),l)),f=i_(i,[t,0],[n-t,r]),m=bS(p,o),g=M_(o);if(0===t)i=wS(f,MS(m,MS(g,f)));else{const e=wS(f,MS(m,MS(g,f)));i=Gw([i_(i,[0,0],[t,r]),e],0)}const x=M_(m),y=i_(s,[0,t],[n,s.shape[1]-t]);if(0===t)s=wS(y,MS(MS(y,o),x));else{const e=wS(y,MS(MS(y,o),x));s=Gw([i_(s,[0,0],[n,t]),e],1)}return[o,i,s]})),cw([e,l,u])}return!e&&n>r&&(s=i_(s,[0,0],[n,r]),i=i_(i,[0,0],[r,r])),[s,i]}))}const TT=jv({qr_:function(t,e=!1){if(Uf(t.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`)),2===t.rank)return _T(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce(((t,e)=>t*e)),r=v_(Pw(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],i=[];return r.forEach((t=>{const[n,r]=_T(t,e);s.push(n),i.push(r)})),[Pw(m_(s,0),t.shape),Pw(m_(i,0),t.shape)]}}});var MT;!function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(MT||(MT={}));const ET=jv({computeWeightedLoss_:function(t,e,n=MT.SUM_BY_NONZERO_WEIGHTS){const r=Gv(t,"losses","computeWeightedLoss");let s=null;null!=e&&(s=Gv(e,"weights","computeWeightedLoss"));const i=null==s?r:bS(r,s);if(n===MT.NONE)return i;if(n===MT.SUM)return SS(i);if(n===MT.MEAN){if(null==s)return CS(i);{const t=r.size/s.size,e=sS(SS(i),SS(s));return t>1?sS(e,mw(t)):e}}if(n===MT.SUM_BY_NONZERO_WEIGHTS){if(null==s)return sS(SS(i),mw(r.size));{const t=bS(s,HS(r.shape)),e=Cb(SS(WS(t,mw(0))),"float32");return sS(SS(i),e)}}throw Error(`Unknown reduction: ${n}`)}});jv({absoluteDifference_:function(t,e,n,r=MT.SUM_BY_NONZERO_WEIGHTS){const s=Gv(t,"labels","absoluteDifference"),i=Gv(e,"predictions","absoluteDifference");let a=null;null!=n&&(a=Gv(n,"weights","absoluteDifference")),Wf(s.shape,i.shape,"Error in absoluteDifference: ");const o=xw(wS(s,i));return ET(o,a,r)}}),jv({cosineDistance_:function(t,e,n,r,s=MT.SUM_BY_NONZERO_WEIGHTS){const i=Gv(t,"labels","cosineDistance"),a=Gv(e,"predictions","cosineDistance");let o=null;null!=r&&(o=Gv(r,"weights","cosineDistance")),Wf(i.shape,a.shape,"Error in cosineDistance: ");const l=mw(1),u=wS(l,SS(bS(i,a),n,!0));return ET(u,o,s)}}),jv({hingeLoss_:function(t,e,n,r=MT.SUM_BY_NONZERO_WEIGHTS){let s=Gv(t,"labels","hingeLoss");const i=Gv(e,"predictions","hingeLoss");let a=null;null!=n&&(a=Gv(n,"weights","hingeLoss")),Wf(s.shape,i.shape,"Error in hingeLoss: ");const o=mw(1);s=wS(bS(mw(2),s),o);const l=t_(wS(o,bS(s,i)));return ET(l,a,r)}}),jv({huberLoss_:function(t,e,n,r=1,s=MT.SUM_BY_NONZERO_WEIGHTS){const i=Gv(t,"labels","huberLoss"),a=Gv(e,"predictions","huberLoss");let o=null;null!=n&&(o=Gv(n,"weights","huberLoss")),Wf(i.shape,a.shape,"Error in huberLoss: ");const l=mw(r),u=xw(wS(a,i)),c=AS(u,l),h=wS(u,c),d=yw(bS(mw(.5),zS(c)),bS(l,h));return ET(d,o,s)}}),jv({logLoss_:function(t,e,n,r=1e-7,s=MT.SUM_BY_NONZERO_WEIGHTS){const i=Gv(t,"labels","logLoss"),a=Gv(e,"predictions","logLoss");let o=null;null!=n&&(o=Gv(n,"weights","logLoss")),Wf(i.shape,a.shape,"Error in logLoss: ");const l=mw(1),u=mw(r),c=US(bS(i,xS(yw(a,u)))),h=bS(wS(l,i),xS(yw(wS(l,a),u))),d=wS(c,h);return ET(d,o,s)}});const kT=jv({squaredDifference_:function(t,e){let n=Gv(t,"a","squaredDifference"),r=Gv(e,"b","squaredDifference");[n,r]=Iv(n,r),Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(ly,s,{})}});jv({meanSquaredError_:function(t,e,n,r=MT.SUM_BY_NONZERO_WEIGHTS){const s=Gv(t,"labels","meanSquaredError"),i=Gv(e,"predictions","meanSquaredError");let a=null;null!=n&&(a=Gv(n,"weights","meanSquaredError")),Wf(s.shape,i.shape,"Error in meanSquaredError: ");const o=kT(s,i);return ET(o,a,r)}}),jv({sigmoidCrossEntropy_:function(t,e,n,r=0,s=MT.SUM_BY_NONZERO_WEIGHTS){let i=Gv(t,"multiClassLabels","sigmoidCrossEntropy");const a=Gv(e,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=Gv(n,"weights","sigmoidCrossEntropy")),Wf(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=mw(r),e=mw(1),n=mw(.5);i=yw(bS(i,wS(e,t)),bS(n,t))}const l=function(t,e){const n=Gv(t,"labels","sigmoidCrossEntropyWithLogits"),r=Gv(e,"logits","sigmoidCrossEntropyWithLogits");Wf(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=t_(r),i=bS(r,n),a=yS(oS(US(xw(r))));return yw(wS(s,i),a)}(i,a);return ET(l,o,s)}});const IT=jv({logSumExp_:function(t,e=null,n=!1){const r=Gv(t,"x","logSumExp"),s=Zf(e,r.shape),i=vS(r,s,!0),a=wS(r,i),o=oS(a),l=SS(o,s),u=xS(l),c=yw(Pw(i,u.shape),u);if(n){const t=LS(c.shape,s);return Pw(c,t)}return c}});jv({softmaxCrossEntropy_:function(t,e,n,r=0,s=MT.SUM_BY_NONZERO_WEIGHTS){let i=Gv(t,"onehotLabels","softmaxCrossEntropy");const a=Gv(e,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=Gv(n,"weights","softmaxCrossEntropy")),Wf(i.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){const t=mw(r),e=mw(1),n=mw(i.shape[1]);i=yw(bS(i,wS(e,t)),sS(t,n))}const l=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);const r=fw(((t,e,r)=>{const s=IT(e,[n],!0),i=wS(Cb(e,"float32"),s);r([t,i]);const a=US(bS(i,t));return{value:SS(a,[n]),gradFunc:(t,e)=>{const[r,s]=e,i=LS(t.shape,[n]);return[bS(Pw(t,i),wS(Cb(r,"float32"),oS(s))),bS(Pw(t,i),wS(oS(s),Cb(r,"float32")))]}}}));return r(t,e)}(i,a);return ET(l,o,s)}}),jv({sparseFillEmptyRows_:function(t,e,n,r){const s=Gv(t,"indices","sparseFillEmptyRows","int32"),i=Gv(e,"values","sparseFillEmptyRows"),a=Gv(n,"denseShape","sparseFillEmptyRows","int32"),o=Gv(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==a.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:s,values:i,denseShape:a,defaultValue:o},u=Pv.runKernel(ry,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),jv({sparseReshape_:function(t,e,n){const r=Gv(t,"inputIndices","sparseReshape","int32"),s=Gv(e,"inputShape","sparseReshape","int32"),i=Gv(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a={inputIndices:r,inputShape:s,newShape:i},o=Pv.runKernel(sy,a);return{outputIndices:o[0],outputShape:o[1]}}}),jv({sparseSegmentMean_:function(t,e,n){const r=Gv(t,"data","sparseSegmentMean"),s=Gv(e,"indices","sparseSegmentMean","int32"),i=Gv(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);const a={data:r,indices:s,segmentIds:i};return Pv.runKernel(iy,a)}}),jv({sparseSegmentSum_:function(t,e,n){const r=Gv(t,"data","sparseSegmentSum"),s=Gv(e,"indices","sparseSegmentSum","int32"),i=Gv(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);const a={data:r,indices:s,segmentIds:i};return Pv.runKernel(ay,a)}}),jv({stringNGrams_:function(t,e,n,r,s,i,a,o){const l=Gv(t,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=Gv(e,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:i,padWidth:a,preserveShortSequences:o},h={data:l,dataSplits:u},d=Pv.runKernel(hy,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}}),jv({stringSplit_:function(t,e,n=!0){const r=Gv(t,"input","stringSplit","string"),s=Gv(e,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const i={skipEmpty:n},a={input:r,delimiter:s},o=Pv.runKernel(dy,a,i);return{indices:o[0],values:o[1],shape:o[2]}}}),jv({stringToHashBucketFast_:function(t,e){const n=Gv(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return Pv.runKernel(py,s,r)}});const CT={flipLeftRight:q_,grayscaleToRGB:X_,resizeNearestNeighbor:cT,resizeBilinear:uT,rotateWithOffset:K_,cropAndResize:j_,nonMaxSuppression:J_,nonMaxSuppressionAsync:async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const i=Gv(t,"boxes","nonMaxSuppressionAsync"),a=Gv(e,"scores","nonMaxSuppressionAsync"),o=Y_(i,a,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([i.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:h}=tT(u,c,n,r,s);return i!==t&&i.dispose(),a!==e&&a.dispose(),x_(h,"int32")},nonMaxSuppressionWithScore:oT,nonMaxSuppressionWithScoreAsync:async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const a=Gv(t,"boxes","nonMaxSuppressionAsync"),o=Gv(e,"scores","nonMaxSuppressionAsync"),l=Y_(a,o,n,r,s,i);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const u=await Promise.all([a.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=nT(c,h,n,r,s,i);return a!==t&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:x_(d,"int32"),selectedScores:x_(p)}},nonMaxSuppressionPadded:lT,nonMaxSuppressionPaddedAsync:async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const a=Gv(t,"boxes","nonMaxSuppressionAsync"),o=Gv(e,"scores","nonMaxSuppressionAsync"),l=Y_(a,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([a.data(),o.data()]),{selectedIndices:f,validOutputs:m}=eT(d,p,u,c,h,i);return a!==t&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:x_(f,"int32"),validOutputs:mw(m,"int32")}},threshold:mT,transform:gT},AT={bandPart:xT,gramSchmidt:ST,qr:TT};class RT extends gw{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Pv.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Pv.registeredVariables[e];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:uw((()=>S_(r).variable(!1)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:uw((()=>S_(r).variable(!1)))});const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const i=this.accumulatedGrads[n].variable,a=this.accumulatedUpdates[n].variable;uw((()=>{const t=yw(bS(i,this.rho),bS(zS(s),1-this.rho)),e=bS(sS(p_(yw(a,this.epsilon)),p_(yw(i,this.epsilon))),s),n=yw(bS(a,this.rho),bS(zS(e),1-this.rho));i.assign(t),a.assign(n);const o=yw(bS(e,-this.learningRate),r);r.assign(o)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(cw(this.accumulatedGrads.map((t=>t.variable))),cw(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}RT.className="Adadelta",aw(RT);class NT extends gw{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Pv.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:uw((()=>hS(r.shape,this.initialAccumulatorValue).variable(t)))}}const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const i=this.accumulatedGrads[n].variable;uw((()=>{const t=yw(i,zS(s));i.assign(t);const e=yw(bS(sS(s,p_(yw(t,Pv.backend.epsilon()))),-this.learningRate),r);r.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&cw(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}NT.className="Adagrad",aw(NT);class DT extends gw{constructor(t,e,n,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],uw((()=>{this.accBeta1=mw(e).variable(),this.accBeta2=mw(n).variable()})),null==r&&(this.epsilon=Pv.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);uw((()=>{const n=wS(1,this.accBeta1),r=wS(1,this.accBeta2);e.forEach(((e,s)=>{const i=Pv.registeredVariables[e];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${e}/m`,variable:uw((()=>S_(i).variable(!1)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${e}/v`,variable:uw((()=>S_(i).variable(!1)))});const a=Array.isArray(t)?t[s].tensor:t[e];if(null==a)return;const o=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,u=yw(bS(o,this.beta1),bS(a,1-this.beta1)),c=yw(bS(l,this.beta2),bS(zS(a),1-this.beta2)),h=sS(u,n),d=sS(c,r);o.assign(u),l.assign(c);const p=yw(bS(sS(h,yw(p_(d),this.epsilon)),-this.learningRate),i);i.assign(p)})),this.accBeta1.assign(bS(this.accBeta1,this.beta1)),this.accBeta2.assign(bS(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&cw(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&cw(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),uw((()=>{this.accBeta1.assign(vT(this.beta1,this.iterations_+1)),this.accBeta2.assign(vT(this.beta2,this.iterations_+1))}));const e=t.length/2;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}DT.className="Adam",aw(DT);class LT extends gw{constructor(t,e,n,r=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],uw((()=>{this.iteration=mw(0).variable(),this.accBeta1=mw(e).variable()})),null==r&&(this.epsilon=Pv.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);uw((()=>{const n=wS(1,this.accBeta1),r=sS(-this.learningRate,yw(bS(this.iteration,this.decay),1));e.forEach(((e,s)=>{const i=Pv.registeredVariables[e];null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${e}/m`,variable:S_(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${e}/v`,variable:S_(i).variable(!1)});const a=Array.isArray(t)?t[s].tensor:t[e];if(null==a)return;const o=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,u=yw(bS(o,this.beta1),bS(a,1-this.beta1)),c=bS(l,this.beta2),h=xw(a),d=IS(c,h);o.assign(u),l.assign(d);const p=yw(bS(sS(r,n),sS(u,yw(d,this.epsilon))),i);i.assign(p)})),this.iteration.assign(yw(this.iteration,1)),this.accBeta1.assign(bS(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&cw(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&cw(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}LT.className="Adamax",aw(LT);class FT extends gw{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const s=Pv.registeredVariables[e];uw((()=>{const t=yw(bS(this.c,r),s);s.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=hw(mw(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}FT.className="SGD",aw(FT);class PT extends FT{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=mw(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Pv.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:uw((()=>S_(r).variable(t)))}}const s=this.accumulations[n].variable,i=Array.isArray(t)?t[n].tensor:t[e];null!=i&&uw((()=>{let t;const e=yw(bS(this.m,s),i);t=this.useNesterov?yw(bS(this.c,yw(i,bS(e,this.m))),r):yw(bS(this.c,e),r),s.assign(e),r.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&cw(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}PT.className="Momentum",aw(PT);class $T extends gw{constructor(t,e=.9,n=0,r=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=Pv.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,n)=>{const r=Pv.registeredVariables[e],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:uw((()=>S_(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:uw((()=>S_(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:uw((()=>S_(r).variable(s)))});const i=Array.isArray(t)?t[n].tensor:t[e];if(null==i)return;const a=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;uw((()=>{const t=yw(bS(a,this.decay),bS(zS(i),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,s=yw(bS(e,this.decay),bS(i,1-this.decay)),l=sS(bS(i,this.learningRate),p_(wS(t,yw(zS(s),this.epsilon)))),u=yw(bS(o,this.momentum),l);a.assign(t),e.assign(s),o.assign(u);const c=wS(r,u);r.assign(c)}else{const t=yw(bS(a,this.decay),bS(zS(i),1-this.decay)),e=yw(bS(o,this.momentum),sS(bS(i,this.learningRate),p_(yw(t,this.epsilon))));a.assign(t),o.assign(e);const n=wS(r,e);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&cw(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&cw(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&cw(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}$T.className="RMSProp",aw($T);class OT{static sgd(t){return new FT(t)}static momentum(t,e,n=!1){return new PT(t,e,n)}static rmsprop(t,e=.9,n=0,r=null,s=!1){return new $T(t,e,n,r,s)}static adam(t=.001,e=.9,n=.999,r=null){return new DT(t,e,n,r)}static adadelta(t=.001,e=.95,n=null){return new RT(t,e,n)}static adamax(t=.002,e=.9,n=.999,r=null,s=0){return new LT(t,e,n,r,s)}static adagrad(t,e=.1){return new NT(t,e)}}const zT={sgd:OT.sgd,momentum:OT.momentum,adadelta:OT.adadelta,adagrad:OT.adagrad,rmsprop:OT.rmsprop,adamax:OT.adamax,adam:OT.adam},BT="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function UT(){return new Promise((t=>BT((()=>t()))))}function WT(t,e){const n=t[0].length;t.forEach(((t,e)=>{Uf(t.length===n,(()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`))})),Uf(e>=0&&e<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=t[0];t.forEach(((t,s)=>{for(let i=0;i<n;i++)Uf(i===e||t[i]===r[i],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${t}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}function VT(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}const GT=30;function HT(t){return t<=GT?t:um(t,Math.floor(Math.sqrt(t)))}function jT(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function qT(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)s=s.concat([t[r+1]/e[r],e[r]]);s=s.concat(t.slice(n+1))}return s}function XT(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function KT(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let n=1;n<t.length;++n)n<=e.length?r?s.push(e[n-1]*t[n]):s.push(t[n]/e[n-1]):s.push(t[n]);return s}function YT(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function JT(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}function ZT(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(0===Hf(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,i=s[s.length-1];let a=1;for(let t=0;t<s.length-1;++t)a*=s[t];const o=t.shape,l=s.slice();l.pop();let u=1;for(let t=i;t<n;++t)u*=o[t],l.push(o[t]);const c=[...cm(t.shape).map((t=>t/u)),1].slice(0,i);return[l,a,u,c]}function QT(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(i+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(i+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(i+" update.rank != "+(s+t.length-r));for(let t=0;t<s;++t)if(n.shape[t]!==e.shape[t])throw new Error(i+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-s;++e)if(n.shape[e+s]!==t[e+r])throw new Error(i+` updates.shape[${e+s}] (${n.shape[e+s]}) != shape[${e+s}] (${t[e+s]})`)}function tM(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}QT(n,e,t)}function eM(t,e,n){const r=e.shape.length,s=r>1?e.shape[r-1]:1,i=n.length;let a=1;for(let t=s;t<i;++t)a*=n[t];const o=s<1?1:s;return{sliceRank:s,numUpdates:Hf(e.shape)/o,sliceSize:a,strides:[...cm(n.slice(0,s)),1],outputSize:Hf(n)}}const nM=1.7580993408473768,rM=1.0507009873554805,sM=.3275911,iM=.254829592,aM=-.284496736,oM=1.421413741,lM=-1.453152027,uM=1.061405429;function cM(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function hM(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function dM(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=0;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}}function pM(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=2;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}}function fM(t,e){return{real:t[2*e],imag:t[2*e+1]}}function mM(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function gM(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const i=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:n,imag:r}}function xM(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}const yM=/->/g;function vM(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(yM,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=t.split("->");Uf(-1===r.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const i=r.split(","),a=i.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let t=0;t<s.length;++t){const e=s[t];if(!i.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let t=0;t<r.length;++t){const e=r[t];-1===o.indexOf(e)&&","!==e&&o.push(e)}const l=new Array(i.length);for(let t=0;t<a;++t){if(new Set(i[t].split("")).size!==i[t].length)throw new Error(`Found duplicate axes in input component ${i[t]}. Support for duplicate axes in input is not implemented yet.`);l[t]=[];for(let e=0;e<i[t].length;++e)l[t].push(o.indexOf(i[t][e]))}const u=o.length,c=[];for(let t=s.length;t<u;++t)c.push(t);return{allDims:o,summedDims:c,idDims:l}}function bM(t,e){let n=new Array(t);n.fill(-1);for(let t=0;t<e.length;++t)n[e[t]]=t;const r=[];for(let e=0;e<t;++e)-1===n[e]&&r.push(e);return n=n.filter((t=>-1!==t)),{permutationIndices:n,expandDims:r}}function wM(t,e,n){const r=new Array(t);for(let t=0;t<n.length;++t){const s=n[t].shape;for(let n=0;n<e[t].length;++n)void 0===r[e[t][n]]?r[e[t][n]]=s[n]:Uf(r[e[t][n]]===s[n],(()=>`Expected dimension ${r[e[t][n]]} at axis ${n} of input shaped ${JSON.stringify(s)}, but got dimension ${s[n]}`))}}function SM(t,e){const n=t,r=[];let s=0;0===t.length&&n.push(-1),s=t.length+1;for(let t=0;t<s;++t)r.push([]);const i=[];for(let t=0;t<n.length;++t){const s=TM(e,n[t]);for(const e of s)-1===i.indexOf(e)&&(r[t].push(e),i.push(e))}return{path:n,steps:r}}function _M(t){return t.every(((t,e)=>t===e))}function TM(t,e){const n=[];for(let r=0;r<t.length;++r)0!==t[r].length&&-1===t[r].indexOf(e)&&-1!==e||n.push(r);return n}function MM(t,e,n=0){let r=[];if("number"==typeof e)Uf(t.shape[n]%e==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce(((t,e)=>(-1===e&&(t+=1),t)),0);Uf(s<=1,(()=>"There should be only one negative value in split array."));const i=e.indexOf(-1);if(-1!==i){const r=e.reduce(((t,e)=>e>0?t+e:t));e[i]=t.shape[n]-r}Uf(t.shape[n]===e.reduce(((t,e)=>t+e)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=e}return r}function EM(t){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${t}`}function kM(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function IM(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}function CM(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function AM(t,e){return`size ${t} must be non-negative, not ${e}`}function RM(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function NM(t,e){return`Input to reshape is a SparseTensor with ${Hf(t)}\n  dense values, but the requested shape requires a multiple of ${Hf(e)}. inputShape=${t} outputShape= ${e}`}function DM(t,e){return`Input to reshape is a tensor with ${Hf(t)} dense values, but the requested shape has ${Hf(e)}. inputShape=${t} outputShape=${e}`}function LM(){return"segment ids must be >= 0"}function FM(){return"segment ids are not increasing"}function PM(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function $M(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}function OM(t,e){let n,r=!1;for(t<=GT?(n=t,r=!0):n=um(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=um(t,n+1);return n}function zM(t,e,n){const r=[],s=t.length;for(let i=0;i<s;i++)i!==e?r.push(t[i]):r.push(n);return r}function BM(t,e,n,r){const s=e.shape.length,i=t.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(t.shape[n]!==e.shape[n])throw new Error(`x.shape[${n}]: ${t.shape[n]} should be equal to indices.shape[${n}]: ${e.shape[n]}.`);const a=t.shape[n],o=[];let l=1,u=1,c=1;for(let e=0;e<r;++e)o.push(t.shape[e]),l*=t.shape[e];for(let e=r;e<n;e++)o.push(t.shape[e]),u*=t.shape[e];for(let t=r;t<s;t++)o.push(e.shape[t]);for(let e=n+1;e<i;e++)o.push(t.shape[e]),c*=t.shape[e];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:o}}function UM(t){try{return t.map((t=>sv(t)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function WM(t){return t.map((t=>rv(t)))}function VM(t,e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(t);const r=Ib(t,"int32"),s=Ib([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const i=r.indexToLoc(n[e]),a=e*t.length;s.values.set(i,a)}return s.toTensor()}const GM={kernelName:km,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(t,D_(Cb(n,"float32"),-1))}}},HM={kernelName:Im,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=zS(Cb(n,"float32")),r=p_(wS(mw(1),e));return US(sS(t,r))}}}},jM={kernelName:Cm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=p_(wS(zS(Cb(n,"float32")),1));return sS(t,e)}}}},qM={kernelName:Am,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Bb(n.shape,r.shape);return{a:()=>{let e=t;const r=zb(n.shape,s);return r.length>0&&(e=SS(e,r)),Pw(e,n.shape)},b:()=>{let e=t;const n=zb(r.shape,s);return n.length>0&&(e=SS(e,n)),Pw(e,r.shape)}}}},XM={kernelName:Rm,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach(((e,r)=>{n[r]=()=>t.clone()})),n}},KM={kernelName:Lm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>S_(n)}}},YM={kernelName:Fm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>S_(n)}}},JM={kernelName:Pm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>sS(t,p_(wS(mw(1),zS(Cb(n,"float32")))))}}},ZM={kernelName:$m,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=p_(yw(mw(1),zS(Cb(n,"float32"))));return sS(t,e)}}}},QM={kernelName:Bm,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Bb(n.shape,r.shape);return{a:()=>{const e=yw(zS(n),zS(r));let i=bS(t,sS(r,e));const a=zb(n.shape,s);return a.length>0&&(i=SS(i,a)),Pw(i,n.shape)},b:()=>{const e=yw(zS(n),zS(r));let i=US(bS(t,sS(n,e)));const a=zb(r.shape,s);return a.length>0&&(i=SS(i,a)),Pw(i,r.shape)}}}},tE={kernelName:Om,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>sS(t,yw(zS(Cb(n,"float32")),1))}}},eE={kernelName:zm,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>sS(t,wS(mw(1),zS(Cb(n,"float32"))))}}},nE=jv({avgPool3dGrad_:function(t,e,n,r,s,i){const a=Gv(t,"dy","avgPool3dGrad"),o=Gv(e,"input","avgPool3dGrad");let l=a,u=o,c=!1;4===o.rank&&(c=!0,l=Pw(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=Pw(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Uf(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Uf(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Fw("avgPool3dGrad",s,i);const h={dy:l,input:u},d={filterSize:n,strides:r,pad:s,dimRoundingMode:i},p=Pv.runKernel(Gm,h,d);return c?Pw(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),rE={kernelName:Vm,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:o}=n;return{x:()=>nE(t,r,s,i,a,o)}}},sE=jv({avgPoolGrad_:function(t,e,n,r,s){const i=Gv(t,"dy","avgPoolGrad"),a=Gv(e,"input","avgPoolGrad");Uf(a.rank===i.rank,(()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`));let o=a,l=i,u=!1;3===a.rank&&(u=!0,o=Pw(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=Pw(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Uf(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Uf(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},h={filterSize:n,strides:r,pad:s},d=Pv.runKernel(Wm,c,h);return u?Pw(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),iE={kernelName:Um,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{filterSize:s,strides:i,pad:a}=n;return{x:()=>sE(t,r,s,i,a)}}},aE={kernelName:Hm,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[r,s]=e,{transposeA:i,transposeB:a}=n;return i||a?!i&&a?{a:()=>MS(t,s,!1,!1),b:()=>MS(t,r,!0,!1)}:i&&!a?{a:()=>MS(s,t,!1,!0),b:()=>MS(r,t,!1,!1)}:{a:()=>MS(s,t,!0,!0),b:()=>MS(t,r,!0,!0)}:{a:()=>MS(t,s,!1,!0),b:()=>MS(r,t,!0,!1)}}},oE=jv({spaceToBatchND_:function(t,e,n){const r=Gv(t,"x","spaceToBatchND");Uf(r.rank>=1+e.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`)),Uf(n.length===e.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`)),Uf(r.shape.reduce(((t,r,s)=>s>0&&s<=e.length?t&&(r+n[s-1][0]+n[s-1][1])%e[s-1]==0:t),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`));const s={x:r},i={blockShape:e,paddings:n};return Pv.runKernel(ty,s,i)}}),lE={kernelName:jm,gradFunc:(t,e,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>oE(t,r,s)}}},uE={kernelName:"BroadcastTo",gradFunc:(t,e,n)=>{const r=n,s=r.inputShape,i=r.shape,a=Array.from(i);for(let t=s.length-1;t>=0;t--)if(s[t]===i[t])a[t]=1;else if(1!==s[t])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const o=[];for(let t=0;t<a.length;t++)a[t]>1&&o.push(t);return{x:()=>SS(t,o,!0)}}},cE={kernelName:Km,gradFunc:t=>({x:()=>t.clone()})},hE={kernelName:Ym,gradFunc:t=>({x:()=>S_(t)})},dE={kernelName:Jm,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{clipValueMin:s,clipValueMax:i}=n;return{x:()=>w_(TS(mS(r,s),dT(r,i)),t,S_(t))}}},pE={kernelName:Qm,inputsToSave:["x"],gradFunc:GM.gradFunc},fE={kernelName:tg,saveAllInputs:!0,gradFunc:(t,e,n)=>{const r=e.map((t=>t.shape)),{axis:s}=n,i=Zf(s,e[0].shape)[0],a=r.map((t=>t[i]));return d_(t,a,i).map((t=>()=>t))}},mE={kernelName:eg,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,{dilations:i,strides:a,pad:o,dataFormat:l}=n;return Uf(Nw(i),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`)),{x:()=>Jw(r.shape,t,s,a,o,l),filter:()=>R_(r,t,s.shape,a,o,l)}}},gE={kernelName:rg,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,{strides:i,pad:a,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Kw(t,s,i,a,o,1,l),filter:()=>R_(t,r,s.shape,i,a,o,l)}}},xE=jv({conv3DBackpropFilter_:function(t,e,n,r,s){let i=t;4===t.rank&&(i=Pw(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let a=e;4===a.rank&&(a=Pw(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),Uf(5===i.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`)),Uf(5===a.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`)),Uf(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Uf(i.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`)),Uf(a.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:i,dy:a},l={strides:r,pad:s,filterShape:n};return Pv.runKernel(ig,o,l)}}),yE={kernelName:sg,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:s,pad:i}=n;Uf(Nw(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[a,o]=e;return{x:()=>tS(a.shape,t,o,s,i),filter:()=>xE(a,t,o.shape,s,i)}}},vE=jv({sin_:function(t){const e={x:Gv(t,"x","sin","float32")};return Pv.runKernel(qx,e)}}),bE={kernelName:og,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(US(vE(Cb(n,"float32"))),t)}}},wE=jv({sinh_:function(t){const e={x:Gv(t,"x","sinh")};return Pv.runKernel(Xx,e)}}),SE={kernelName:lg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(wE(Cb(n,"float32")),t)}}},_E=jv({cumsum_:function(t,e=0,n=!1,r=!1){const s={x:Gv(t,"x","cumsum")},i={axis:e,exclusive:n,reverse:r};return Pv.runKernel(cg,s,i)}}),TE={kernelName:cg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s,exclusive:i,reverse:a}=n;return{x:()=>{const e=PS([s],r.rank);let n=_E(t,s,i,!a);return null!=e&&(n=M_(n,e)),n}}}},ME={kernelName:fg,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:a}=n,o=null==r?[1,1]:r;Uf(Nw(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=e;return Uf(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Uf(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Uf(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Uf(Dw(s,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`)),Fw("depthwiseConv2d",i,a),{x:()=>B_(l.shape,t,u,s,i,o,a),filter:()=>z_(l,t,u.shape,s,i,o,a)}}},EE={kernelName:yg,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[r,s]=e,i={x:r,filter:s,dy:t},a={x:r,filter:s,dy:t};return{x:()=>Pv.runKernel(vg,i,n),filter:()=>Pv.runKernel(bg,a,n)}}},kE={kernelName:_g,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,r={dy:t,y:n};return{x:()=>Pv.runKernel(Tg,r)}}},IE={kernelName:Mg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=bS(oS(US(zS(n))),2/Math.sqrt(Math.PI));return{x:()=>bS(t,r)}}},CE={kernelName:kg,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(t,n)}}},AE={kernelName:Ig,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>Pw(t,n.shape)}}},RE={kernelName:Cg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(t,oS(n))}}},NE={kernelName:Dg,gradFunc:t=>({x:()=>S_(t)})},DE={kernelName:Lg,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Bb(n.shape,r.shape);return{a:()=>{const e=sS(t,Cb(r,"float32")),i=zb(n.shape,s);return i.length>0?Pw(SS(e,i),n.shape):e},b:()=>{let e=bS(t,Cb(n,"float32"));const i=zb(r.shape,s);i.length>0&&(e=Pw(SS(e,i),r.shape));const a=zS(r);return US(sS(e,Cb(a,"float32")))}}}},LE=jv({rsqrt_:function(t){const e={x:Gv(t,"x","rsqrt","float32")};return Pv.runKernel(Ux,e)}}),FE={kernelName:Fg,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:r}=n,[s,i,a,o]=e,l=null==o?mw(1):o,u=zb(i.shape,s.shape),c=[];if(1===i.rank){for(let t=0;t<s.shape.length-1;++t)c.push(s.shape[t]);c.push(1)}const h=wS(s,i),d=bS(t,l),p=LE(yw(a,mw(r))),f=bS(bS(bS(p,p),p),mw(-.5));return{x:()=>1===i.rank?Pw(bS(bS(t,uS(Pw(p,[1,1,1,i.shape[0]]),c)),l),s.shape):Pw(bS(bS(t,p),l),s.shape),mean:()=>{let t=bS(bS(p,mw(-1)),d);return 1===i.rank&&(t=SS(t,u)),Pw(t,i.shape)},variance:()=>{let t=bS(bS(f,h),d);return 1===i.rank&&(t=SS(t,u)),Pw(t,i.shape)},scale:()=>{const e=bS(h,p);let n=bS(t,e);return 1===i.rank&&(n=SS(n,u)),Pw(n,i.shape)},offset:()=>{let e=t;return 1===i.rank&&(e=SS(e,u)),Pw(e,i.shape)}}}},PE=jv({unsortedSegmentSum_:function(t,e,n){const r=Gv(t,"x","unsortedSegmentSum"),s=Gv(e,"segmentIds","unsortedSegmentSum","int32");Uf(qf(n),(()=>"numSegments must be of dtype int"));const i={x:r,segmentIds:s},a={numSegments:n};return Pv.runKernel(_y,i,a)}}),$E={kernelName:Pg,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[r,s]=e,{axis:i}=n,a=Zf(i,r.shape)[0];return{x:()=>{const e=r.shape,n=s.size,o=e.slice(0,a),l=o.length,u=e.slice(i,e.length).slice(1),c=u.length,h=OE(0,l),d=OE(l+1,l+1+c),p=zE([o,[n],u]),f=Pw(t,p),m=Pw(s,[n]),g=zE([[l],h,d]),x=M_(f,g);let y=PE(x,m,r.shape[a]);const v=$S(g);return y=M_(y,v),y},indices:()=>s}}};function OE(t,e){const n=[];for(let r=t;r<e;++r)n.push(r);return n}function zE(t){const e=[];for(let n=0;n<t.length;++n)for(let r=0;r<t[n].length;++r)e.push(t[n][r]);return e}const BE={kernelName:zg,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>S_(n),b:()=>S_(r)}}},UE={kernelName:Bg,gradFunc:t=>({x:()=>Cb(t,"float32")})},WE={kernelName:Vg,gradFunc:t=>({x:()=>S_(t)})},VE={kernelName:Gg,gradFunc:t=>({x:()=>S_(t)})},GE={kernelName:Hg,gradFunc:t=>({x:()=>S_(t)})},HE={kernelName:jg,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{alpha:s}=n,i=fS(r,0);return{x:()=>w_(i,t,bS(t,s))}}},jE={kernelName:Jg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>sS(t,yw(n,1))}}},qE={kernelName:Yg,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>sS(t,Cb(n,"float32"))}}},XE={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{axis:s}=n;return{logits:()=>{const e=oS(r);return wS(t,bS(SS(t,s,!0),e))}}}},KE=jv({localResponseNormalizationBackprop_:function(t,e,n,r=5,s=1,i=1,a=.5){const o={x:t,y:e,dy:n},l={depthRadius:r,bias:s,alpha:i,beta:a};return Pv.runKernel(nx,o,l)}}),YE={kernelName:ex,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{depthRadius:i,bias:a,alpha:o,beta:l}=n;return{x:()=>KE(r,s,t,i,a,o,l)}}};function JE(t,e,n,r){return e.rank<n.rank&&(e=Pw(e,LS(e.shape,r))),t.rank<n.rank&&(t=Pw(t,LS(t.shape,r))),{x:()=>bS(t,Cb(aS(n,e),t.dtype))}}const ZE={kernelName:rx,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{reductionIndices:s}=r,i=e[0],a=JE(t,e[1],i,Zf(s,i.shape));return{x:()=>a.x()}}},QE=jv({less_:function(t,e){let n=Gv(t,"a","less","string_or_numeric"),r=Gv(e,"b","less","string_or_numeric");[n,r]=Iv(n,r),Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(qg,s)}}),tk={kernelName:sx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>bS(t,Cb(mS(n,r),"float32")),b:()=>bS(t,Cb(QE(n,r),"float32"))}}},ek=jv({maxPool3dGrad_:function(t,e,n,r,s,i,a){const o=Gv(t,"dy","maxPool3dGrad"),l=Gv(e,"input","maxPool3dGrad"),u=Gv(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=Pw(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=Pw(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=Pw(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Uf(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),Uf(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),Uf(5===d.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`)),Fw("maxPool3dGrad",i,a);const f={dy:c,input:h,output:d},m={filterSize:r,strides:s,pad:i,dimRoundingMode:a},g=Pv.runKernel(lx,f,m);return p?Pw(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),nk={kernelName:ox,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=n;return{x:()=>ek(t,r,s,i,a,o,l)}}},rk=jv({maxPoolGrad_:function(t,e,n,r,s,i,a){const o=Gv(t,"dy","maxPoolGrad"),l=Gv(e,"input","maxPoolGrad"),u=Gv(n,"output","maxPoolGrad");Uf(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),Uf(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Uf(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Fw("maxPoolGrad",i,a);const c={dy:o,input:l,output:u},h={filterSize:r,strides:s,pad:i,dimRoundingMode:a};return Pv.runKernel(ax,c,h)}}),sk={kernelName:ix,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r,s]=e,{filterSize:i,strides:a,pad:o}=n;return{x:()=>rk(t,r,s,i,a,o)}}},ik={kernelName:cx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s}=n,i=Zf(s,r.shape),a=Hf(DS(r.shape,i)[1]);return{x:()=>{const e=r.shape.slice();i.forEach((t=>{e[t]=1}));const n=Pw(t,e);return sS(bS(n,HS(r.shape,"float32")),a)}}}},ak={kernelName:hx,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const r=n,{axis:s}=r,[i,a]=e,o=JE(t,a,i,Zf(s,i.shape));return{x:()=>o.x()}}},ok={kernelName:dx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e;return{a:()=>bS(t,Cb(dT(n,r),"float32")),b:()=>bS(t,Cb(fS(n,r),"float32"))}}},lk={kernelName:px,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:s}=n,i=s.map((t=>t[0]));return{x:()=>i_(t,i,r.shape)}}},uk={kernelName:fx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Bb(n.shape,r.shape);return{a:()=>{const e=zb(n.shape,s);return e.length>0?Pw(SS(t,e),n.shape):t},b:()=>{const e=bS(t,US(dS(sS(n,r)))),i=zb(r.shape,s);return i.length>0?Pw(SS(e,i),r.shape):e}}}},ck={kernelName:gx,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Bb(n.shape,r.shape);return{a:()=>{const e=bS(t,Cb(r,"float32")),i=zb(n.shape,s);return i.length>0?Pw(SS(e,i),n.shape):e},b:()=>{const e=bS(t,Cb(n,"float32")),i=zb(r.shape,s);return i.length>0?Pw(SS(e,i),r.shape):e}}}},hk={kernelName:xx,gradFunc:t=>({x:()=>US(t)})},dk={kernelName:_x,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>GS(n.shape,"float32")}}},pk={kernelName:Sx,gradFunc:t=>({x:()=>S_(t)})},fk={kernelName:Tx,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:r}=n;return v_(t,r).map((t=>()=>t))}},mk={kernelName:Mx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const r=e[0],{paddings:s}=n,i=s.map((t=>t[0]));return{x:()=>i_(t,i,r.shape)}}},gk={kernelName:Ex,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,r,s]=e,i=n,a=r,o=Bb(i.shape,a.shape);return{a:()=>{const e=Cb(a,"float32");let n=bS(t,bS(e,vT(i,wS(e,mw(1)))));const r=zb(i.shape,o);return r.length>0&&(n=SS(n,r)),Pw(n,i.shape)},b:()=>{const e=fS(i,0),n=w_(e,xS(i),S_(i));let r=bS(t,bS(s,n));const l=zb(a.shape,o);return l.length>0&&(r=SS(r,l)),Pw(r,a.shape)}}}},xk={kernelName:kx,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,r]=e,s=fS(n,0);return{x:()=>w_(s,t,bS(t,r)),alpha:()=>{let e=w_(s,S_(t),bS(t,n));const i=zb(r.shape,t.shape);return i.length>0&&(e=SS(e,i)),Pw(e,r.shape)}}}},yk=jv({cumprod_:function(t,e=0,n=!1,r=!1){const s={x:Gv(t,"x","cumprod")},i={axis:e,exclusive:n,reverse:r};return Pv.runKernel(ug,s,i)}});const vk={kernelName:Ix,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{axis:s}=n;let i=[];return i=null==s?r.shape.map(((t,e)=>e)):"number"==typeof s?[s]:s,{x:()=>function(t,e,n){const r=t.shape.length,s=r-n.length,i=PS(n,r);let a=t;null!=i&&(a=M_(t,i));const o=a.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((t,e)=>t*e),1);o.push(l);let u=function(t,e,n){const r=t.shape.slice();r[n]=1;const s=Pw(e,r),i=yk(t,n,!0,!1),a=yk(t,n,!0,!0),o=bS(i,a);return bS(s,o)}(a.reshape(o),e,s);if(u=u.reshape(a.shape),null!=i){const t=$S(i);u=M_(u,t)}return u}(r,t,i)}}},bk={kernelName:wg,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Bb(n.shape,r.shape);return{a:()=>{const e=sS(t,Cb(r,"float32")),i=zb(n.shape,s);return i.length>0?Pw(SS(e,i),n.shape):e},b:()=>{let e=bS(t,Cb(n,"float32"));const i=zb(r.shape,s);i.length>0&&(e=Pw(SS(e,i),r.shape));const a=zS(r);return US(sS(e,Cb(a,"float32")))}}}},wk={kernelName:Rx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>sS(t,US(zS(n)))}}},Sk={kernelName:Ox,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,r=bS(dT(n,6),D_(n));return{x:()=>bS(t,Cb(r,"float32"))}}},_k={kernelName:Nx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(t,Cb(D_(n),"float32"))}}},Tk={kernelName:Dx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Pw(t,n.shape)}}},Mk={kernelName:Px,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,s={dy:t,images:r};return{images:()=>Pv.runKernel($x,s,n)}}},Ek={kernelName:Lx,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[r]=e,s={dy:t,images:r};return{images:()=>Pv.runKernel(Fx,s,n)}}},kk={kernelName:zx,gradFunc:(t,e,n)=>{const{dims:r}=n,s=Zf(r,t.shape);return{x:()=>e_(t,s)}}},Ik={kernelName:Bx,gradFunc:t=>({x:()=>S_(t)})},Ck={kernelName:Ux,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>US(sS(t,bS(vT(n,1.5),2)))}}},Ak=jv({logicalNot_:function(t){const e={x:Gv(t,"x","logicalNot","bool")};return Pv.runKernel(Qg,e)}}),Rk={kernelName:Gx,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>Cb(S_(n),"float32"),t:()=>bS(t,Cb(n,t.dtype)),e:()=>bS(t,Cb(Ak(n),t.dtype))}}},Nk={kernelName:Hx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const e=fS(n,mw(0)),r=mw(nM),s=mw(rM),i=bS(t,s),a=bS(bS(t,r),oS(Cb(n,"float32")));return w_(e,i,a)}}}},Dk={kernelName:Yx,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(t,bS(n,wS(mw(1),n)))}}},Lk={kernelName:Kx,gradFunc:t=>({x:()=>S_(t)})},Fk=jv({cos_:function(t){const e={x:Gv(t,"x","cos","float32")};return Pv.runKernel(og,e)}}),Pk={kernelName:qx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(Fk(Cb(n,"float32")),t)}}},$k=jv({cosh_:function(t){const e={x:Gv(t,"x","cosh","float32")};return Pv.runKernel(lg,e)}}),Ok={kernelName:Xx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS($k(Cb(n,"float32")),t)}}},zk={kernelName:jx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{begin:s,size:i}=n,a=r.shape,[o,l]=ew(r,s,i),u=[];for(let e=0;e<t.rank;e++)u.push([o[e],a[e]-o[e]-l[e]]);return{x:()=>qS(t,u)}}},Bk={kernelName:ny,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[r]=e,{dim:s}=n,i=bS(t,r);return{logits:()=>wS(i,bS(SS(i,[s],!0),r))}}},Uk={kernelName:Jx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(t,s_(n))}}},Wk=jv({batchToSpaceND_:function(t,e,n){const r=Gv(t,"x","batchToSpaceND"),s=e.reduce(((t,e)=>t*e));Uf(r.rank>=1+e.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`)),Uf(n.length===e.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`)),Uf(r.shape[0]%s==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`));const i={x:r},a={blockShape:e,crops:n};return Pv.runKernel(jm,i,a)}}),Vk={kernelName:ty,gradFunc:(t,e,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>Wk(t,r,s)}}},Gk={kernelName:ey,gradFunc:(t,e,n)=>{const{axis:r}=n;return{x:()=>Gw(t,r)}}},Hk=[GM,HM,jM,qM,XM,KM,YM,JM,ZM,QM,tE,eE,rE,iE,aE,lE,uE,cE,hE,dE,pE,fE,gE,mE,yE,bE,SE,TE,ME,EE,bk,kE,IE,CE,AE,RE,DE,NE,FE,$E,BE,UE,WE,VE,GE,HE,jE,qE,XE,YE,ZE,ZE,tk,nk,sk,ik,ak,ok,lk,uk,ck,hk,dk,pk,fk,mk,mk,gk,xk,vk,wk,Sk,_k,Tk,Mk,Ek,kk,Ik,Ck,Rk,Nk,Dk,Lk,Pk,Ok,zk,Bk,Uk,Vk,Vk,Gk,Gk,{kernelName:Zx,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>sS(t,bS(p_(Cb(n,"float32")),2))}}},{kernelName:ly,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=mw(2);return{a:()=>bS(t,bS(s,wS(n,r))),b:()=>bS(t,bS(s,wS(r,n)))}}},{kernelName:uy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(t,bS(Cb(n,"float32"),2))}}},{kernelName:My,gradFunc:t=>({x:()=>S_(t)})},{kernelName:fy,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,r]=e,s=Bb(n.shape,r.shape);return{a:()=>{let e=t;const r=zb(n.shape,s);return r.length>0&&(e=SS(e,r)),Pw(e,n.shape)},b:()=>{let e=t;const n=zb(r.shape,s);return n.length>0&&(e=SS(e,n)),Pw(US(e),r.shape)}}}},{kernelName:Qx,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,s=r.shape.slice(),{axis:i}=n;Zf(i,r.shape).forEach((t=>{s[t]=1}));const a=Pw(t,s),o=bS(a,HS(r.shape,"float32"));return{x:()=>o}}},{kernelName:my,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>sS(t,zS(Fk(n)))}}},{kernelName:gy,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>bS(wS(mw(1),zS(n)),t)}}},{kernelName:xy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[r]=e,{reps:s}=n;return{x:()=>{let e=S_(r);if(1===r.rank)for(let n=0;n<s[0];++n)e=yw(e,i_(t,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)e=yw(e,i_(t,[n*r.shape[0],i*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)for(let a=0;a<s[2];++a)e=yw(e,i_(t,[n*r.shape[0],i*r.shape[1],a*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let i=0;i<s[1];++i)for(let a=0;a<s[2];++a)for(let o=0;o<s[3];++o)e=yw(e,i_(t,[n*r.shape[0],i*r.shape[1],a*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return e}}}},{kernelName:by,gradFunc:(t,e,n)=>{const r=n,{perm:s}=r,i=$S(s);return{x:()=>M_(t,i)}}},{kernelName:Sy,gradFunc:(t,e,n)=>{const r=n,{axis:s}=r;return{value:()=>m_(t,s)}}},{kernelName:_y,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>function(t,e){const n=IS(e,S_(e)),r=pS(t,n);let s=mS(e,mw(0,"int32"));const i=r.rank-s.rank;for(let t=0;t<i;++t)s=lS(s,t+1);s=TS(s,HS(r.shape,"bool"));const a=S_(r);return w_(s,r,a)}(t,n)}}},{kernelName:Ty,gradFunc:t=>({x:()=>S_(t)})}];for(const t of Hk)Oy(t);yv().prototype.abs=function(){return this.throwIfDisposed(),xw(this)};const jk=jv({acos_:function(t){const e={x:Gv(t,"x","acos")};return Pv.runKernel(Im,e)}});yv().prototype.acos=function(){return this.throwIfDisposed(),jk(this)};const qk=jv({acosh_:function(t){const e={x:Gv(t,"x","acosh")};return Pv.runKernel(Cm,e)}});yv().prototype.acosh=function(){return this.throwIfDisposed(),qk(this)},yv().prototype.add=function(t){return this.throwIfDisposed(),yw(this,t)},yv().prototype.all=function(t,e){return this.throwIfDisposed(),vw(this,t,e)},yv().prototype.any=function(t,e){return this.throwIfDisposed(),bw(this,t,e)},yv().prototype.argMax=function(t){return this.throwIfDisposed(),ww(this,t)};const Xk=jv({argMin_:function(t,e=0){const n={x:Gv(t,"x","argMin")},r={axis:e};return Pv.runKernel(Fm,n,r)}});yv().prototype.argMin=function(t){return this.throwIfDisposed(),Xk(this,t)},yv().prototype.asScalar=function(){return this.throwIfDisposed(),Uf(1===this.size,(()=>"The array must have only 1 element.")),Pw(this,[])},yv().prototype.asType=function(t){return this.throwIfDisposed(),Cb(this,t)},yv().prototype.as1D=function(){return this.throwIfDisposed(),Pw(this,[this.size])},yv().prototype.as2D=function(t,e){return this.throwIfDisposed(),Pw(this,[t,e])},yv().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),Pw(this,[t,e,n])},yv().prototype.as4D=function(t,e,n,r){return this.throwIfDisposed(),Pw(this,[t,e,n,r])},yv().prototype.as5D=function(t,e,n,r,s){return this.throwIfDisposed(),Pw(this,[t,e,n,r,s])};const Kk=jv({asin_:function(t){const e={x:Gv(t,"x","asin")};return Pv.runKernel(Pm,e)}});yv().prototype.asin=function(){return this.throwIfDisposed(),Kk(this)};const Yk=jv({asinh_:function(t){const e={x:Gv(t,"x","asinh")};return Pv.runKernel($m,e)}});yv().prototype.asinh=function(){return this.throwIfDisposed(),Yk(this)};const Jk=jv({atan_:function(t){const e={x:Gv(t,"x","atan")};return Pv.runKernel(Om,e)}});yv().prototype.atan=function(){return this.throwIfDisposed(),Jk(this)};const Zk=jv({atan2_:function(t,e){let n=Gv(t,"a","atan2"),r=Gv(e,"b","atan2");[n,r]=Iv(n,r);const s={a:n,b:r};return Pv.runKernel(Bm,s)}});yv().prototype.atan2=function(t){return this.throwIfDisposed(),Zk(this,t)};const Qk=jv({atanh_:function(t){const e={x:Gv(t,"x","atanh")};return Pv.runKernel(zm,e)}});yv().prototype.atanh=function(){return this.throwIfDisposed(),Qk(this)},yv().prototype.avgPool=function(t,e,n,r){return this.throwIfDisposed(),$w(this,t,e,n,r)},yv().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),Wk(this,t,e)},yv().prototype.batchNorm=function(t,e,n,r,s){return this.throwIfDisposed(),zw(this,t,e,n,r,s)},yv().prototype.broadcastTo=function(t){return this.throwIfDisposed(),b_(this,t)},yv().prototype.cast=function(t){return this.throwIfDisposed(),Cb(this,t)};const tI=jv({ceil_:function(t){const e={x:Gv(t,"x","ceil","float32")};return Pv.runKernel(Ym,e)}});yv().prototype.ceil=function(){return this.throwIfDisposed(),tI(this)},yv().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),Vw(this,t,e)},yv().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof xv&&(t=[t]),Gw([this,...t],e)},yv().prototype.conv1d=function(t,e,n,r,s,i){return this.throwIfDisposed(),Yw(this,t,e,n,r,s,i)},yv().prototype.conv2dTranspose=function(t,e,n,r,s){return this.throwIfDisposed(),Zw(this,t,e,n,r,s)},yv().prototype.conv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),Kw(this,t,e,n,r,s,i)},yv().prototype.cos=function(){return this.throwIfDisposed(),Fk(this)},yv().prototype.cosh=function(){return this.throwIfDisposed(),$k(this)},yv().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),yk(this,t,e,n)},yv().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),_E(this,t,e,n)};const eI=jv({depthToSpace_:function(t,e,n="NHWC"){const r=Gv(t,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],i="NHWC"===n?r.shape[2]:r.shape[3],a="NHWC"===n?r.shape[3]:r.shape[1];Uf(e>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`)),Uf(s*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${e}  for depthToSpace with input shape\n    ${r.shape}`)),Uf(i*e>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${e} for depthToSpace with input shape\n        ${r.shape}`)),Uf(a%(e*e)==0,(()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${r.shape}`));const o={x:r},l={blockSize:e,dataFormat:n};return Pv.runKernel(pg,o,l)}});yv().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),eI(this,t,e)},yv().prototype.depthwiseConv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),nS(this,t,e,n,r,s,i)};const nI=jv({dilation2d_:function(t,e,n,r,s=[1,1],i="NHWC"){const a=Gv(t,"x","dilation2d"),o=Gv(e,"filter","dilation2d");Uf(3===a.rank||4===a.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`)),Uf(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),Uf("NHWC"===i,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`));let l=a,u=!1;3===a.rank&&(l=Pw(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);const c={x:l,filter:o},h={strides:n,pad:r,dilations:s},d=Pv.runKernel(yg,c,h);return u?Pw(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});yv().prototype.dilation2d=function(t,e,n,r,s){return this.throwIfDisposed(),nI(this,t,e,n,r,s)};const rI=jv({divNoNan_:function(t,e){let n=Gv(t,"a","div"),r=Gv(e,"b","div");[n,r]=Iv(n,r);const s=sS(n,r),i=S_(s),a=aS(r,i);return w_(a,i,s)}});yv().prototype.divNoNan=function(t){return this.throwIfDisposed(),rI(this,t)},yv().prototype.div=function(t){return this.throwIfDisposed(),sS(this,t)};const sI=jv({dot_:function(t,e){const n=Gv(t,"t1","dot"),r=Gv(e,"t2","dot");Uf(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const s=1===n.rank?n.size:n.shape[1],i=1===r.rank?r.size:r.shape[0];if(Uf(s===i,(()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`)),1===n.rank&&1===r.rank){const t=Pw(n,[1,-1]),e=Pw(r,[-1,1]),s=MS(t,e);return Pw(s,[])}if(1===n.rank&&2===r.rank){const t=Pw(n,[1,-1]),e=Pw(r,[r.shape[0],r.shape[1]]),s=MS(t,e);return Pw(s,[s.size])}if(2===n.rank&&1===r.rank){const t=Pw(r,[-1,1]),e=MS(n,t);return Pw(e,[e.size])}{const t=Pw(r,[r.shape[0],r.shape[1]]);return MS(n,t)}}});yv().prototype.dot=function(t){return this.throwIfDisposed(),sI(this,t)},yv().prototype.elu=function(){return this.throwIfDisposed(),iS(this)},yv().prototype.equal=function(t){return this.throwIfDisposed(),aS(this,t)};const iI=jv({erf_:function(t){let e=Gv(t,"x","erf");Uf("int32"===e.dtype||"float32"===e.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===e.dtype&&(e=Cb(e,"float32"));const n={x:e};return Pv.runKernel(Mg,n)}});yv().prototype.erf=function(){return this.throwIfDisposed(),iI(this)};const aI=jv({euclideanNorm_:function(t,e=null,n=!1){return wT(t,"euclidean",e,n)}});yv().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),aI(this,t,e)},yv().prototype.exp=function(){return this.throwIfDisposed(),oS(this)},yv().prototype.expandDims=function(t){return this.throwIfDisposed(),lS(this,t)};const oI=jv({expm1_:function(t){const e={x:Gv(t,"x","expm1")};return Pv.runKernel(Cg,e)}});yv().prototype.expm1=function(){return this.throwIfDisposed(),oI(this)},yv().prototype.fft=function(){return this.throwIfDisposed(),k_(this)},yv().prototype.flatten=function(){return this.throwIfDisposed(),Pw(this,[this.size])},yv().prototype.floor=function(){return this.throwIfDisposed(),dS(this)},yv().prototype.floorDiv=function(t){return this.throwIfDisposed(),rS(this,t)},yv().prototype.gather=function(t,e){return this.throwIfDisposed(),pS(this,t,e)},yv().prototype.greaterEqual=function(t){return this.throwIfDisposed(),mS(this,t)},yv().prototype.greater=function(t){return this.throwIfDisposed(),fS(this,t)},yv().prototype.ifft=function(){return this.throwIfDisposed(),C_(this)},yv().prototype.irfft=function(){return this.throwIfDisposed(),A_(this)};const lI=jv({isFinite_:function(t){const e={x:Gv(t,"x","isFinite")};return Pv.runKernel(Vg,e)}});yv().prototype.isFinite=function(){return this.throwIfDisposed(),lI(this)};const uI=jv({isInf_:function(t){const e={x:Gv(t,"x","isInf")};return Pv.runKernel(Gg,e)}});yv().prototype.isInf=function(){return this.throwIfDisposed(),uI(this)};const cI=jv({isNaN_:function(t){const e={x:Gv(t,"x","isNaN")};return Pv.runKernel(Hg,e)}});yv().prototype.isNaN=function(){return this.throwIfDisposed(),cI(this)},yv().prototype.leakyRelu=function(t){return this.throwIfDisposed(),gS(this,t)},yv().prototype.lessEqual=function(t){return this.throwIfDisposed(),dT(this,t)},yv().prototype.less=function(t){return this.throwIfDisposed(),QE(this,t)};const hI=jv({localResponseNormalization_:function(t,e=5,n=1,r=1,s=.5){const i=Gv(t,"x","localResponseNormalization");Uf(4===i.rank||3===i.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`)),Uf(qf(e),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`));let a=i,o=!1;3===i.rank&&(o=!0,a=Pw(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:a},u={depthRadius:e,bias:n,alpha:r,beta:s},c=Pv.runKernel(ex,l,u);return o?Pw(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});yv().prototype.localResponseNormalization=function(t,e,n,r){return this.throwIfDisposed(),hI(this,t,e,n,r)};const dI=jv({logSigmoid_:function(t){const e=Gv(t,"x","logSigmoid"),n=fw((t=>({value:US(h_(US(t))),gradFunc:e=>bS(e,s_(US(t)))})));return n(e)}});yv().prototype.logSigmoid=function(){return this.throwIfDisposed(),dI(this)},yv().prototype.logSoftmax=function(t){return this.throwIfDisposed(),_S(this,t)},yv().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),IT(this,t,e)},yv().prototype.log=function(){return this.throwIfDisposed(),xS(this)},yv().prototype.log1p=function(){return this.throwIfDisposed(),yS(this)},yv().prototype.logicalAnd=function(t){return this.throwIfDisposed(),TS(this,t)},yv().prototype.logicalNot=function(){return this.throwIfDisposed(),Ak(this)};const pI=jv({logicalOr_:function(t,e){const n=Gv(t,"a","logicalOr","bool"),r=Gv(e,"b","logicalOr","bool");Bb(n.shape,r.shape);const s={a:n,b:r};return Pv.runKernel(tx,s)}});yv().prototype.logicalOr=function(t){return this.throwIfDisposed(),pI(this,t)};const fI=jv({logicalXor_:function(t,e){const n=Gv(t,"a","logicalXor","bool"),r=Gv(e,"b","logicalXor","bool");return Bb(n.shape,r.shape),TS(pI(t,e),Ak(TS(t,e)))}});yv().prototype.logicalXor=function(t){return this.throwIfDisposed(),fI(this,t)},yv().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),MS(this,t,e,n)},yv().prototype.maxPool=function(t,e,n,r){return this.throwIfDisposed(),ES(this,t,e,n,r)},yv().prototype.max=function(t,e){return this.throwIfDisposed(),vS(this,t,e)},yv().prototype.maximum=function(t){return this.throwIfDisposed(),IS(this,t)},yv().prototype.mean=function(t,e){return this.throwIfDisposed(),CS(this,t,e)},yv().prototype.min=function(t,e){return this.throwIfDisposed(),yT(this,t,e)},yv().prototype.minimum=function(t){return this.throwIfDisposed(),AS(this,t)};const mI=jv({mirrorPad_:function(t,e,n){Uf("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=Gv(t,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Uf(e.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`));const s="reflect"===n?1:0;for(let t=0;t<r.rank;t++)Uf(2===e[t].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Uf(e[t][0]>=0&&e[t][0]<=r.shape[t]-s&&e[t][1]>=0&&e[t][1]<=r.shape[t]-s,(()=>`Padding in dimension ${t} cannot be greater than or equal to ${r.shape[t]-s} or less than 0 for input of shape ${r.shape}`));const i={paddings:e,mode:n},a={x:r};return Pv.runKernel(px,a,i)}});yv().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),mI(this,t,e)};const gI=jv({mod_:function(t,e){let n=Gv(t,"a","mod"),r=Gv(e,"b","mod");[n,r]=Iv(n,r);const s={a:n,b:r};return Pv.runKernel(fx,s)}});yv().prototype.mod=function(t){return this.throwIfDisposed(),gI(this,t)},yv().prototype.mul=function(t){return this.throwIfDisposed(),bS(this,t)},yv().prototype.neg=function(){return this.throwIfDisposed(),US(this)},yv().prototype.norm=function(t,e,n){return this.throwIfDisposed(),wT(this,t,e,n)},yv().prototype.notEqual=function(t){return this.throwIfDisposed(),WS(this,t)},yv().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),VS(this,t,e,n)},yv().prototype.onesLike=function(){return this.throwIfDisposed(),jS(this)},yv().prototype.pad=function(t,e){return this.throwIfDisposed(),qS(this,t,e)};const xI=jv({pool_:function(t,e,n,r,s,i,a){null==s&&(s=[1,1]),null==i&&(i=1),0===r&&(r="valid");const o=Gv(t,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=Pw(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Uf(Dw(i,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`));const c=_w(l.shape,e,i,s,r),h=[c.dilationHeight,c.dilationWidth];let d;d="same"===r?function(t,e){const n=t.map(((t,n)=>t+(t-1)*(e[n]-1))).map((t=>t-1)),r=n.map((t=>Math.floor(t/2))),s=n.map(((t,e)=>t-r[e]));return n.map(((t,e)=>[r[e],s[e]]))}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(t,e,n){const r=n.map((t=>t[0])),s=n.map((t=>t[1])),i=t.concat(r,s),a=e.map(((t,e)=>(t-i[e]%t)%t)),o=s.map(((t,e)=>t+a[e]));return[e.map(((t,e)=>[r[e],o[e]])),e.map(((t,e)=>[0,a[e]]))]}([c.inHeight,c.inWidth],h,d),g=p?r:"valid",x=p?l:oE(l,h,f),y=("avg"===n?()=>$w(x,e,i,g,a):()=>ES(x,e,i,g,a))(),v=p?y:Wk(y,h,m);return u?Pw(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});yv().prototype.pool=function(t,e,n,r,s,i){return this.throwIfDisposed(),xI(this,t,e,n,r,s,i)},yv().prototype.pow=function(t){return this.throwIfDisposed(),vT(this,t)},yv().prototype.prelu=function(t){return this.throwIfDisposed(),XS(this,t)};const yI=jv({prod_:function(t,e=null,n=!1){let r=Gv(t,"x","prod");"bool"===r.dtype&&(r=Cb(r,"int32"));const s={x:r},i={axis:e,keepDims:n};return Pv.runKernel(Ix,s,i)}});yv().prototype.prod=function(t,e){return this.throwIfDisposed(),yI(this,t,e)};const vI=jv({reciprocal_:function(t){const e={x:Gv(t,"x","reciprocal")};return Pv.runKernel(Rx,e)}});yv().prototype.reciprocal=function(){return this.throwIfDisposed(),vI(this)},yv().prototype.relu=function(){return this.throwIfDisposed(),t_(this)},yv().prototype.relu6=function(){return this.throwIfDisposed(),N_(this)},yv().prototype.reshapeAs=function(t){return this.throwIfDisposed(),Pw(this,t.shape)},yv().prototype.reshape=function(t){return this.throwIfDisposed(),Pw(this,t)},yv().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),uT(this,t,e,n)},yv().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),cT(this,t,e,n)},yv().prototype.reverse=function(t){return this.throwIfDisposed(),e_(this,t)},yv().prototype.rfft=function(){return this.throwIfDisposed(),I_(this)},yv().prototype.round=function(){return this.throwIfDisposed(),pT(this)},yv().prototype.rsqrt=function(){return this.throwIfDisposed(),LE(this)},yv().prototype.selu=function(){return this.throwIfDisposed(),n_(this)},yv().prototype.separableConv2d=function(t,e,n,r,s,i){return this.throwIfDisposed(),r_(this,t,e,n,r,s,i)},yv().prototype.sigmoid=function(){return this.throwIfDisposed(),s_(this)};const bI=jv({sign_:function(t){const e={x:Gv(t,"x","sign")};return Pv.runKernel(Kx,e)}});yv().prototype.sign=function(){return this.throwIfDisposed(),bI(this)},yv().prototype.sin=function(){return this.throwIfDisposed(),vE(this)},yv().prototype.sinh=function(){return this.throwIfDisposed(),wE(this)},yv().prototype.slice=function(t,e){return this.throwIfDisposed(),i_(this,t,e)},yv().prototype.softmax=function(t){return this.throwIfDisposed(),c_(this,t)},yv().prototype.softplus=function(){return this.throwIfDisposed(),h_(this)},yv().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),oE(this,t,e)},yv().prototype.split=function(t,e){return this.throwIfDisposed(),d_(this,t,e)},yv().prototype.sqrt=function(){return this.throwIfDisposed(),p_(this)},yv().prototype.square=function(){return this.throwIfDisposed(),zS(this)},yv().prototype.squaredDifference=function(t){return this.throwIfDisposed(),kT(this,t)},yv().prototype.squeeze=function(t){return this.throwIfDisposed(),f_(this,t)},yv().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof xv?[this,t]:[this,...t];return m_(n,e)},yv().prototype.step=function(t){return this.throwIfDisposed(),D_(this,t)};const wI=jv({stridedSlice_:function(t,e,n,r,s=0,i=0,a=0,o=0,l=0){const u={x:Gv(t,"x","stridedSlice","string_or_numeric")},c={begin:e,end:n,strides:r,beginMask:s,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};return Pv.runKernel(cy,u,c)}});yv().prototype.stridedSlice=function(t,e,n,r,s,i,a,o){return this.throwIfDisposed(),wI(this,t,e,n,r,s,i,a,o)},yv().prototype.sub=function(t){return this.throwIfDisposed(),wS(this,t)},yv().prototype.sum=function(t,e){return this.throwIfDisposed(),SS(this,t,e)};const SI=jv({tan_:function(t){const e={x:Gv(t,"x","tan","float32")};return Pv.runKernel(my,e)}});yv().prototype.tan=function(){return this.throwIfDisposed(),SI(this)},yv().prototype.tanh=function(){return this.throwIfDisposed(),g_(this)},yv().prototype.tile=function(t){return this.throwIfDisposed(),uS(this,t)},yv().prototype.toBool=function(){return this.throwIfDisposed(),Cb(this,"bool")},yv().prototype.toFloat=function(){return this.throwIfDisposed(),Cb(this,"float32")},yv().prototype.toInt=function(){return this.throwIfDisposed(),Cb(this,"int32")};const _I=jv({topk_:function(t,e=1,n=!0){const r=Gv(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const i={x:r},a={k:e,sorted:n},[o,l]=Pv.runKernel(yy,i,a);return{values:o,indices:l}}});yv().prototype.topk=function(t,e){return this.throwIfDisposed(),_I(this,t,e)},yv().prototype.transpose=function(t){return this.throwIfDisposed(),M_(this,t)};const TI=jv({unique_:function(t,e=0){const n=Gv(t,"x","unique","string_or_numeric");Uf(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:e},[i,a]=Pv.runKernel(wy,r,s);return{values:i,indices:a}}});yv().prototype.unique=function(t){return this.throwIfDisposed(),TI(this,t)},yv().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),PE(this,t,e)},yv().prototype.unstack=function(t){return this.throwIfDisposed(),v_(this,t)},yv().prototype.where=function(t,e){return this.throwIfDisposed(),w_(t,this,e)},yv().prototype.zerosLike=function(){return this.throwIfDisposed(),S_(this)};class MI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,MI.prototype)}}class EI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,EI.prototype)}}class kI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,kI.prototype)}}class II extends Error{constructor(t){super(t),Object.setPrototypeOf(this,II.prototype)}}class CI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,CI.prototype)}}Error;class AI{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const t=this.cache.keys().next().value;this.cache.delete(t)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const t=this.cache.keys().next().value;this.cache.delete(t)}this.maxEntries=t}}function RI(t,e){if(Array.isArray(t)){let n=[];for(let r=0;r<e;r++)n=n.concat(t);return n}{const n=new Array(e);return n.fill(t),n}}function NI(t,e){if(!t)throw new CI(e)}function DI(t,e){let n=0;for(const r of t)r===e&&n++;return n}function LI(t){return 1===t.length?t[0]:t}function FI(t){return Array.isArray(t)?t:[t]}function PI(t){const e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function $I(t){return t.length<=1||-1===t.indexOf("_")?t:t.replace(/[_]+(\w|$)/g,((t,e)=>e.toUpperCase()))}let OI={};function zI(t){if(null==t)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function BI(t){if(null!=t&&"object"==typeof t)if(Array.isArray(t))t.forEach((t=>BI(t)));else{const e=Object.keys(t);for(const n of e){const e=t[n];null!=e&&"object"==typeof e&&(Array.isArray(e)||"ndarray"!==e.type||"number"!=typeof e.value?BI(e):t[n]=e.value)}}}function UI(t,e={},n={},r="object",s=!1){if("string"==typeof t){const s=t;let i;if(s in n)i=n[s];else if(s in OI)i=OI[s];else if(i=e[s],null==i)throw new kI(`Unknown ${r}: ${t}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const i=t;if(null==i.className||null==i.config)throw new kI(`${r}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const a=i.className;let o,l;if(a in n?[o,l]=n[a]:a in OI?[o,l]=OI.className:a in e&&([o,l]=e[a]),null==o)throw new kI(`Unknown ${r}: ${a}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const t={};for(const e of Object.keys(OI))t[e]=OI[e];for(const e of Object.keys(n))t[e]=n[e];i.config.customObjects=t;const e=Object.assign({},OI);for(const t of Object.keys(n))OI[t]=n[t];BI(i.config);const r=l(o,i.config,n,s);return OI=Object.assign({},e),r}{const t=Object.assign({},OI);for(const t of Object.keys(n))OI[t]=n[t];const e=new o(i.config);return OI=Object.assign({},t),e}}}function WI(t,e){return-1*function(t,e){return t<e?-1:t>e?1:0}(t,e)}function VI(t){if(null==t)return t;const e=[];for(const n of t)-1===e.indexOf(n)&&e.push(n);return e}function GI(t){if(null==t)throw new kI(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function HI(t,e,n){if(null!=n&&t.indexOf(n)<0)throw new kI(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function jI(t,e,n=0,r=1/0){return NI(n>=0),NI(r>=n),Array.isArray(t)&&t.length>=n&&t.length<=r&&t.every((t=>typeof t===e))}function qI(t,e){Array.isArray(t)?(Uf(t.length>0,(()=>`${e} is unexpectedly an empty array.`)),t.forEach(((t,n)=>qI(t,`element ${n+1} of ${e}`)))):Uf(Number.isInteger(t)&&t>0,(()=>`Expected ${e} to be a positive integer, but got ${XI(t)}.`))}function XI(t){return null===t?"null":Array.isArray(t)?"["+t.map((t=>XI(t))).join(",")+"]":"string"==typeof t?`"${t}"`:`${t}`}function KI(t){return"relu"===t?"relu":"linear"===t?"linear":"elu"===t?"elu":null}let YI=0;function JI(){return YI++}const ZI={};function QI(t=""){return t in ZI||(ZI[t]=0),ZI[t]+=1,t+ZI[t].toString()}const tC=["channelsFirst","channelsLast"],eC=["nearest","bilinear"],nC=["valid","same","causal"],rC=["max","avg"],sC=["sum","mul","concat","ave"],iC=new Map;function aC(t){HI(tC,"DataFormat",t)}function oC(t){HI(nC,"PaddingMode",t)}function lC(t){HI(rC,"PoolMode",t)}const uC=[];function cC(t,e){uC.push(t);try{const t=e();return uC.pop(),t}catch(t){throw uC.pop(),t}}function hC(t){if(!fC(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===uC.length?"":uC.join("/")+"/")+t}function dC(t){if(!fC(t))throw new Error("Not a valid tensor name: '"+t+"'");iC.has(t)||iC.set(t,0);const e=iC.get(t);if(iC.set(t,iC.get(t)+1),e>0){const n=`${t}_${e}`;return iC.set(n,1),n}return t}const pC=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function fC(t){return!!t.match(pC)}function mC(t,e,n){null==e&&(e=0),null==n&&(n=t.length);let r=1;for(let s=e;s<n;++s)r*=t[s];return r}function gC(t){if(0===t.length)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r<e&&(e=r)}return e}function xC(t){if(0===t.length)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const r=t[n];r>e&&(e=r)}return e}function yC(t,e){if(e<t)throw new kI(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let r=t;r<e;++r)n.push(r);return n}let vC;function bC(){return null==vC&&(vC=pw().epsilon()),vC}function wC(t,e){return Cb(t,e)}function SC(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),Pw(t,n)}function _C(t,e,n){return uw((()=>{switch(t.rank){case 1:return a_(t,e,n);case 2:return o_(t,[e,0],[n,t.shape[1]]);case 3:return l_(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return u_(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return i_(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return i_(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new kI(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}))}function TC(t,e,n){return uw((()=>{switch(t.rank){case 1:return a_(t,e,n);case 2:return o_(t,[0,e],[t.shape[0],n]);case 3:return l_(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return u_(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new kI(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}}))}function MC(t,e,n,r){return uw((()=>{switch(t.rank){case 1:return a_(t,e,n);case 2:switch(r){case 1:return _C(t,e,n);case 2:return TC(t,e,n);default:throw new kI(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return _C(t,e,n);case 2:return l_(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return TC(t,e,n);default:throw new kI(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return _C(t,e,n);case 2:return u_(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return u_(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return TC(t,e,n);default:throw new kI(`The axis is not within the rank of the tensor ${r}`)}default:throw new kI(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}}))}function EC(t,e=-1){let n;return e<0&&(n=t[0].rank,e=0!==n?n:0),e===t[0].rank&&(e=-1),Gw(t,e)}function kC(t,e){switch(t.rank){case 1:return Hw([t,e]);case 2:return jw([t,e],0);case 3:return qw([t,e],0);case 4:return Xw([t,e],0);default:throw new kI(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function IC(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new kI(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return uS(t,e)}function CC(t,e=0,n=1,r,s){return ZS(t,e,n,r,s)}function AC(t,e,n,r){if(t.rank<2||e.rank<2)throw new II(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3&&t.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new II(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`);if(2===t.rank&&2===e.rank)return U_({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?DC(t.rank,r,"channelsLast"):null,activation:n});{const s=t.shape.slice(),i=s.pop();t=Pw(t,[-1,i]);const a=e.shape.slice(),o=a.pop(),l=a.pop(),u=[...a,o],c=Array.from({length:e.rank},((t,n)=>0===n?e.rank-2:n<=e.rank-2?n-1:n));e=Pw(M_(e,c),[l,-1]);const h=[...s,...u];return Pw(U_({a:t,b:e,transposeA:!1,transposeB:!1,bias:r?DC(t.rank,r,"channelsLast"):null,activation:n}),h)}}function RC(t,e,n){return uw((()=>(e=Array.isArray(e)?x_(e,"int32"):Cb(e,"int32"),pS(t,e,n))))}function NC(t){return bS(t,t)}function DC(t,e,n){const r=e.shape;if(1!==e.rank&&e.rank!==t)throw new kI(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(5===t){if("channelsFirst"===n)return 1===r.length?Pw(e,[1,r[0],1,1,1]):Pw(e,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Pw(e,[1,1,1,1,r[0]]):Pw(e,[1].concat(r))}else if(4===t){if("channelsFirst"===n)return 1===r.length?Pw(e,[1,r[0],1,1]):Pw(e,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Pw(e,[1,1,1,r[0]]):Pw(e,[1].concat(r))}else if(3===t){if("channelsFirst"===n)return 1===r.length?Pw(e,[1,r[0],1]):Pw(e,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Pw(e,[1,1,r[0]]):Pw(e,[1].concat(r))}else if(t<3)return e;throw new kI(`Unsupported input rank by biasAdd: ${e.rank}`)}function LC(t,e,n){return uw((()=>(null==n&&(n="channelsLast"),aC(n),yw(t,DC(t.rank,e,n)))))}function FC(t,e,n,r){return uw((()=>E_(t,e,n,r)))}function PC(t,e,n=!1){return n?t():e()}const $C=["fanIn","fanOut","fanAvg"],OC=["normal","uniform","truncatedNormal"];class zC extends sw{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class BC extends zC{apply(t,e){return GS(t,e)}}BC.className="Zeros",aw(BC);class UC extends zC{apply(t,e){return HS(t,e)}}UC.className="Ones",aw(UC);class WC extends zC{constructor(t){if(super(),"object"!=typeof t)throw new kI(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new kI(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return uw((()=>bS(mw(this.value),HS(t,e))))}getConfig(){return{value:this.value}}}WC.className="Constant",aw(WC);class VC extends zC{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return QS(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}VC.className="RandomUniform",aw(VC);class GC extends zC{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new II(`randomNormal does not support dType ${e}.`);return CC(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}GC.className="RandomNormal",aw(GC);class HC extends zC{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if("float32"!==(e=e||"float32")&&"int32"!==e)throw new II(`truncatedNormal does not support dType ${e}.`);return y_(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}HC.className="TruncatedNormal",aw(HC);class jC extends zC{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,e){return uw((()=>{if(2!==t.length||t[0]!==t[1])throw new kI("Identity matrix initializer can only be used for 2D square matrices.");return bS(this.gain,cS(t[0]))}))}getConfig(){return{gain:this.gain}}}jC.className="Identity",aw(jC);class qC extends zC{constructor(t){if(super(),t.scale<0)throw new kI(`scale must be a positive float. Got: ${t.scale}`);var e;this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,e=this.mode,HI($C,"FanMode",e),this.distribution=null==t.distribution?"normal":t.distribution,function(t){HI(OC,"Distribution",t)}(this.distribution),this.seed=t.seed}apply(t,e){const n=function(t,e="channelsLast"){let n,r;if(aC(e),2===t.length)n=t[0],r=t[1];else if(-1!==[3,4,5].indexOf(t.length)){if("channelsFirst"===e){const e=mC(t,2);n=t[1]*e,r=t[0]*e}else if("channelsLast"===e){const e=mC(t,0,t.length-2);n=t[t.length-2]*e,r=t[t.length-1]*e}}else{const e=mC(t);n=Math.sqrt(e),r=Math.sqrt(e)}return[n,r]}(t),r=n[0],s=n[1];let i=this.scale;if("fanIn"===this.mode?i/=Math.max(1,r):"fanOut"===this.mode?i/=Math.max(1,s):i/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(e=e||"float32")&&"int32"!==e)throw new II(`${this.getClassName()} does not support dType ${e}.`);return y_(t,0,n,e,this.seed)}{const n=Math.sqrt(3*i);return QS(t,-n,n,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}qC.className="VarianceScaling",aw(qC);class XC extends qC{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return qC.className}}XC.className="GlorotUniform",aw(XC);class KC extends qC{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return qC.className}}KC.className="GlorotNormal",aw(KC);class YC extends qC{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return qC.className}}YC.className="HeNormal",aw(YC);class JC extends qC{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return qC.className}}JC.className="HeUniform",aw(JC);class ZC extends qC{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return qC.className}}ZC.className="LeCunNormal",aw(ZC);class QC extends qC{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return qC.className}}QC.className="LeCunNormal",aw(QC);class tA extends zC{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,null!=this.seed)throw new II("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return uw((()=>{if(t.length<2)throw new II("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);const e=CC(t[0]>t[1]?[t[1],t[0]]:t,0,1,"float32");let n=AT.gramSchmidt(e);return t[0]>t[1]&&(n=M_(n)),bS(this.gain,n)}))}getConfig(){return{gain:this.gain,seed:this.seed}}}tA.className="Orthogonal",aw(tA);const eA={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function nA(t,e={}){return UI(t,iw.getMap().classNameMap,e,"initializer")}function rA(t){return zI(t)}function sA(t){if("string"==typeof t){const e=t in eA?eA[t]:t;if("GlorotNormal"===e)return new KC;if("GlorotUniform"===e)return new XC;if("HeNormal"===e)return new YC;if("HeUniform"===e)return new JC;if("LeCunNormal"===e)return new ZC;if("LeCunUniform"===e)return new QC;{const t={};return t.className=e,t.config={},nA(t)}}return t instanceof zC?t:nA(t)}function iA(t){return Array.isArray(t)&&Array.isArray(t[0])}function aA(t){return 0===t.length?[]:Array.isArray(t[0])?t:[t]}function oA(t){let e;if(Array.isArray(t)){if(1!==t.length)throw new kI(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function lA(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(1===t.length)return t[0];throw new kI(`Expected exactly 1 Shape; got ${t.length}`)}return t}function uA(t){let e=0;for(const n of t)0===n.shape.length?e+=1:e+=n.shape.reduce(((t,e)=>t*e));return e}class cA{constructor(t,e="float32",n="Variable",r=!0,s=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=JI(),n=null==n?"Variable":n,this.originalName=hC(n),this.name=dC(this.originalName),this.trainable_=r,this.constraint=s,this.val=function(t,e=!0,n,r){return Pv.makeVariable(t,e,n,r)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function hA(t){return t.map((t=>t.read()))}function dA(t){t.forEach((t=>{t[0].write(t[1])}))}class pA{constructor(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class fA{constructor(t,e,n,r,s,i,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=a,this.id=JI(),null!=i&&(this.originalName=hC(i),this.name=dC(this.originalName)),this.rank=e.length}}let mA=0;class gA{constructor(t,e){this.callArgs=e,this.id=mA++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const e of t.inboundLayers)null!=e&&e.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)null!=e?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let xA=0;class yA extends sw{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=xA++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const t=this.getClassName();e=PI(t)+"_"+QI(t)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}null!=t.weights?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new EI(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new kI(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return LI(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return LI(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new MI(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new MI(`Layer ${this.name} is not connected, no input to return.`);return LI(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new MI(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new MI(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return LI(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((t=>t()))}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach((e=>e.trainable=t)),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((t=>t.trainable)):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((t=>!t.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=FI(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=FI(this.inputSpec);if(t.length!==e.length)throw new kI(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){const r=t[n],s=e[n];if(null==s)continue;const i=r.rank;if(null!=s.ndim&&i!==s.ndim)throw new kI(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(null!=s.maxNDim&&i>s.maxNDim)throw new kI(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(null!=s.minNDim&&i<s.minNDim)throw new kI(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new kI(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const t=r.shape;for(const e in s.axes){const r=Number(e),i=s.axes[e],a=r>=0?t[r]:t[t.length+r];if(null!=i&&-1===[i,null].indexOf(a))throw new kI(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${i} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const e=s.shape[t],i=r.shape[t];if(null!=e&&null!=i&&e!==i)throw new kI(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const n=FI(t);let r=!0;for(const t of n)if(!(t instanceof fA)){r=!1;break}let s=!0;for(const t of n)if(t instanceof fA){s=!1;break}if(r===s)throw new kI("Arguments to apply() must be all SymbolicTensors or all Tensors");return cC(this.name,(()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of FI(t))e.push(n.shape);this.build(LI(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let r=this.call(t,e);const s=FI(r),i=[];for(let t of s)-1!==n.indexOf(t)&&(t=t.clone()),i.push(t);if(r=LI(i),null!=this.activityRegularizer)throw new II("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(t){t=FI(t);const e=[];for(const n of t)e.push(n.shape);return LI(e)}(t),r=this.computeOutputShape(n);let s;const i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new fA(i,n,this,FI(t),e,this.name,r))):new fA(i,r,this,FI(t),e,this.name),this.addInboundNode(t,s,null,null,n,r,e),this._refCount++,null!=this.activityRegularizer)throw new II("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}}))}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=t[r]&&t[r]!==n&&(e=!0)})),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new MI(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new MI(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new EI(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return uA(this.weights)}build(t){this.built=!0}getWeights(t=!1){return hA(t?this.trainableWeights:this.weights)}setWeights(t){uw((()=>{const e=this.weights;if(e.length!==t.length)throw new kI(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const n=[],r=hA(e);for(let s=0;s<r.length;++s){const i=r[s],a=e[s],o=t[s];if(!jf(i.shape,o.shape))throw new kI(`Layer weight shape ${i.shape} not compatible with provided weight shape ${o.shape}`);n.push([a,o])}dA(n)}))}addWeight(t,e,n,r,s,i,a,o){if(-1!==this._addedWeightNames.indexOf(t))throw new kI(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():sA("zeros"));const l=r.apply(e,n),u=new cA(l,n,t,i,a);return l.dispose(),null!=s&&this.addLoss((()=>s.apply(u.read()))),null==i&&(i=!0),i?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=FI(t),void 0!==this._losses&&null!==this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach((t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return e}addInboundNode(t,e,n,r,s,i,a=null){const o=FI(t);e=FI(e),n=FI(n),r=FI(r),s=aA(s),i=aA(i);const l=[],u=[],c=[];for(const t of o)l.push(t.sourceLayer),u.push(t.nodeIndex),c.push(t.tensorIndex);new gA({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:e,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:i},a);for(let t=0;t<e.length;t++)e[t].sourceLayer=this,e[t].nodeIndex=this.inboundNodes.length-1,e[t].tensorIndex=t}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach((t=>t.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function vA(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const r=vA(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of r)-1===e.indexOf(t)&&e.push(t)}return e}}}class bA extends yA{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:QI("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new kI("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(null==e){if(null==t.inputShape)throw new kI("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new kI("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];const r=new fA(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new gA({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new kI(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}bA.className="InputLayer",aw(bA);class wA{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof wA)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,n){if(null!=this.id2Value[t.id])throw new kI(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function(t,e){if(null==t.dtype||t.dtype===e.dtype)return e;try{return Cb(e,t.dtype)}catch(n){throw new kI(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=n&&(this.id2Mask[t.id]=n),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof fA){if(null==this.id2Value[t.id])throw new kI(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new kI(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof fA){if(null==this.id2Value[t.id])throw new kI(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new kI(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&cw(this.id2Mask)}}const SA=new AI,_A=new AI;function TA(t,e,n,r){const s=null!=n&&n.training,i=Array.isArray(t),a=i?t:[t],o=a.map((t=>t.name)),l=[],u=e.names();for(const t of o)-1!==u.indexOf(t)?l.push(e.getValue(t)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+e.names().sort().join(",");let h,d=SA.get(c);if(null==d){const t=function(t,e){Uf(null!=t&&t.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===t.length){const s=EA(t[0],e);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of t){const{sorted:t,recipientMap:a}=EA(i,e);for(const e of t)s.has(e.name)||(n.push(e),s.add(e.name));for(const t in a)null==r[t]&&(r[t]=new Set),a[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:MA(r)}}(a,e);d=t.sorted,h=t.recipientCounts,SA.put(c,d),_A.put(c,h)}h={},s||Object.assign(h,_A.get(c));const p=new wA(e);for(let t=0;t<d.length;++t){if(null!=r){const t=lw().numTensors;t>r.maxNumTensors&&(r.maxNumTensors=t),t<r.minNumTensors&&(r.minNumTensors=t)}const i=d[t],a=i.sourceLayer;if(a instanceof bA)continue;const u=[],c=[],f=[];let m=!1;for(const t of i.inputs){const n=p.getValue(t),r=p.getMask(t);u.push(n),c.push(r),null!=r&&(m=!0),s||(h[t.name]--,0!==h[t.name]||e.hasKey(t)||-1!==o.indexOf(t.name)||n.isDisposed||!0===t.sourceLayer.stateful||f.push(n))}m&&((n=n||{}).mask=c[0]);const g=FI(a.apply(u,n));let x=null;a.supportsMasking&&(x=a.computeMask(u,c));const y=kA(i),v=Array.isArray(y)?y:[y];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(x)?x[0]:x);const e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}s||cw(f)}return p.disposeMasks(),i?l:l[0]}function MA(t){const e={};for(const n in t)e[n]=t[n].size;return e}function EA(t,e){const n=new Set,r=[],s={};for(const t of e.names())n.add(t);const i=[],a=[];for(i.push(t);i.length>0;){const t=i[i.length-1];if(n.has(t.name)){i.pop();continue}const e=a[a.length-1]===i.length-1;if(0===t.inputs.length||e)i.pop(),r.push(t),n.add(t.name),e&&a.pop();else{a.push(i.length-1);for(const e of t.inputs)null==s[e.name]&&(s[e.name]=new Set),s[e.name].add(t.name),n.has(e.name)||i.push(e)}}return{sorted:r,recipientMap:s}}function kA(t){let e;if(1===t.sourceLayer.inboundNodes.length)e=t.sourceLayer.output;else{let n=null;for(let e=0;e<t.sourceLayer.inboundNodes.length;++e)for(const r of t.sourceLayer.inboundNodes[e].outputTensors)if(r.id===t.id){n=e;break}e=t.sourceLayer.getOutputAt(n)}return e}function IA(t,e){return uw((()=>p_(SS(bS(t,t),e,!0))))}Sm().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(t){null!=SA&&SA.setMaxEntries(t),null!=_A&&_A.setMaxEntries(t)}));class CA extends sw{getConfig(){return{}}}class AA extends CA{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return uw((()=>{const e=IA(t,this.axis),n=Vw(e,0,this.maxValue);return bS(t,sS(n,yw(bC(),e)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}AA.className="MaxNorm",aw(AA);class RA extends CA{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return uw((()=>sS(t,yw(bC(),IA(t,this.axis)))))}getConfig(){return{axis:this.axis}}}RA.className="UnitNorm",aw(RA);class NA extends CA{apply(t){return t_(t)}}NA.className="NonNeg",aw(NA);class DA extends CA{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return uw((()=>{const e=IA(t,this.axis),n=yw(bS(this.rate,Vw(e,this.minValue,this.maxValue)),bS(1-this.rate,e));return bS(t,sS(n,yw(bC(),e)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}DA.className="MinMaxNorm",aw(DA);const LA={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function FA(t){return zI(t)}function PA(t,e={}){return UI(t,iw.getMap().classNameMap,e,"constraint")}function $A(t){return null==t?null:"string"==typeof t?PA({className:t in LA?LA[t]:t,config:{}}):t instanceof CA?t:PA(t)}async function OA(t){if(null==t)return;const e=[],n=[],r=[];for(const s in t){const i=t[s];if("number"!=typeof i){const t=i;e.push(t.data()),n.push(s),r.push(t)}}if(e.length>0){const s=await Promise.all(e);for(let e=0;e<s.length;++e)t[n[e]]=s[e][0];cw(r)}}function zA(t){if(null!=t)for(const e in t){const n=t[e];"number"!=typeof n&&n.dispose()}}var BA;!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(BA||(BA={}));class UA{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class WA{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){null==e&&(e={});for(const n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class VA extends UA{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){null==e&&(e={});const n=null==e.size?0:e.size;this.seen+=n;for(const t in e){const r=e[t];if("number"==typeof r)this.totals.hasOwnProperty(t)||(this.totals[t]=0),this.totals[t]=this.totals[t]+r*n;else{let e;t in this.totals?e=this.totals[t]:this.totals[t]=0;const s=uw((()=>yw(this.totals[t],bS(r,n))));this.totals[t]=s,null!=e&&e.dispose()}}}async onEpochEnd(t,e){if(null!=e)for(const t of this.params.metrics)null!=this.totals[t]&&("number"==typeof this.totals[t]?e[t]=this.totals[t]/this.seen:uw((()=>{const n=bS(sS(1,this.seen),this.totals[t]);e[t]=n,this.totals[t].dispose(),hw(e[t])})))}}class GA extends UA{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){null==e&&(e={}),this.epoch.push(t);for(const t in e)null==this.history[t]&&(this.history[t]=[]),this.history[t].push(e[t])}async syncData(){const t=[],e=[],n=[];for(const r in this.history){const s=this.history[r];for(let i=0;i<s.length;++i)if("number"!=typeof s[i]){const a=s[i];t.push(a.data()),e.push(r),n.push(i)}}const r=await Promise.all(t);for(let t=0;t<r.length;++t)this.history[e[t]][n[t]].dispose(),this.history[e[t]][n[t]]=r[t][0]}}class HA extends UA{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||UT,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");am(this.yieldEvery)&&(this.maybeWait=function(t,e,n){let r,s=null!=n?n():nv();return(...i)=>{const a=null!=n?n():nv();return a-s<e||(s=a,r=t(...i)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){const r=[];null!=this.yield&&(await OA(n),r.push(this.yield(t,e,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(t,e){this.currentEpoch=t,null!=this.epochBegin&&(await OA(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const n=[];null!=this.epochEnd&&(await OA(e),n.push(this.epochEnd(t,e))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){null!=this.batchBegin&&(await OA(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const n=[];null!=this.batchEnd&&(await OA(e),n.push(this.batchEnd(t,e))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):am(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){null!=this.trainBegin&&(await OA(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await OA(t),await this.trainEnd(t))}}function jA(t,e){return null==t&&(t={}),t instanceof UA?[t]:Array.isArray(t)&&t[0]instanceof UA?t:FI(t).map((t=>new HA(t,e)))}class qA{constructor(){}static registerCallbackConstructor(t,e){Uf(t>=0&&Number.isInteger(t),(()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`)),qA.checkForDuplicate(e),null==qA.constructors[t]&&(qA.constructors[t]=[]),qA.constructors[t].push(e)}static checkForDuplicate(t){for(const e in qA.constructors)qA.constructors[+e].forEach((e=>{if(e===t)throw new kI("Duplicate callback constructor.")}))}static clear(){qA.constructors={}}static createCallbacks(t){const e=[];for(const n in qA.constructors){const r=+n;t>=r&&e.push(...qA.constructors[r])}return e.map((t=>new t))}}function XA(t,e,n,r,s,i,a,o,l){const u=new GA,c=[new VA,...qA.createCallbacks(e)];null!=t&&c.push(...t),c.push(u);const h=new WA(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:i,batchSize:a,verbose:e,doValidation:o,metrics:l}),{callbackList:h,history:u}}function KA(t,e={},n=!1){return UI(t,iw.getMap().classNameMap,e,"layer",n)}function YA(t,e){return uw((()=>{"float32"!==t.dtype&&(t=Cb(t,"float32"));const n=SS(NC(t),e,!0),r=hS(n.shape,bC()),s=p_(IS(n,r));return sS(t,s)}))}function JA(t,e){return uw((()=>CS(NC(wS(e,t)),-1)))}function ZA(t,e){return uw((()=>CS(xw(wS(e,t)),-1)))}function QA(t,e){return uw((()=>{const n=wS(t,e),r=Vw(xw(t),bC(),Number.MAX_VALUE),s=xw(sS(n,r));return bS(100,CS(s,-1))}))}function tR(t,e,n=!1){return uw((()=>{if(n)e=c_(e);else{const t=SS(e,e.shape.length-1,!0);e=sS(e,t)}return e=Vw(e,bC(),1-bC()),US(SS(bS(Cb(t,"float32"),xS(e)),e.shape.length-1))}))}function eR(t,e,n=!1){return uw((()=>{const r=Cb(dS(function(t){const e=[mC(t.shape)];return Pw(t,e)}(t)),"int32"),s=(e=Vw(e,bC(),1-bC())).shape;return tR(Pw(VS(r,s[s.length-1]),s),e,n)}))}function nR(t,e){return uw((()=>{let n;return n=Vw(e,bC(),1-bC()),n=xS(sS(n,wS(1,n))),CS(function(t,e){if(!jf(t.shape,e.shape))throw new kI(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return uw((()=>{const n=t_(e),r=US(xw(e));return yw(wS(n,bS(e,t)),yS(oS(r)))}))}(t,n),-1)}))}function rR(t,e){return uw((()=>{const n=YA(t,-1),r=YA(e,-1),s=bS(n,r);return US(SS(s,-1))}))}qA.constructors={};const sR={meanSquaredError:JA,meanAbsoluteError:ZA,meanAbsolutePercentageError:QA,meanSquaredLogarithmicError:function(t,e){return uw((()=>{const n=Vw(e,bC(),Number.MAX_VALUE),r=xS(yw(1,n)),s=Vw(t,bC(),Number.MAX_VALUE),i=xS(yw(1,s));return CS(NC(wS(r,i)),-1)}))},squaredHinge:function(t,e){return uw((()=>{const n=IS(0,wS(1,bS(t,e)));return CS(NC(n),-1)}))},hinge:function(t,e){return uw((()=>{const n=IS(0,wS(1,bS(t,e)));return CS(n,-1)}))},categoricalHinge:function(t,e){return uw((()=>{const n=SS(bS(t,e),-1),r=vS(bS(wS(1,t),e),-1);return IS(0,yw(1,wS(r,n)))}))},logcosh:function(t,e){return uw((()=>{const n=Math.log(2),r=wS(e,t),s=wS(yw(r,h_(bS(-2,r))),n);return CS(s,-1)}))},categoricalCrossentropy:tR,sparseCategoricalCrossentropy:eR,binaryCrossentropy:nR,kullbackLeiblerDivergence:function(t,e){return uw((()=>{const n=Vw(t,bC(),1),r=Vw(e,bC(),1);return SS(bS(t,xS(sS(n,r))),-1)}))},poisson:function(t,e){return uw((()=>{const n=xS(yw(bC(),e));return CS(wS(e,bS(t,n)),-1)}))},cosineProximity:rR};function iR(t){if("string"==typeof t){if(t in sR)return sR[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new kI(e)}return t}function aR(t,e){return uw((()=>{const n=bS(.5,jS(e)),r=wC(fS(e,n),t.dtype);return CS(aS(t,r),-1)}))}function oR(t,e){return uw((()=>wC(aS(ww(t,-1),ww(e,-1)),"float32")))}function lR(t,e){return nR(t,e)}function uR(t,e){return t.rank===e.rank&&(t=f_(t,[t.rank-1])),(e=ww(e,-1)).dtype!==t.dtype&&(e=Cb(e,t.dtype)),Cb(aS(t,e),"float32")}const cR=tR,hR=eR,dR={binaryAccuracy:aR,categoricalAccuracy:oR,precision:function(t,e){return uw((()=>{const n=function(t,e){return uw((()=>Cb(SS(TS(aS(t,1),aS(e,1))),"float32")))}(t,e),r=function(t,e){return uw((()=>Cb(SS(TS(aS(t,0),aS(e,1))),"float32")))}(t,e),s=yw(n,r);return Cb(w_(fS(s,0),sS(n,s),0),"float32")}))},categoricalCrossentropy:cR,sparseCategoricalCrossentropy:hR,mse:JA,MSE:JA,mae:ZA,MAE:ZA,mape:QA,MAPE:QA,cosine:rR};function pR(t){if("string"==typeof t&&t in dR)return dR[t];if("string"!=typeof t&&null!=t)return t;throw new kI(`Unknown metric ${t}`)}function fR(t){if(NI(null!==t,`Unknown LossOrMetricFn ${t}`),"string"==typeof t)return t;{let e;for(const n of Object.keys(sR))if(sR[n]===t){e=n;break}if(void 0!==e)return e;for(const n of Object.keys(dR))if(dR[n]===t){e=n;break}return void 0!==e?e:t.name}}function mR(t,e,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!gR(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(t);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function gR(t){if(null===t)return!0;if("object"==typeof t){if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e){if("string"!=typeof n)return!1;if(!gR(t[n]))return!1}return!0}if(Array.isArray(t)){for(const e of t)if(!gR(e))return!1;return!0}return!1}{const e=typeof t;return"string"===e||"number"===e||"boolean"===e}}function xR(t,e,n=console.log){let r="";for(let n=0;n<t.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=t[n],r=r.slice(0,e[n]),r+=" ".repeat(e[n]-r.length);n(r)}function yR(t,e,n){let r,s;try{s=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){s="multiple"}try{r=JSON.stringify(t.outputShape)}catch(t){r="multiple"}xR([`${t.name} (${t.getClassName()})`,s,r,t.countParams().toString()],e,n)}function vR(t,e,n,r){let s,i;try{i=t.inboundNodes.map((t=>JSON.stringify(t.inputShapes))).join(",")}catch(t){i="multiple"}try{s=JSON.stringify(t.outputShape)}catch(t){s="multiple"}const a=[];for(const e of t.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(e)))for(let t=0;t<e.inboundLayers.length;++t){const n=e.inboundLayers[t].name,r=e.nodeIndices[t],s=e.tensorIndices[t];a.push(`${n}[${r}][${s}]`)}const o=t.name,l=t.getClassName(),u=0===a.length?"":a[0];xR([`${o} (${l})`,i,s,t.countParams().toString(),u],e,r);for(let t=1;t<a.length;++t)xR(["","","","",a[t]],e,r)}function bR(t,e,n){return("inboundNodes"===t||"outputLayers"===t||"inputLayers"===t)&&0===e&&"string"==typeof n}function wR(t,e){if(null===t)return null;if("string"==typeof t)return $I(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let s=0;s<r;++s){const r=t[s];bR(e,s,r)?n.push(r):n.push(wR(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];if("name"===n&&"string"==typeof r)e[n]=r;else{const t=$I(n);e[t]=wR(r,t)}}return e}}function SR(t,e){if(null==t)return null;if("string"==typeof t)return PI(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const n=[],r=t.length;for(let s=0;s<r;++s){const r=t[s];bR(e,s,r)?n.push(r):n.push(SR(r,e))}return n}{const e={};for(const n of Object.keys(t)){const r=t[n];e[PI(n)]="name"!==n&&"className"!==n||"string"!=typeof r?SR(r,n):r}return e}}class _R extends yA{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=QI(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],VI(this.inputs).length!==this.inputs.length)throw new kI(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((t=>t.name))}`);VI(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((t=>t.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const t of this.outputs){const e=t.sourceLayer,n=t.nodeIndex,r=t.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const t of this.inputs){const e=t.sourceLayer,n=t.nodeIndex,r=t.tensorIndex;NI(0===n,"input layer has >1 nodes"),NI(0===r,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e];if(!(n instanceof bA))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${e} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const t of this.outputLayers)this.outputNames.push(t.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const e={},n={},r={},s={},i={},a=[],o=(t,e,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=t.sourceLayer,s=t.nodeIndex,l=t.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new EI(`The tensor ${t.name} at layer "${r.name}" is part of a cycle.`);if(-1!==e.indexOf(u))return;this.containerNodes.add(_R.nodeKey(r,s)),r.id in i||(i[r.id]=Object.keys(i).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let t=0;t<c;t++){const r=u.inputTensors[t],s=u.inboundLayers[t],i=u.nodeIndices[t],a=u.tensorIndices[t];o(r,e,n,s,i,a)}for(e.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);a.push(u)},l=[],u=[];for(const t of this.outputs)o(t,l,u);const c=a.slice().reverse();for(const t of c){n[t.id]=t,t.id in e||(e[t.id]=0);let i=e[t.id];const a=null==r[t.outboundLayer.id]?0:r[t.outboundLayer.id];i=Math.max(i,a),r[t.outboundLayer.id]=i,s[t.outboundLayer.id]=t.outboundLayer,e[t.id]=i;for(let r=0;r<t.inboundLayers.length;r++){const s=t.inboundLayers[r],a=t.nodeIndices[r],o=s.inboundNodes[a],l=null==e[o.id]?0:e[o.id];e[o.id]=Math.max(i+1,l),n[o.id]=o}}const h={};for(const t in e){const r=e[t];r in h||(h[r]=[]),h[r].push(n[t])}const d={};for(const t in r){const e=r[t];e in d||(d[e]=[]),d[e].push(s[t])}let p=Object.keys(d).map((t=>parseInt(t,10))).sort(WI);this.layers=[];for(const t of p){const e=d[t];e.sort(((t,e)=>{const n=i[t.id],r=i[e.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof _R&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((t=>parseInt(t,10))).sort(WI);const f=this.inputs.slice(),m=[];for(const t of p)for(const e of h[t]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new EI(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map((t=>t.name));for(const t of g){const e=g.filter((e=>e===t)).length;if(1!==e)throw new EI(`The name "${t}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new gA({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((e=>{e._trainableWeights.forEach((e=>e.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new kI("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let r=0;for(const t of this.layers)for(const e of t.weights){if(null!=n[e.originalName])throw new kI(`Duplicate weight name: ${e.originalName}`);n[e.originalName]=e,r++}const s=[];for(const r in t){let i=r;if(null==n[r]){const t=r.split("/");i=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[i])s.push([n[i],t[r]]);else if(e)throw new kI(`Provided weight data has no target variable: ${r}`);delete n[i]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new kI(`${t.length} of ${r} weights are not set: ${t}`)}dA(s)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 3.18.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const n=SR(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return uw((()=>{t=FI(t);const n=new wA;for(let e=0;e<this.inputs.length;++e)n.add(this.inputs[e],t[e]);return TA(this.outputs,n,e)}))}computeMask(t,e){return uw((()=>{let n;return t=FI(t),n=null==e?RI(null,t.length):FI(e),this.runInternalGraph(t,n)[1]}))}computeOutputShape(t){const e=aA(t);if(e.length!==this.inputLayers.length)throw new kI(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let t=0;t<e.length;t++){const r=this.inputLayers[t],s=e[t];n[r.name+"_0_0"]=s}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(WI);if(r.length>1)for(const t of r){const e=this.nodesByDepth[t];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(e.id))continue;const r=[];for(let e=0;e<t.inboundLayers.length;e++){const s=t.inboundLayers[e],i=t.nodeIndices[e],a=t.tensorIndices[e],o=n[`${s.name}_${i}_${a}`];r.push(o)}const s=aA(e.computeOutputShape(LI(r))),i=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++)n[`${e.name}_${i}_${t}`]=s[t]}}const s=[],i=[];for(let t=0;t<this.outputLayers.length;t++){const e=this.outputLayers[t],n=this.outputLayersNodeIndices[t],r=this.outputLayersTensorIndices[t],s=`${e.name}_${n}_${r}`;i.push(s)}for(let t=0;t<i.length;t++){const e=i[t];NI(e in n),s.push(n[e])}return LI(s)}runInternalGraph(t,e){null==e&&(e=RI(null,t.length));const n={};for(let r=0;r<this.inputs.length;++r){const s=this.inputs[r],i=t[r],a=e[r];n[s.id]=[i,a]}const r=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(WI);for(const t of r){const e=this.nodesByDepth[t];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,s=t.outputTensors,i=new Array;for(const t of r)t.id in n&&i.push(n[t.id]);if(i.length===r.length){let r,a,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===i.length){const[t,n]=i[0];null==u.mask&&(u.mask=n),o=FI(e.call(t,u)),l=FI(e.computeMask(t,n)),r=[t],a=[n]}else r=i.map((t=>t[0])),a=i.map((t=>t[1])),null==u.mask&&(u.mask=a),o=FI(e.call(r,u)),l=FI(e.computeMask(r,a));if(e.activityRegularizer)throw new II("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<s.length;++t){const e=s[t],r=o[t],i=l[t];n[e.id]=[r,i]}}}}const s=[],i=[],a=[];for(const t of this.outputs){NI(t.id in n,`Could not compute output ${t.name} : ${t.id}`);const[e,r]=n[t.id];a.push(e.shape),s.push(e),i.push(r)}return[s,i,a]}buildNodeConversionMap(t){const e={};let n;for(const t of this.layers){n=t instanceof _R?1:0;for(let r=0;r<t.inboundNodes.length;r++){const s=_R.nodeKey(t,r);this.containerNodes.has(s)&&(e[s]=n,n+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new kI(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new kI("Provide either a layer name or layer index");for(const e of this.layers)if(e.name===t)return e;throw new kI(`No such layer: ${t}`)}calculateLosses(){return uw((()=>{const t=[];for(const e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){const r=_R.nodeKey(e,n);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t}))}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(const t of this.layers){const r=t.getClassName(),s=t.getConfig(),i=[];for(let n=0;n<t.inboundNodes.length;n++){const r=t.inboundNodes[n],s=_R.nodeKey(t,n);let a={};if(this.containerNodes.has(s)){if(r.callArgs)try{JSON.stringify(r.callArgs),a=r.callArgs}catch(e){console.warn(`Layer ${t.name} was passed non-serializable keyword arguments: ${r.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),a={}}if(r.inboundLayers.length>0){const t=[];for(let n=0;n<r.inboundLayers.length;n++){const s=r.inboundLayers[n],i=r.nodeIndices[n],o=r.tensorIndices[n];let l=e[_R.nodeKey(s,i)];null==l&&(l=0),t.push([s.name,l,o,a])}i.push(t)}}}const a={};a.name=t.name,a.className=r,a.config=s,a.inboundNodes=i,n.push(a)}t.layers=n;const r=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t],s=this.inputLayersNodeIndices[t],i=_R.nodeKey(n,s);if(!this.containerNodes.has(i))continue;let a=e[i];null==a&&(a=0);const o=this.inputLayersTensorIndices[t];r.push([n.name,a,o])}t.inputLayers=r;const s=[];for(let t=0;t<this.outputLayers.length;t++){const n=this.outputLayers[t],r=this.outputLayersNodeIndices[t],i=_R.nodeKey(n,r);if(!this.containerNodes.has(i))continue;let a=e[i];null==a&&(a=0);const o=this.outputLayersTensorIndices[t];s.push([n.name,a,o])}return t.outputLayers=s,t}static fromConfig(t,e,n={},r=!1){const s={},i={};function a(t,e){t.name in i?i[t.name].push(e):i[t.name]=[e]}function o(t,e){const n=[];let r;for(const i of e){const o=i[0],l=i[1],u=i[2];if(r=null==i[3]?{}:i[3],!(o in s))return void a(t,e);const c=s[o];if(c.inboundNodes.length<=l)return void a(t,e);const h=c.inboundNodes[l];n.push(h.outputTensors[u])}n.length>0&&t.apply(LI(n),r)}function l(t){const n=t.name,i=KA(t,null!=e.customObjects?e.customObjects:{});i.setFastWeightInitDuringBuild(r),s[n]=i,t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new kI(`Corrupted configuration, expected array for nodeData: ${t}`);a(i,t)}))}const u=e.name,c=e.layers;for(const t of c)l(t);for(;!GI(i);)for(const t of c){const e=s[t.name];if(e.name in i){const t=i[e.name];delete i[e.name];for(const n of t)o(e,n)}}const h=[],d=[],p=e.inputLayers;for(const t of p){const e=t[0],n=t[1],r=t[2];NI(e in s);const i=s[e].inboundNodes[n].outputTensors;h.push(i[r])}const f=e.outputLayers;for(const t of f){const e=t[0],n=t[1],r=t[2];NI(e in s);const i=s[e].inboundNodes[n].outputTensors;d.push(i[r])}return new t({inputs:h,outputs:d,name:u})}get stateful(){if(this._stateful)throw new kI("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){uw((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}function TR(t,e){return function(t,e,n){const r=e.length;if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>null));if(1===r)return Array.isArray(t)&&1===t.length?t:"object"==typeof t&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}if("object"==typeof t&&Object.keys(t).length>0&&"object"==typeof t[Object.keys(t)[0]]){const n=[];return e.forEach((e=>{e in t?n.push(t[e]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}(t,e,"classWeight")}async function MR(t,e,n,r){if(null!=e||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const e=uw((()=>{if(1===t.shape.length)return Ab(t);if(2===t.shape.length){if(t.shape[1]>1)return ww(t,1);if(1===t.shape[1])return Pw(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await e.data());cw(e);const s=[];return r.forEach((t=>{if(null==n[t])throw new Error(`classWeight must contain all classes in the training data. The class ${t} exists in the data but not in classWeight`);s.push(n[t])})),x_(s,"float32")}return null}function ER(t,e){return bS(t,e)}function kR(t,e){let n,r;const s=e;n=s.xs,r=s.ys,Uf(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`));const i=IR("input",t.inputNames,n),a=IR("output",t.outputNames,r),o=i[0].shape[0];Uf(i.length===t.inputs.length,(()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`)),Uf(a.length===t.outputs.length,(()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`));for(let e=0;e<i.length;e++)Uf(i[e].shape[0]===o,(()=>`Batch size mismatch: input ${t.inputNames[e]} has ${i[e].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`));for(let e=0;e<a.length;e++)Uf(a[e].shape[0]===o,(()=>`Batch size mismatch: output ${t.outputNames[e]} has ${a[e].shape[0]}; expected  ${o} based on input ${t.inputNames[0]}.`));return{xs:i,ys:a}}function IR(t,e,n){if(n instanceof xv)return[n];if(Array.isArray(n))return Uf(n.length===e.length,(()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`)),n;{const r=[];for(const s of e){if(null==n[s])throw new kI(`The feature data generated by the dataset lacks the required ${t} key '${s}'.`);r.push(n[s])}return r}}function CR(t){return"function"==typeof t.iterator}function AR(t){Uf(t>0&&Number.isInteger(t),(()=>`batchSize is required to be a positive integer, but got ${t}`))}function RR(t,e,n){return null==t?[null]:Array.isArray(t)?t.map((t=>_C(t,e,n-e))):_C(t,e,n-e)}function NR(t,e){return uw((()=>null==t?null:Array.isArray(t)?t.map((t=>NR(t,e))):RC(t,"int32"===e.dtype?e:Cb(e,"int32"))))}function DR(t,e){const n=[];let r=0,s=null;for(;r<t;)s=r+e,s>=t&&(s=t),n.push([r,s]),r=s;return n}function LR(t){const e=[];t instanceof xv&&(t=[t]);for(let n=0;n<t.length;++n){const r=t[n];if(1===r.rank)e.push(SC(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function FR(t,e){if(null==t)return;const n=[];if(e instanceof xv)n.push(e.id);else if(Array.isArray(e))e.forEach((t=>n.push(t.id)));else if(null!=e)for(const t in e){const r=e[t];n.push(r.id)}const r=[];if(t instanceof xv)-1===n.indexOf(t.id)&&r.push(t);else if(Array.isArray(t))t.forEach((t=>{-1===n.indexOf(t.id)&&r.push(t)}));else if(null!=t)for(const e in t){const s=t[e];-1===n.indexOf(s.id)&&r.push(s)}r.forEach((t=>{t.isDisposed||t.dispose()}))}function PR(t){return Array.isArray(t)}function $R(t){return!function(t){return t instanceof xv}(t)&&!PR(t)}function OR(t,e,n,r=!0,s=""){if(null==e||0===e.length){if(null!=t){let e=!1;if(PR(t)&&t.length>0)e=!0;else if($R(t)){for(const n in t)if(t.hasOwnProperty(n)){e=!0;break}}else e=!0;if(e)throw new kI(`Error when checking model ${s} expected no data, but got ${t}`)}return[]}if(null==t)return e.map((t=>null));let i;if($R(t)){i=[];for(const n of e){if(null==t[n])throw new kI(`No data provided for "${n}". Need data for each key in: ${e}`);i.push(t[n])}}else if(PR(t)){if(t.length!==e.length)throw new kI(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);i=t}else{if(e.length>1)throw new kI(`The model ${s} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);i=[t]}if(i=LR(i),null!=n)for(let t=0;t<e.length;++t){if(null==n[t])continue;const a=i[t];if(a.shape.length!==n[t].length)throw new kI(`Error when checking ${s}: expected ${e[t]} to have ${n[t].length} dimension(s). but got array with shape ${a.shape}`);for(let e=0;e<n[t].length;++e){if(0===e&&!r)continue;const i=a.shape[e],o=n[t][e];if(null!=o&&o>=0&&i!==o)throw new kI(`${s} expected a batch of elements where each example has shape [${n[t].slice(1,n[t].length)}] (i.e.,tensor shape [*,${n[t].slice(1,n[t].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function zR(t,e,n,r=!0,s=""){let i;if(Array.isArray(t)){if(t.length!==e.length)throw new kI(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);i=t}else{if(e.length>1)throw new kI(`The model expects ${e.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);i=[t]}if(null!=n)for(let t=0;t<e.length;++t){if(null==n[t])continue;const a=i[t];if(a.shape.length!==n[t].length)throw new kI(`Error when checking ${s}: expected ${e[t]} to have ${n[t].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let i=0;i<n[t].length;++i){if(0===i&&!r)continue;const o=a.shape[i],l=n[t][i];if(null!=l&&l!==o)throw new kI(`Error when checking ${s}: expected ${e[t]} to have shape ${JSON.stringify(n[t])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}class BR extends _R{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new kI("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(t,e,n,r=console.log){const s=function(t){let e=!0;const n=[],r=[];for(const e in t.nodesByDepth)n.push(t.nodesByDepth[e]);for(const t of n){if(t.length>1||1===t.length&&t[0].inboundLayers.length>1){e=!1;break}r.push(...t)}if(e)for(const n of t.layers){let t=!1;for(const s of n.inboundNodes)if(-1!==r.indexOf(s)){if(t){e=!1;break}t=!0}if(!e)break}return e}(t),i=["Layer (type)","Input Shape","Output shape","Param #"];let a;if(s?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((t=>Math.floor(e*t)))),!s){i.push("Receives inputs"),a=[];for(const e in t.nodesByDepth)a.push(...t.nodesByDepth[e])}r("_".repeat(e)),xR(i,n,r),r("=".repeat(e));const o=t.layers;for(let t=0;t<o.length;++t)s?yR(o[t],n,r):vR(o[t],n,a,r),r((t===o.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const l=function(t){let e;return e=null!=t.collectedTrainableWeights?uA(t.collectedTrainableWeights):uA(t.trainableWeights),e}(t),u=uA(t.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(e))}(this,t,e,n)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function(t){const e={Adagrad:()=>zT.adagrad(.01),Adadelta:()=>zT.adadelta(1,.95,bC()),Adam:()=>zT.adam(.001,.9,.999,bC()),Adamax:()=>zT.adamax(.002,.9,.999,bC(),0),RMSProp:()=>zT.rmsprop(.001,.9,0,bC()),SGD:()=>zT.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new kI(`Unknown Optimizer ${t}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof gw))throw new kI("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new kI(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);const n=t.loss;e=n.map((t=>iR(t)))}else{const n=iR(t.loss);this.outputs.forEach((t=>{e.push(n)}))}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new kI(`Unknown entry in loss dictionary: "${e}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==t.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),e.push(iR(t.loss[n]))}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let t=0;t<this.outputs.length;++t){const e=this.internalOutputShapes[t],n=this.outputNames[t];this.feedOutputNames.push(n),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[t])}const n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],cC("loss",(()=>{for(let t=0;t<this.outputs.length;++t){if(-1!==n.indexOf(t))continue;const e=this.lossFunctions[t];this.outputs.length>1&&(this.metricsTensors.push([e,t]),this.metricsNames.push(this.outputNames[t]+"_loss"))}}));const r=function(t,e){if(null==t||Array.isArray(t)&&0===t.length)return e.map((t=>[]));let n;if("string"==typeof t||"function"==typeof t)n=[t];else{if(!Array.isArray(t)&&"object"!=typeof t)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);n=t}if(Array.isArray(n))return e.map((t=>n));{const t=[];for(const r of e){let e=n.hasOwnProperty(r)?n[r]:[];Array.isArray(e)||(e=[e]),t.push(e)}return t}}(t.metrics,this.outputNames),s=(t,e,n)=>{this.outputNames.length>1&&(e=this.outputNames[t]+"_"+e),this.metricsNames.push(e),this.metricsTensors.push([n,t])};cC("metric",(()=>{for(let t=0;t<this.outputs.length;++t)-1===n.indexOf(t)&&(e=>{let n,r,i;for(const a of e){if("string"==typeof a&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(a)){const e=this.internalOutputShapes[t];let s;1===e[e.length-1]||this.lossFunctions[t]===nR?-1!==["accuracy","acc"].indexOf(a)?r=aR:-1!==["crossentropy","ce"].indexOf(a)&&(r=lR):this.lossFunctions[t]===eR?-1!==["accuracy","acc"].indexOf(a)?r=uR:-1!==["crossentropy","ce"].indexOf(a)&&(r=hR):-1!==["accuracy","acc"].indexOf(a)?r=oR:-1!==["crossentropy","ce"].indexOf(a)&&(r=cR),-1!==["accuracy","acc"].indexOf(a)?s="acc":-1!==["crossentropy","ce"].indexOf(a)&&(s="ce"),i=r,n=""+s}else{const t=pR(a);i=t,n=""+fR(a)}let e;cC(n,(()=>{e=i})),s(t,n,e)}})(r[t])})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){const r=null==n.batchSize?32:n.batchSize;AR(r);const s=this.standardizeUserDataXY(t,e,!0,r);try{const i=s[0].concat(s[1]);this.makeTestFunction();const a=this.testFunction;return LI(this.testLoop(a,i,r,n.verbose,n.steps))}finally{FR(s[0],t),FR(s[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),async function(t,e,n){const r=null!=(n=n||{}).batches,s=t.testFunction;let i=[];if(n.verbose>0)throw new II("Verbose mode is not implemented yet.");Uf(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const a="function"==typeof e.next?e:await e.iterator();let o=0,l=0;for(;!r||l<n.batches;){const e=await a.next();if(i=uw((()=>{if(e.value){const{xs:n,ys:r}=kR(t,e.value),a=n.concat(r),u=uw((()=>s(a)));if(cw(a),0===l)for(let t=0;t<u.length;++t)i.push(mw(0));const c=a[0].shape[0];for(let t=0;t<u.length;++t){const e=u[t],n=i[t];i[t]=uw((()=>yw(i[t],bS(c,e)))),l>0&&cw(n)}cw(u),o+=c,++l}return i})),e.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let t=0;t<i.length;++t){const e=i[t];i[t]=sS(i[t],o),cw(e)}return LI(i)}(this,t,e)}checkNumSamples(t,e,n,r="steps"){let s;if(null!=n){if(s=null,null!=e)throw new kI(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else{if(null==t)throw new kI(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return s}execute(t,e){if(Array.isArray(e)&&0===e.length)throw new kI("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(e),r=n?e:[e],s=this.retrieveSymbolicTensors(r),i=new wA;if(t instanceof xv&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new kI(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)i.add(this.inputs[e],t[e])}else for(const e of this.inputs){const n=t[e.name];if(null==n)throw new kI(`No value is provided for the model's input ${e.name}`);i.add(e,n)}const a=TA(s,i);return n?a:a[0]}retrieveSymbolicTensors(t){const e=RI(null,t.length);let n=t.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],i=s.map((t=>t.name));for(let r=0;r<t.length;++r){const a=i.indexOf(t[r]);if(-1!==a&&(e[r]=s[a],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw e.forEach(((e,r)=>{null==e&&n.push(t[r])})),new kI(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return e}predictLoop(t,e=32,n=!1){return uw((()=>{const r=this.checkNumSamples(t);if(n)throw new II("Verbose predictLoop() is not implemented yet.");const s=DR(r,e),i=this.outputs.map((t=>[]));for(let e=0;e<s.length;++e)uw((()=>{const n=s[e][0],r=s[e][1],i=RR(t,n,r),a=[];if(Array.isArray(i))for(let t=0;t<i.length;++t)a.push({key:this.inputs[t],value:i[t]});else a.push({key:this.inputs[0],value:i});const o=new wA(a);return TA(this.outputs,o)})).forEach(((t,e)=>i[e].push(t)));return LI(i.map((t=>Gw(t,0))))}))}predict(t,e={}){const n=LR(t);zR(n,this.inputNames,this.feedInputShapes,!1);try{const r=null==e.batchSize?32:e.batchSize;return AR(r),this.predictLoop(n,r)}finally{FR(n,t)}}predictOnBatch(t){zR(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,r){if(null==this.optimizer_)throw new EI("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let t=0;t<this.feedOutputShapes.length;++t){const e=this.feedOutputShapes[t];this.feedLossFns[t]===eR?s.push(e.slice(0,e.length-1).concat([1])):s.push(e)}if(function(t,e,n){const r=VI(t.map((t=>t.shape[0])));r.sort();const s=VI(e.map((t=>t.shape[0])));if(s.sort(),r.length>1)throw new kI(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((t=>t.shape)))}`);if(s.length>1)throw new kI(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((t=>t.shape)))}`);if(r.length>0&&s.length>0&&!jf(r,s))throw new kI(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(t=OR(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=OR(e,this.feedOutputNames,s,!1,"target")),function(t,e,n){const r=[JA,nR,tR];for(let s=0;s<t.length;++s){const i=t[s],a=e[s],o=n[s];if(null!=a){if(a===tR&&1===i.shape[i.shape.length-1])throw new kI(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(a)){const t=i.shape.slice(1),e=o.slice(1);for(let n=0;n<t.length;++n){const r=t[n],s=e[n];if(null!=s&&r!==s)throw new kI(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&t[0].shape[0]%r!=0)throw new kI(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,r,s=!0,i){const[a,o]=this.standardizeUserDataXY(t,e,s,i);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const t=TR(r,this.outputNames);l=[];for(let e=0;e<t.length;++e)l.push(await MR(o[e],null,t[e]))}return[a,o,l]}testLoop(t,e,n,r=0,s){return uw((()=>{const i=this.checkNumSamples(e,n,s,"steps"),a=[];if(r>0)throw new II("Verbose mode is not implemented yet.");if(null!=s)throw new II("steps mode in testLoop() is not implemented yet");{const r=DR(i,n),s=x_(yC(0,i));for(let n=0;n<r.length;++n){const i=r[n][0],o=r[n][1],l=_C(s,i,o-i),u=NR(e,l),c=t(u);if(0===n)for(let t=0;t<c.length;++t)a.push(mw(0));for(let t=0;t<c.length;++t){const e=c[t];a[t]=yw(a[t],bS(o-i,e))}}for(let t=0;t<a.length;++t)a[t]=sS(a[t],i)}return a}))}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){const r=t[n];let s=r;DI(t,r)>1&&(s+=`_${DI(t.slice(0,n),r)}`),e.push(s)}return e}makeTrainFunction(){return t=>{const e=[],n=t.slice(0,this.inputs.length),r=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],a=this.collectedTrainableWeights.map((t=>t.read()));return[this.optimizer_.minimize((()=>{const t=[];for(let e=0;e<this.inputs.length;++e)t.push({key:this.inputs[e],value:n[e]});const a=new wA(t),o=TA(this.outputs,a,{training:!0});let l;for(let t=0;t<this.lossFunctions.length;++t){let n=(0,this.lossFunctions[t])(r[t],o[t]);null!=s[t]&&(n=ER(n,s[t]));const i=CS(n);e.push(i),l=0===t?n:yw(l,n)}for(let t=0;t<this.metricsTensors.length;++t){let n;if(this.outputs.length>1&&t<this.outputs.length)n=e[t];else{const e=this.metricsTensors[t][0],s=this.metricsTensors[t][1];n=CS(e(r[s],o[s]))}hw(n),i.push(n)}return l=CS(l),this.calculateLosses().forEach((t=>{l=yw(l,t)})),l}),!0,a)].concat(i)}}makeTestFunction(){this.testFunction=t=>uw((()=>{const e=[];let n;const r=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let t=0;t<this.inputs.length;++t)i.push({key:this.inputs[t],value:r[t]});const a=new wA(i),o=TA(this.outputs,a);for(let t=0;t<this.lossFunctions.length;++t){const r=this.lossFunctions[t],i=CS(r(s[t],o[t]));n=0===t?i:yw(n,i),e.push(n)}for(let t=0;t<this.metricsTensors.length;++t){const n=this.metricsTensors[t][0],r=this.metricsTensors[t][1],i=CS(n(s[r],o[r]));e.push(i)}return e}))}async fit(t,e,n={}){return async function(t,e,n,r={}){if(t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let s,i,a,o,l,u,c,h,d;t.isTraining=!0;try{const p=null==r.batchSize?32:r.batchSize;AR(p);const f=!1,m=await t.standardizeUserData(e,n,r.sampleWeight,r.classWeight,f,p);s=m[0],i=m[1],d=m[2];let g,x=!1;if(null!=r.validationData&&r.validationData.length>0){if(x=!0,2!==r.validationData.length)throw 3===r.validationData.length?new II("validationData including sample weights is not supported yet."):new kI(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);l=r.validationData[0],u=r.validationData[1];const e=!0,n=await t.standardizeUserData(l,u,null,null,e,p);c=n[0],h=n[1],g=c.concat(h)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){x=!0;const t=Math.floor(s[0].shape[0]*(1-r.validationSplit)),e=s[0].shape[0];c=RR(s,t,e),a=s,s=RR(s,0,t),h=RR(i,t,e),o=i,i=RR(i,0,t),g=c.concat(h)}else null!=r.validationSteps&&(x=!0);const y=s.concat(i).concat(d);t.checkTrainableWeightsConsistency();const v=t.makeTrainFunction(),b=t.getDedupedMetricsNames();let w,S;x?(t.makeTestFunction(),w=t.testFunction,S=b.slice().concat(b.map((t=>"val_"+t)))):(w=null,g=[],S=b.slice());const _=jA(r.callbacks,r.yieldEvery),T=await async function(t,e,n,r,s,i,a,o,l,u,c,h,d,p,f){null==s&&(s=32),null==i&&(i=1),null==c&&(c=!0),null==d&&(d=0);let m=!1;null!=l&&null!=u&&(m=!0);const g=t.checkNumSamples(n,s,p,"steps_per_epoch");let x;null!=g&&(x=yC(0,g)),null==a&&(a=1);const{callbackList:y,history:v}=XA(o,a,i,d,g,p,s,m,h);y.setModel(t),t.history=v,await y.onTrainBegin(),t.stopTraining_=!1;for(let a=d;a<i;++a){await y.onEpochBegin(a);const i={};{if("batch"===c)throw new II("batch shuffling is not implemneted yet");c&&$f(x);const a=x_(x),o=DR(g,s);for(let c=0;c<o.length;++c){const h={};if(await y.onBatchBegin(c,h),uw((()=>{const d=o[c][0],p=o[c][1],f=_C(a,d,p-d);h.batch=c,h.size=p-d;const g=NR(n,f),x=e(g);for(let t=0;t<r.length;++t){const e=r[t],n=x[t];h[e]=n,hw(n)}if(c===o.length-1&&m){const e=t.testLoop(l,u,s);for(let t=0;t<r.length;++t){const n=r[t],s=e[t];hw(s),i["val_"+n]=s}}})),await y.onBatchEnd(c,h),zA(h),t.stopTraining_)break}a.dispose()}if(await y.onEpochEnd(a,i),t.stopTraining_)break}return await y.onTrainEnd(),await t.history.syncData(),t.history}(t,v,y,b,p,r.epochs,r.verbose,_,w,g,r.shuffle,S,r.initialEpoch,null);return T}finally{t.isTraining=!1,FR(s,e),FR(i,n),FR(a,e),FR(o,n),FR(c,l),FR(h,u),null!=d&&cw(d)}}(this,t,e,n)}async fitDataset(t,e){return async function(t,e,n){const r=null!=n.batchesPerEpoch;if(Uf(null!=t.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Uf(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Uf(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Uf(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Uf(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const s=null!=n.validationData;let i,a;if(s)if(CR(n.validationData))Uf(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const t=function(t){if(3===t.length)throw new II("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}(n.validationData);i=t.xs,a=t.ys}const o=t.makeTrainFunction(),l=t.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map((t=>"val_"+t))):l.slice();const c=jA(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=XA(c,h,n.epochs,null,null,function(t,e){let n=null;return null!=e.batchesPerEpoch?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}(e,n),null,s,u);d.setModel(t),t.history=p,await d.onTrainBegin(),t.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await e.iterator();for(;f<n.epochs;){const u={};await d.onEpochBegin(f);let c=0,h=0;for(r||(m=await e.iterator());!r||c<n.batchesPerEpoch;){const e=await m.next();if(r&&e.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=e.value){const{xs:r,ys:s}=kR(t,e.value),i={};i.batch=h,i.size=r[0].shape[0],await d.onBatchBegin(h,i);const a=[];if(null!=n.classWeight){const e=TR(n.classWeight,t.outputNames);for(let t=0;t<e.length;++t)a.push(await MR(s[t],null,e[t]))}const u=r.concat(s).concat(a),p=o(u);cw(u);for(let t=0;t<l.length;++t){const e=l[t],n=p[t];i[e]=n,hw(n)}await d.onBatchEnd(h,i),zA(i),h++,c++}if(r?c>=n.batchesPerEpoch:e.done){if(s){let e;e=CR(n.validationData)?FI(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):FI(t.evaluate(i,a,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<t.metricsNames.length;++n)u[`val_${t.metricsNames[n]}`]=e[n]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(f,u),f++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}(this,t,e)}async trainOnBatch(t,e){const n=await this.standardizeUserData(t,e),r=n[0],s=n[1],i=this.makeTrainFunction()(r.concat(s)),a=[];for(const t of i){const e=await t.data();a.push(e[0])}return cw(i),FR(n[0],t),FR(n[1],e),LI(a)}getNamedWeights(t){const e=[],n=null!=t&&t.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let t=0;t<r.length;++t)n&&!r[t].trainable||e.push({name:r[t].originalName,tensor:s[t]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const e=lw().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-lw().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=PI(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if("string"!=typeof t)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map((t=>PI(t)))}else{const e=Object.keys(this.loss);t={};const n=this.loss;for(const r of e){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");t[r]=PI(n[r])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[PI(fR(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((t=>PI(fR(t))));{const t={};for(const e in this.metrics)t[e]=PI(fR(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const e=KA(wR(t.optimizer_config));let n,r;if("string"==typeof t.loss)n=$I(t.loss);else if(Array.isArray(t.loss))n=t.loss.map((t=>$I(t)));else if(null!=t.loss){n={};for(const e in t.loss)n[e]=$I(t.loss[e])}if(Array.isArray(t.metrics))r=t.metrics.map((t=>$I(t)));else if(null!=t.metrics){r={};for(const e in t.metrics)r[e]=$I(t.metrics[e])}this.compile({loss:n,metrics:r,optimizer:e})}async save(t,e){if("string"==typeof t){const e=(n=t,rb.getSaveHandlers(n));if(0===e.length)throw new kI(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new kI(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}var n;if(null==t.save)throw new kI("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await Yv(this.getNamedWeights(e)),s={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v3.18.0",convertedBy:null};if(null!=e&&e.includeOptimizer&&null!=this.optimizer){s.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:e,specs:n}=await Yv(await this.optimizer.getWeights(),t);r.specs.push(...n),r.data=tb([r.data,e])}if(null!=this.userDefinedMetadata){const t=!0;mR(this.userDefinedMetadata,this.name,t),s.userDefinedMetadata=this.userDefinedMetadata}return s.weightData=r.data,s.weightSpecs=r.specs,t.save(s)}setUserDefinedMetadata(t){mR(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}BR.className="Model",aw(BR);class UR extends BR{}UR.className="Functional",aw(UR);class WR extends BR{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:QI("sequential_"),null!=t.layers)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some((t=>t<0)))throw new kI(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof WR||t instanceof BR;let n;if(e){if(n=t,1!==n.outputs.length)throw new kI("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new kI("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new kI("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const e=function(t){if(null==t.batchShape&&null==t.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=t.batchShape&&null!=t.shape)throw new kI("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;null!=t.shape&&null==e&&(e=[null].concat(t.shape));let n=t.dtype;return null==n&&(n="float32"),new bA({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(e)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==t.inboundNodes.length)throw new kI(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new kI("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=vA(this.outputs[0])}this.inboundNodes=[],new gA({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:RI(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs[0].shape})}else{const e=t.apply(this.outputs[0]);if(Array.isArray(e))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[e],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return null==this.model&&this.build(),this.model.call(t,e)}build(t){if(lA(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new BR({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new EI("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new EI("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return null==this.model&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new EI("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new EI("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},r=!1){let s,i={};if(e instanceof Array){if(null==e[0].className||"Merge"===e[0].className)throw new kI("Legacy serialization format not supported yet.");s=e}else Uf(null!=e.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),s=e.layers,delete e.layers,i=e;const a=new t(i);if(!(a instanceof WR))throw new II(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const t of s){const e=KA(t,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),a.add(e)}return a}set stopTraining(t){if(null==this.model)throw new kI("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new kI("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}}WR.className="Sequential",aw(WR);class VR extends sw{getConfig(){return{}}}class GR extends VR{apply(t,e=1){return function(t,e=1){if(1!==e)throw new II(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return iS(t)}(t,e)}}GR.className="elu",aw(GR);class HR extends VR{apply(t){return n_(t)}}HR.className="selu",aw(HR);class jR extends VR{apply(t){return t_(t)}}jR.className="relu",aw(jR);class qR extends VR{apply(t){return uw((()=>AS(6,t_(t))))}}qR.className="relu6",aw(qR);class XR extends VR{apply(t){return t}}XR.className="linear",aw(XR);class KR extends VR{apply(t){return s_(t)}}KR.className="sigmoid",aw(KR);class YR extends VR{apply(t){return function(t){return uw((()=>{const e=yw(.5,bS(.2,t));return Vw(e,0,1)}))}(t)}}YR.className="hardSigmoid",aw(YR);class JR extends VR{apply(t){return h_(t)}}JR.className="softplus",aw(JR);class ZR extends VR{apply(t){return function(t){return uw((()=>sS(t,yw(xw(t),1))))}(t)}}ZR.className="softsign",aw(ZR);class QR extends VR{apply(t){return g_(t)}}QR.className="tanh",aw(QR);class tN extends VR{apply(t,e=-1){return c_(t,e)}}tN.className="softmax",aw(tN);class eN extends VR{apply(t,e=-1){return _S(t,e)}}eN.className="logSoftmax",aw(eN);class nN extends VR{apply(t,e=1){return uw((()=>bS(s_(bS(t,e)),t)))}}nN.className="swish",aw(nN);class rN extends VR{apply(t){return uw((()=>bS(t,g_(h_(t)))))}}function sN(t){return t.getClassName()}function iN(t,e={}){return UI(t,iw.getMap().classNameMap,e,"activation")}function aN(t){if(null==t){return iN({className:"linear",config:{}})}if("string"==typeof t){const e={};return e.className=t,e.config={},iN(e)}return t instanceof VR?t:iN(t)}rN.className="mish",aw(rN);class oN extends sw{}class lN extends oN{constructor(t){super(),function(t){if(null!=t&&"object"!=typeof t)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return uw((()=>{let e=GS([1]);return this.hasL1&&(e=yw(e,SS(bS(this.l1,xw(t))))),this.hasL2&&(e=yw(e,SS(bS(this.l2,NC(t))))),Pw(e,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}lN.className="L1L2",aw(lN);const uN={l1l2:"L1L2"};function cN(t){return zI(t)}function hN(t,e={}){return UI(t,iw.getMap().classNameMap,e,"regularizer")}function dN(t){return null==t?null:"string"==typeof t?hN({className:t in uN?uN[t]:t,config:{}}):t instanceof oN?t:hN(t)}class pN extends yA{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,e){t=oA(t);let n=t_(t);return null!=this.maxValue&&(n=Vw(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}pN.className="ReLU",aw(pN);class fN extends yA{constructor(t){super(null==t?{}:t),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=oA(t);return gS(n,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}fN.className="LeakyReLU",aw(fN);class mN extends yA{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=sA(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=dN(t.alphaRegularizer),this.alphaConstraint=$A(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new kI(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const e=(t=lA(t)).slice(1);if(null!=this.sharedAxes)for(const t of this.sharedAxes)e[t-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let e=1;e<t.length;++e)n[e]=t[e];this.inputSpec=[new pA({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=oA(t),XS(t,this.alpha.read())}getConfig(){const t={alphaInitializer:rA(this.alphaInitializer),alphaRegularizer:cN(this.alphaRegularizer),alphaConstraint:FA(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}mN.className="PReLU",aw(mN);class gN extends yA{constructor(t){if(super(null==t?{}:t),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new II(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,e){const n=oA(t);return iS(n)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}gN.className="ELU",aw(gN);class xN extends yA{constructor(t){super(null==t?{}:t),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,e){const n=oA(t);return bS(n,Cb(fS(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}xN.className="ThresholdedReLU",aw(xN);class yN extends yA{constructor(t){super(null==t?{}:t),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new tN).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,e){const n=oA(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function vN(t,e,n){if("number"==typeof t)return RI(t,e);if(t.length!==e)throw new kI(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let s=0;s<e;++s){const i=t[s];if((r=i)!==parseInt(r.toString(),10))throw new kI(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${i}`)}return t;var r}function bN(t,e,n,r,s=1){if(null==t)return t;let i;return i="same"===n?t:t-(e+(e-1)*(s-1))+1,Math.floor((i+r-1)/r)}function wN(t,e,n,r){if(null==t)return null;if("valid"===r)t=t*e+xC([n-e,0]);else{if("same"!==r)throw new kI(`Unsupport padding mode: ${r}.`);t*=e}return t}function SN(t,e){return uw((()=>(aC(e),"channelsFirst"===e?M_(t,[0,2,3,1]):t)))}function _N(t,e){return uw((()=>(aC(e),"channelsFirst"===e?M_(t,[0,2,3,4,1]):t)))}function TN(t,e,n,r=[1,1],s="valid",i,a,o=null){return uw((()=>{if(null==i&&(i="channelsLast"),aC(i),3!==t.rank&&4!==t.rank)throw new kI(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(3!==e.rank&&4!==e.rank)throw new kI(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=SN(t,i);if("causal"===s)throw new II("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=O_({x:l,filter:e,strides:r,pad:"same"===s?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===i&&(l=M_(l,[0,3,1,2])),l}))}yN.className="Softmax",aw(yN);class MN extends yA{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",MN.verifyArgs(e),this.rank=t,qI(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new II(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=vN(e.kernelSize,t,"kernelSize"),this.strides=vN(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,oC(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,aC(this.dataFormat),this.activation=aN(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=sA(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=$A(e.biasConstraint),this.biasRegularizer=dN(e.biasRegularizer),this.activityRegularizer=dN(e.activityRegularizer),this.dilationRate=vN(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new kI(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new kI(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new kI(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(NI("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!jI(t.kernelSize,"number",1,3))throw new kI(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:sN(this.activation),useBias:this.useBias,biasInitializer:rA(this.biasInitializer),biasRegularizer:cN(this.biasRegularizer),activityRegularizer:cN(this.activityRegularizer),biasConstraint:FA(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class EN extends MN{constructor(t,e){super(t,e),this.kernel=null,EN.verifyArgs(e),this.filters=e.filters,qI(this.filters,"filters"),this.kernelInitializer=sA(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=$A(e.kernelConstraint),this.kernelRegularizer=dN(e.kernelRegularizer)}build(t){t=lA(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new kI(`The channel dimension of the input should be defined. Found ${t[e]}`);const n=t[e],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return uw((()=>{let e;t=oA(t);const n=null==this.bias?null:this.bias.read(),r=KI(this.activation.getClassName());if(null!=r&&2===this.rank)e=TN(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=function(t,e,n,r=1,s="valid",i,a=1){return uw((()=>{if(null==i&&(i="channelsLast"),aC(i),3!==t.shape.length)throw new kI(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(3!==e.shape.length)throw new kI(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new kI(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===i&&(t=M_(t,[0,2,1])),"causal"===s)throw new II("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Yw(t,e,r,"same"===s?"same":"valid","NWC",a);return null!=n&&(o=LC(o,n)),o}))}(t,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=TN(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new II("convolutions greater than 3D are not implemented yet.");e=function(t,e,n,r=[1,1,1],s="valid",i,a){return uw((()=>{if(null==i&&(i="channelsLast"),aC(i),4!==t.rank&&5!==t.rank)throw new kI(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(4!==e.rank&&5!==e.rank)throw new kI(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let o=_N(t,i);if("causal"===s)throw new II("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Qw(o,e,r,"same"===s?"same":"valid","NDHWC",a),null!=n&&(o=LC(o,n)),"channelsFirst"===i&&(o=M_(o,[0,4,1,2,3])),o}))}(t,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e}))}computeOutputShape(t){t=lA(t);const e=[],n="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let t=0;t<n.length;++t){const r=bN(n[t],this.kernelSize[t],this.padding,this.strides[t],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[t]);e.push(r)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:rA(this.kernelInitializer),kernelRegularizer:cN(this.kernelRegularizer),kernelConstraint:FA(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new kI(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class kN extends EN{constructor(t){super(2,t),kN.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!jI(t.kernelSize,"number",1,2))throw new kI(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}kN.className="Conv2D",aw(kN);class IN extends EN{constructor(t){super(3,t),IN.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new kI(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}IN.className="Conv3D",aw(IN);class CN extends kN{constructor(t){if(super(t),this.inputSpec=[new pA({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new kI(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=lA(t)).length)throw new kI("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new kI("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new pA({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return uw((()=>{let e=oA(t);if(4!==e.shape.length)throw new kI(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape,r=n[0];let s,i;"channelsFirst"===this.dataFormat?(s=2,i=3):(s=1,i=2);const a=n[s],o=n[i],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],h=this.strides[1],d=[r,wN(a,c,l,this.padding),wN(o,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=M_(e,[0,2,3,1]));let p=Zw(e,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=M_(p,[0,3,1,2])),null!=this.bias&&(p=LC(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(t){const e=(t=lA(t)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const i=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[r]=wN(e[r],o,i,this.padding),e[s]=wN(e[s],l,a,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}CN.className="Conv2DTranspose",aw(CN);class AN extends IN{constructor(t){if(super(t),this.inputSpec=[new pA({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new kI(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(5!==(t=lA(t)).length)throw new kI("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new kI("The channel dimension of the inputs should be defined. Found `None`.");const n=t[e],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new pA({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return uw((()=>{let e=oA(t);if(5!==e.shape.length)throw new kI(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${e.shape.length}`);const n=e.shape,r=n[0];let s,i,a;"channelsFirst"===this.dataFormat?(a=2,s=3,i=4):(a=1,s=2,i=3);const o=n[a],l=n[s],u=n[i],c=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,wN(o,p,c,this.padding),wN(l,f,h,this.padding),wN(u,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(e=M_(e,[0,2,3,4,1]));let x=eS(e,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(x=M_(x,[0,4,1,2,3])),null!==this.bias&&(x=LC(x,this.bias.read(),this.dataFormat)),null!==this.activation&&(x=this.activation.apply(x)),x}))}computeOutputShape(t){const e=(t=lA(t)).slice();let n,r,s,i;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,i=4):(n=4,r=1,s=2,i=3);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],h=this.strides[2];return e[n]=this.filters,e[r]=wN(e[r],u,a,this.padding),e[s]=wN(e[s],c,o,this.padding),e[i]=wN(e[i],h,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}AN.className="Conv3DTranspose",aw(AN);class RN extends EN{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==e.filters)throw new kI("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=e.kernelInitializer||null!=e.kernelRegularizer||null!=e.kernelConstraint)throw new kI("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=e.padding&&"same"!==e.padding&&"valid"!==e.padding)throw new kI(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=sA(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=dN(e.depthwiseRegularizer),this.depthwiseConstraint=$A(e.depthwiseConstraint),this.pointwiseInitializer=sA(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=dN(e.pointwiseRegularizer),this.pointwiseConstraint=$A(e.pointwiseConstraint)}build(t){if((t=lA(t)).length<this.rank+2)throw new kI(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e]||t[e]<0)throw new kI(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const n=t[e],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let t=0;t<this.rank;++t)s.push(1);s.push(n*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new pA({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return uw((()=>{let e;if(t=oA(t),1===this.rank)throw new II("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=M_(t,[0,2,3,1])),e=r_(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=LC(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=M_(e,[0,3,1,2])),e}))}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=rA(this.depthwiseInitializer),t.pointwiseInitializer=rA(this.pointwiseInitializer),t.depthwiseRegularizer=cN(this.depthwiseRegularizer),t.pointwiseRegularizer=cN(this.pointwiseRegularizer),t.depthwiseConstraint=FA(this.depthwiseConstraint),t.pointwiseConstraint=FA(this.pointwiseConstraint),t}}RN.className="SeparableConv";class NN extends RN{constructor(t){super(2,t)}}NN.className="SeparableConv2D",aw(NN);class DN extends EN{constructor(t){super(1,t),DN.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!jI(t.kernelSize,"number",1,1))throw new kI(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}DN.className="Conv1D",aw(DN);class LN extends yA{constructor(t){super(t),"number"==typeof t.cropping?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return uw((()=>{if(t=oA(t),"channelsLast"===this.dataFormat){const e=MC(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return MC(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=MC(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return MC(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}LN.className="Cropping2D",aw(LN);class FN extends yA{constructor(t){var e;super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,aC(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,e=this.interpolation,HI(eC,"InterpolationFormat",e)}computeOutputShape(t){if("channelsFirst"===this.dataFormat){const e=null==t[2]?null:this.size[0]*t[2],n=null==t[3]?null:this.size[1]*t[3];return[t[0],t[1],e,n]}{const e=null==t[1]?null:this.size[0]*t[1],n=null==t[2]?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return uw((()=>{let e=oA(t);const n=e.shape;if("channelsFirst"===this.dataFormat){e=M_(e,[0,2,3,1]);const t=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?CT.resizeNearestNeighbor(e,[t,r]):CT.resizeBilinear(e,[t,r]);return M_(s,[0,3,1,2])}{const t=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?CT.resizeNearestNeighbor(e,[t,r]):CT.resizeBilinear(e,[t,r])}}))}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}FN.className="UpSampling2D",aw(FN);class PN extends MN{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=sA(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=$A(t.depthwiseConstraint),this.depthwiseRegularizer=dN(t.depthwiseRegularizer)}build(t){if((t=lA(t)).length<4)throw new kI(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e="channelsFirst"===this.dataFormat?1:3;if(null==t[e]||t[e]<0)throw new kI(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const n=t[e],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return uw((()=>{let e=function(t,e,n=[1,1],r="valid",s,i){return uw((()=>{null==s&&(s="channelsLast"),aC(s);let a=SN(t,s);if(4!==t.rank)throw new kI(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(4!==e.rank)throw new kI(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=nS(a,e,n,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===s&&(a=M_(a,[0,3,1,2])),a}))}(t=oA(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=LC(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e}))}computeOutputShape(t){t=lA(t);const e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=bN(e,this.kernelSize[0],this.padding,this.strides[0]),i=bN(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],r,s,i]:[t[0],s,i,r]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=rA(this.depthwiseInitializer),t.depthwiseRegularizer=cN(this.depthwiseRegularizer),t.depthwiseConstraint=FA(this.depthwiseRegularizer),t}}function $N(t,e,n,r){if(Array.isArray(t)){if(null!=e||null!=n)throw new kI("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function s(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=s(e),constants:n=s(n)}}function ON(t,e,n,r=!1,s,i,a=!1,o=!1){return uw((()=>{const l=e.shape.length;if(l<3)throw new kI(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(yC(2,l));if(e=M_(e,u),null!=i)throw new II("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=Cb(Cb(s,"bool"),"float32")).rank===l-1&&(s=lS(s,-1)),s=M_(s,u)),r&&(e=e_(e,0),null!=s&&(s=e_(s,0)));const c=[];let h,d=n;const p=e.shape[0],f=v_(e);let m,g;null!=s&&(m=v_(s));for(let e=0;e<p;++e){const n=f[e],r=uw((()=>t(n,d)));if(null==s)h=r[0],d=r[1];else{const t=uw((()=>{const t=m[e],n=wS(jS(t),t);return{output:yw(bS(r[0],t),bS(d[0],n)),newStates:d.map(((e,s)=>yw(bS(r[1][s],t),bS(e,n))))}}));h=t.output,d=t.newStates}o&&c.push(h)}return o&&(g=m_(c,1)),[h,g,d]}))}PN.className="DepthwiseConv2D",aw(PN);class zN extends yA{constructor(t){let e;if(super(t),null==t.cell)throw new kI("cell property is missing for the constructor of RNN.");if(e=Array.isArray(t.cell)?new qN({cells:t.cell}):t.cell,null==e.stateSize)throw new kI("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new pA({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?yC(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((t=>null)):this.states_}setStates(t){this.states_=t}computeOutputShape(t){iA(t)&&(t=t[0]);let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const n=e[0];let r;if(r=this.returnSequences?[t[0],t[1],n]:[t[0],n],this.returnState){const n=[];for(const r of e)n.push([t[0],r]);return[r].concat(n)}return r}computeMask(t,e){return uw((()=>{Array.isArray(e)&&(e=e[0]);const t=this.returnSequences?e:null;if(this.returnState){const e=this.states.map((t=>null));return[t].concat(e)}return t}))}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new II("Constants support is not implemented in RNN yet.");iA(t)&&(t=t[0]);const e=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new pA({shape:[e,null,...n]});const r=[t[0]].concat(t.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!jf(this.stateSpec.map((t=>t.shape[t.shape.length-1])),s))throw new kI(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map((t=>new pA({shape:[null,t]})));this.stateful&&this.resetStates()}resetStates(t,e=!1){uw((()=>{if(!this.stateful)throw new MI("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new kI("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>GS([n,t]))):this.states_=[GS([n,this.cell.stateSize])];else if(null==t)cw(this.states_),null!=this.keptStates&&(cw(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((t=>GS([n,t]))):this.states_[0]=GS([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new kI(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===e?this.keptStates.push(this.states_.slice()):cw(this.states_);for(let e=0;e<this.states_.length;++e){const r=t[e],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,i=[n,s];if(!jf(r.shape,i))throw new kI(`State ${e} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${r.shape}`);this.states_[e]=r}}this.states_=this.states_.map((t=>hw(t.clone())))}))}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const s=$N(t,n,r,this.numConstants);t=s.inputs,n=s.initialState,r=s.constants;let i=[],a=[];if(null!=n){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(const t of n)this.stateSpec.push(new pA({shape:t.shape}));a=a.concat(this.stateSpec)}if(null!=r&&(e.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof fA){const n=[t].concat(i),r=this.inputSpec.concat(a),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,e);return this.inputSpec=s,o}return super.apply(t,e)}call(t,e){return uw((()=>{const n=null==e?null:e.mask,r=null==e?null:e.training;let s=null==e?null:e.initialState;t=oA(t),null==s&&(s=this.stateful?this.states_:this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new kI(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},o=ON(((t,e)=>{const n=this.cell.call([t].concat(e),a);return[n[0],n.slice(1)]}),t,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h}))}getInitialState(t){return uw((()=>{let e=GS(t.shape);return e=SS(e,[1,2]),e=SC(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((t=>t>1?IC(e,[1,t]):e)):this.cell.stateSize>1?[IC(e,[1,this.cell.stateSize])]:[e]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===zN.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){const r=KA(e.cell,n);return new t(Object.assign(e,{cell:r}))}}zN.className="RNN",aw(zN);class BN extends yA{}class UN extends BN{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,qI(this.units,"units"),this.activation=aN(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=sA(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sA(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sA(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=dN(t.kernelRegularizer),this.recurrentRegularizer=dN(t.recurrentRegularizer),this.biasRegularizer=dN(t.biasRegularizer),this.kernelConstraint=$A(t.kernelConstraint),this.recurrentConstraint=$A(t.recurrentConstraint),this.biasConstraint=$A(t.biasConstraint),this.dropout=gC([1,xC([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=gC([1,xC([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=lA(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return uw((()=>{if(2!==t.length)throw new kI(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];const r=null!=e.training&&e.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=XN({ones:()=>jS(t),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=XN({ones:()=>jS(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;s=AC(null!=i?bS(t,i):t,this.kernel.read()),null!=this.bias&&(s=LC(s,this.bias.read())),null!=a&&(n=bS(n,a));let o=yw(s,AC(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:sN(this.activation),useBias:this.useBias,kernelInitializer:rA(this.kernelInitializer),recurrentInitializer:rA(this.recurrentInitializer),biasInitializer:rA(this.biasInitializer),kernelRegularizer:cN(this.kernelRegularizer),recurrentRegularizer:cN(this.recurrentRegularizer),biasRegularizer:cN(this.biasRegularizer),activityRegularizer:cN(this.activityRegularizer),kernelConstraint:FA(this.kernelConstraint),recurrentConstraint:FA(this.recurrentConstraint),biasConstraint:FA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}UN.className="SimpleRNNCell",aw(UN);class WN extends zN{constructor(t){t.cell=new UN(t),super(t)}call(t,e){return uw((()=>{null!=this.cell.dropoutMask&&(cw(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cw(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,s=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:s})}))}static fromConfig(t,e){return new t(e)}}WN.className="SimpleRNN",aw(WN);class VN extends BN{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new kI("GRUCell does not support reset_after parameter set to true.");this.units=t.units,qI(this.units,"units"),this.activation=aN(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=aN(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=sA(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sA(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sA(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=dN(t.kernelRegularizer),this.recurrentRegularizer=dN(t.recurrentRegularizer),this.biasRegularizer=dN(t.biasRegularizer),this.kernelConstraint=$A(t.kernelConstraint),this.recurrentConstraint=$A(t.recurrentConstraint),this.biasConstraint=$A(t.biasConstraint),this.dropout=gC([1,xC([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=gC([1,xC([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=lA(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return uw((()=>{if(2!==t.length)throw new kI(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const n=null!=e.training&&e.training;let r=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=XN({ones:()=>jS(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=XN({ones:()=>jS(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,i=this.recurrentDropoutMask;let a,o,l;0<this.dropout&&this.dropout<1&&(t=bS(t,s[0]));let u=AC(t,this.kernel.read());this.useBias&&(u=LC(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=bS(r,i[0]));const c=this.recurrentKernel.read(),[h,d]=d_(c,[2*this.units,this.units],c.rank-1),p=AC(r,h),[f,m,g]=d_(u,3,u.rank-1),[x,y]=d_(p,2,p.rank-1);a=this.recurrentActivation.apply(yw(f,x)),o=this.recurrentActivation.apply(yw(m,y));const v=AC(bS(o,r),d);l=this.activation.apply(yw(g,v));const b=yw(bS(a,r),bS(yw(1,US(a)),l));return[b,b]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:sN(this.activation),recurrentActivation:sN(this.recurrentActivation),useBias:this.useBias,kernelInitializer:rA(this.kernelInitializer),recurrentInitializer:rA(this.recurrentInitializer),biasInitializer:rA(this.biasInitializer),kernelRegularizer:cN(this.kernelRegularizer),recurrentRegularizer:cN(this.recurrentRegularizer),biasRegularizer:cN(this.biasRegularizer),activityRegularizer:cN(this.activityRegularizer),kernelConstraint:FA(this.kernelConstraint),recurrentConstraint:FA(this.recurrentConstraint),biasConstraint:FA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}VN.className="GRUCell",aw(VN);class GN extends zN{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new VN(t),super(t)}call(t,e){return uw((()=>{null!=this.cell.dropoutMask&&(cw(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cw(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,s=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:s})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}GN.className="GRU",aw(GN);class HN extends BN{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,qI(this.units,"units"),this.activation=aN(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=aN(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=sA(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=sA(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=sA(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=dN(t.kernelRegularizer),this.recurrentRegularizer=dN(t.recurrentRegularizer),this.biasRegularizer=dN(t.biasRegularizer),this.kernelConstraint=$A(t.kernelConstraint),this.recurrentConstraint=$A(t.recurrentConstraint),this.biasConstraint=$A(t.biasConstraint),this.dropout=gC([1,xC([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=gC([1,xC([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const n=(t=lA(t))[t.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,n=this.units;r=new((e=class extends zC{apply(e,r){const s=t.apply([n]),i=(new UC).apply([n]),a=t.apply([2*n]);return kC(kC(s,i),a)}}).className="CustomInit",e)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return uw((()=>{const n=null!=e.training&&e.training;if(3!==t.length)throw new kI(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=t[1];const s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=XN({ones:()=>jS(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=XN({ones:()=>jS(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(t=bS(t,i[0]));let h=AC(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=bS(r,a[0])),h=yw(h,AC(r,this.recurrentKernel.read())),this.useBias&&(h=LC(h,this.bias.read()));const[d,p,f,m]=d_(h,4,h.rank-1);o=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),u=yw(bS(l,s),bS(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=bS(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){const t=super.getConfig(),e={units:this.units,activation:sN(this.activation),recurrentActivation:sN(this.recurrentActivation),useBias:this.useBias,kernelInitializer:rA(this.kernelInitializer),recurrentInitializer:rA(this.recurrentInitializer),biasInitializer:rA(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:cN(this.kernelRegularizer),recurrentRegularizer:cN(this.recurrentRegularizer),biasRegularizer:cN(this.biasRegularizer),activityRegularizer:cN(this.activityRegularizer),kernelConstraint:FA(this.kernelConstraint),recurrentConstraint:FA(this.recurrentConstraint),biasConstraint:FA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}HN.className="LSTMCell",aw(HN);class jN extends zN{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new HN(t),super(t)}call(t,e){return uw((()=>{null!=this.cell.dropoutMask&&(cw(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cw(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==e?null:e.mask,r=null==e?null:e.training,s=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:s})}))}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}jN.className="LSTM",aw(jN);class qN extends BN{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return uw((()=>{let n=t.slice(1);const r=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?r.push(n.splice(0,t.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let i;for(let a=0;a<this.cells.length;++a){const o=this.cells[a];n=r[a],i=0===a?[t[0]].concat(n):[i[0]].concat(n),i=o.call(i,e),s.push(i.slice(1))}n=[];for(const t of s.slice().reverse())n.push(...t);return[i[0]].concat(n)}))}build(t){let e;iA(t)&&(t=t[0]),this.cells.forEach(((n,r)=>{cC(`RNNCell_${r}`,(()=>{n.build(t),e=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,t=[t[0],e]}))})),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map((t=>({className:t.getClassName(),config:t.getConfig()})))};return Object.assign({},t,e)}static fromConfig(t,e,n={}){const r=[];for(const t of e.cells)r.push(KA(t,n));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return hA(t)}setWeights(t){const e=[];for(const n of this.cells){const r=n.weights.length,s=t.splice(r);for(let t=0;t<n.weights.length;++t)e.push([n.weights[t],s[t]])}dA(e)}}function XN(t){const{ones:e,rate:n,training:r=!1,count:s=1,dropoutFunc:i}=t,a=()=>null!=i?i(e(),n):FC(e(),n),o=()=>PC(a,e,r);return!s||s<=1?hw(o().clone()):Array(s).fill(void 0).map(o).map((t=>hw(t.clone())))}qN.className="StackedRNNCells",aw(qN);var KN,YN;class JN extends zN{constructor(t){if(t.unroll)throw new II("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new II("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new pA({ndim:5})]}call(t,e){return uw((()=>{if(null!=this.cell.dropoutMask&&(cw(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cw(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new kI("ConvRNN2D cell does not support constants");const n=null==e?null:e.mask,r=null==e?null:e.training,s=null==e?null:e.initialState;return super.call(t,{mask:n,training:r,initialState:s})}))}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return uw((()=>{const{stateSize:e}=this.cell,n=t.shape,r=this.computeSingleOutputShape(n),s=GS([r[0],...r.slice(2)]);return Array.isArray(e)?Array(e.length).fill(s):[s]}))}resetStates(t,e=!1){uw((()=>{if(!this.stateful)throw new MI("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new kI("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>GS(s))):this.states_=[GS(s)];else if(null==t)cw(this.states_),null!=this.keptStates&&(cw(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>GS(s))):this.states_[0]=GS(s);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new kI(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):cw(this.states_);for(let e=0;e<this.states_.length;++e){const n=t[e],r=s;if(!jf(n.shape,r))throw new kI(`State ${e} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[e]=n}}this.states_=this.states_.map((t=>hw(t.clone())))}))}computeSingleOutputShape(t){const{dataFormat:e,filters:n,kernelSize:r,padding:s,strides:i,dilationRate:a}=this.cell,o="channelsFirst"===e,l=t[o?3:2],u=t[o?4:3],c=bN(l,r[0],s,i[0],a[0]),h=bN(u,r[1],s,i[1],a[1]);return[...t.slice(0,2),...o?[n,c,h]:[c,h,n]]}}JN.className="ConvRNN2D";class ZN extends HN{constructor(t){const{filters:e,kernelSize:n,strides:r,padding:s,dataFormat:i,dilationRate:a}=t;super(Object.assign({},t,{units:e})),this.filters=e,qI(this.filters,"filters"),this.kernelSize=vN(n,2,"kernelSize"),this.kernelSize.forEach((t=>qI(t,"kernelSize"))),this.strides=vN(r||1,2,"strides"),this.strides.forEach((t=>qI(t,"strides"))),this.padding=s||"valid",oC(this.padding),this.dataFormat=i||"channelsLast",aC(this.dataFormat),this.dilationRate=vN(a||1,2,"dilationRate"),this.dilationRate.forEach((t=>qI(t,"dilationRate")))}build(t){var e;t=lA(t);const n="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[n])throw new kI(`The channel dimension of the input should be defined. Found ${t[n]}`);const r=t[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;t=new((e=class extends zC{apply(t,e){return EC([n.apply([r]),HS([r]),n.apply([2*r])])}}).className="CustomInit",e)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return uw((()=>{if(3!==t.length)throw new kI(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const n=e.training||!1,r=t[0],s=t[1],i=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=XN({ones:()=>jS(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=(t,e,n)=>e&&e[n]?bS(e[n],t):t;let l=o(r,a,0),u=o(r,a,1),c=o(r,a,2),h=o(r,a,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=XN({ones:()=>jS(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=o(s,d,0),f=o(s,d,1),m=o(s,d,2),g=o(s,d,3);const[x,y,v,b]=d_(this.kernel.read(),4,3),[w,S,_,T]=this.useBias?d_(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,x,w,this.padding),u=this.inputConv(u,y,S,this.padding),c=this.inputConv(c,v,_,this.padding),h=this.inputConv(h,b,T,this.padding);const[M,E,k,I]=d_(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,M),f=this.recurrentConv(f,E),m=this.recurrentConv(m,k),g=this.recurrentConv(g,I);const C=this.recurrentActivation.apply(yw(l,p)),A=this.recurrentActivation.apply(yw(u,f)),R=yw(bS(A,i),bS(C,this.activation.apply(yw(c,m)))),N=bS(this.recurrentActivation.apply(yw(h,g)),this.activation.apply(R));return[N,N,R]}))}getConfig(){const t=super.getConfig(),{units:e}=t,n=function(t,e){var n={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&e.indexOf(r)<0&&(n[r]=t[r]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(t);s<r.length;s++)e.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(t,r[s])&&(n[r[s]]=t[r[s]])}return n}(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(t,e,n,r){const s=Kw(t,e,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?LC(s,n,this.dataFormat):s}recurrentConv(t,e){return Kw(t,e,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}ZN.className="ConvLSTM2DCell",aw(ZN);class QN extends JN{constructor(t){const e=new ZN(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}QN.className="ConvLSTM2D",aw(QN);class tD extends yA{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,n=[];for(let t=0;t<this.noiseShape.length;++t)n.push(null==this.noiseShape[t]?e[t]:this.noiseShape[t]);return n}call(t,e){return uw((()=>{this.invokeCallHook(t,e);const n=oA(t);if(0<this.rate&&this.rate<1){const t=null!=e.training&&e.training,r=this.getNoiseShape(n);return PC((()=>FC(n,this.rate,r,this.seed)),(()=>n),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}tD.className="Dropout",aw(tD);class eD extends tD{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}eD.className="SpatialDropout1D",aw(eD);class nD extends yA{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,qI(this.units,"units"),this.activation=aN(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=sA(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=sA(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=$A(t.kernelConstraint),this.biasConstraint=$A(t.biasConstraint),this.kernelRegularizer=dN(t.kernelRegularizer),this.biasRegularizer=dN(t.biasRegularizer),this.activityRegularizer=dN(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=lA(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=lA(t)).slice();return e[e.length-1]=this.units,e}call(t,e){return uw((()=>{this.invokeCallHook(t,e);const n=oA(t),r=KI(this.activation.getClassName());let s;return null!=r?s=AC(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=AC(n,this.kernel.read()),null!=this.bias&&(s=LC(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const t={units:this.units,activation:sN(this.activation),useBias:this.useBias,kernelInitializer:rA(this.kernelInitializer),biasInitializer:rA(this.biasInitializer),kernelRegularizer:cN(this.kernelRegularizer),biasRegularizer:cN(this.biasRegularizer),activityRegularizer:cN(this.activityRegularizer),kernelConstraint:FA(this.kernelConstraint),biasConstraint:FA(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}nD.className="Dense",aw(nD);class rD extends yA{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=lA(t);for(const e of t.slice(1))if(null==e)throw new kI(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],mC(t,1)]}call(t,e){return uw((()=>{this.invokeCallHook(t,e);let n=oA(t);if("channelsFirst"===this.dataFormat&&n.rank>1){const t=[0];for(let e=2;e<n.rank;++e)t.push(e);t.push(1),n=M_(n,t)}return function(t){if(t.rank<=1)throw new kI(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],mC(t.shape,1)];return Pw(t,e)}(n)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}rD.className="Flatten",aw(rD);class sD extends yA{constructor(t){super(t),this.supportsMasking=!0,this.activation=aN(t.activation)}call(t,e){return uw((()=>{this.invokeCallHook(t,e);const n=oA(t);return this.activation.apply(n)}))}getConfig(){const t={activation:sN(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}sD.className="Activation",aw(sD);class iD extends yA{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return uw((()=>{return t=oA(t),e=t,n=this.n,uw((()=>{if(2!==e.shape.length)throw new kI(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return IC(SC(e,1),[1,n,1])}));var e,n}))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}iD.className="RepeatVector",aw(iD);class aD extends yA{constructor(t){super(t),this.targetShape=t.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const n="Total size of new array must be unchanged.",r=e.slice();let s=1,i=null;for(let t=0;t<r.length;++t){const e=r[t];if(this.isUnknown(e)){if(null!==i)throw new kI("Can only specifiy one unknown dimension.");i=t}else s*=e}const a=mC(t);if(null!==i){if(0===s||a%s!=0)throw new kI(n);r[i]=a/s}else if(a!==s)throw new kI(n);return r}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return uw((()=>{this.invokeCallHook(t,e);const n=oA(t),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Pw(n,s)}))}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}aD.className="Reshape",aw(aD);class oD extends yA{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=yC(1,t.dims.length+1);if(!jf(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new pA({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=lA(t)).slice();return this.dims.forEach(((n,r)=>{e[r+1]=t[n]})),e}call(t,e){return M_(oA(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}oD.className="Permute",aw(oD);class lD extends yA{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const n=oA(t);return bw(WS(n,this.maskValue),-1)}call(t,e){return uw((()=>{this.invokeCallHook(t,e);const n=oA(t),r=bw(WS(n,this.maskValue),-1,!0);return bS(n,Cb(r,n.dtype))}))}}lD.className="Masking",aw(lD);class uD extends yA{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(FI(t.inputLength))}this.inputDim=t.inputDim,qI(this.inputDim,"inputDim"),this.outputDim=t.outputDim,qI(this.outputDim,"outputDim"),this.embeddingsInitializer=sA(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=dN(t.embeddingsRegularizer),this.activityRegularizer=dN(t.activityRegularizer),this.embeddingsConstraint=$A(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return uw((()=>this.maskZero?(t=oA(t),WS(t,S_(t))):null))}computeOutputShape(t){if(t=lA(t),null==this.inputLength)return[...t,this.outputDim];const e=FI(this.inputLength);if(e.length!==t.length-1)throw new kI(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let r=0;r<e.length;++r){const s=e[r],i=t[r+1];if(null!=s&&null!=i&&s!==i)throw new kI(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==s&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return uw((()=>{this.invokeCallHook(t,e);let n=oA(t);"int32"!==n.dtype&&(n=wC(n,"int32"));const r=RC(this.embeddings.read(),Pw(n,[n.size]));return Pw(r,lA(this.computeOutputShape(n.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:rA(this.embeddingsInitializer),embeddingsRegularizer:cN(this.embeddingsRegularizer),activityRegularizer:cN(this.activityRegularizer),embeddingsConstraint:FA(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}uD.className="Embedding",aw(uD);class cD extends yA{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new II}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const n=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const s=t[t.length-e.length+r],i=e[r];if(null==s||null==i||s<0||i<0)n.push(null);else if(1===s)n.push(i);else if(1===i)n.push(s);else{if(s!==i)throw new kI("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(s)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[lA(t)]),t.length<2)throw new kI(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const n of t)null!=n&&null!==n[0]&&e.push(n[0]);if(e=VI(e),e.length>1)throw new kI(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=null==t[0]?null:t[0].slice(1);for(let e=1;e<t.length;++e){const r=null==t[e]?null:t[e].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}const r=t.map((t=>t.length));-1===t.indexOf(null)&&1===VI(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return uw((()=>{if(this.reshapeRequired){const e=[],n=t.map((t=>t.rank));if(-1===n.indexOf(null)){const r=xC(n);for(let n of t){const t=n.rank;for(let e=0;e<r-t;++e)n=SC(n,1);e.push(n)}return this.mergeFunction(e)}{let n=!1;for(const r of t){const t=r.rank;if(null==t){const t=r.shape,s=t[0],i=t.slice(1).concat([s]);let a=Pw(r,[s].concat(mC(t.slice(1))));a=M_(a,[1,0]),a=Pw(a,i),e.push(a),n=!0}else if(t>1){const s=yC(1,t).concat([0]);e.push(M_(r,s)),n=!0}else e.push(r)}let r=this.mergeFunction(e);const s=r.rank;if(n)if(null==s){const t=r.shape,e=t[t.length-1],n=[e].concat(t.slice(0,t.length-1));r=Pw(M_(Pw(r,[-1,e]),[1,0]),n)}else if(s>1){const t=[s-1].concat(yC(0,s-1));r=M_(r,t)}return r}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let n=1;n<t.length;++n){const r=null==t[n]?null:t[n].slice(1);e=this.computeElementwiseOpOutputShape(e,r)}let n=[];for(const e of t)null!=e&&null!==e[0]&&n.push(e[0]);return n=VI(n),e=1===n.length?n.concat(e):[null].concat(e),e}computeMask(t,e){return uw((()=>{if(null==e)return null;if(!Array.isArray(e))throw new kI("`mask` should be an Array");if(!Array.isArray(t))throw new kI("`inputs` should be an Array");if(e.length!==t.length)throw new kI(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every((t=>null==t)))return null;let n=(e=e.map((t=>null==t?t:lS(t,0))))[0];for(let t=1;t<e.length-1;++t)n=TS(n,e[t]);return n}))}}class hD extends cD{constructor(t){super(t)}mergeFunction(t){return uw((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=yw(e,t[n]);return e}))}}hD.className="Add",aw(hD);class dD extends cD{constructor(t){super(t)}mergeFunction(t){return uw((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=bS(e,t[n]);return e}))}}dD.className="Multiply",aw(dD);class pD extends cD{constructor(t){super(t)}mergeFunction(t){return uw((()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=yw(e,t[n]);return bS(1/t.length,e)}))}}pD.className="Average",aw(pD);class fD extends cD{constructor(t){super(t)}mergeFunction(t){return uw((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=IS(e,t[n]);return e}))}}fD.className="Maximum",aw(fD);class mD extends cD{constructor(t){super(t)}mergeFunction(t){return uw((()=>{let e=t[0];for(let n=1;n<t.length;++n)e=AS(e,t[n]);return e}))}}mD.className="Minimum",aw(mD);class gD extends cD{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new kI("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const n of t)if(null!=n){e=!1;break}if(e)return;const n=[];for(let e=0;e<t.length;++e){const r=t[e].slice();r.splice(this.axis,1);let s=!1;for(const t of n)if(jf(t,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new kI("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return uw((()=>EC(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new kI("A `Concatenate` layer should be called on a list of inputs.");const e=t,n=e[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const t of e.slice(1)){if(null==n[r]||null==t[r]){n[r]=null;break}n[r]+=t[r]}return n}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new kI("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new kI("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new kI(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return uw((()=>{let n=!0;if(e.forEach((t=>{null==t||(n=!1)})),n)return null;const r=[];for(let n=0;n<t.length;++n)null==e[n]?r.push(Cb(jS(t[n]),"bool")):e[n].rank<t[n].rank?r.push(lS(e[n],-1)):r.push(e[n]);const s=Gw(r,this.axis);return vw(s,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function xD(t,e){for(;t<0;)t+=e;return t}gD.className="Concatenate",aw(gD);class yD extends cD{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){Uf(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],n=t[1];if(e.length>3||n.length>3)throw new II("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);if(e[r[0]]!==n[r[1]])throw new kI(`Dimension incompatibility: ${e[r[0]]} !== ${n[r[1]]}`)}mergeFunction(t){if(2!==t.length)throw new kI(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,n=t[0],r=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,n)=>xD(e,t[n].shape.length))):[xD(this.axes,n.shape.length),xD(this.axes,r.shape.length)],this.normalize&&(n=YA(n,e[0]),r=YA(r,e[1])),function(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new II("batchDot is not implemented for tensors of 4D or higher rank yet");if(Uf(t.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`)),Uf(t.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===t.dtype||"complex64"===e.dtype)throw new II("batchDot is not implemented for complex64-type Tensors yet.");const r=t.shape.length,s=e.shape.length;null==n&&(n=[r-1,s-2]);const i=n;return uw((()=>{let n,a;if(r>s){n=r-s;const t=[];for(let e=0;e<n;++e)t.push(1);e=Pw(e,e.shape.concat(t))}else if(s>r){n=s-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=Pw(t,t.shape.concat(e))}else n=0;if(2===t.shape.length&&2===e.shape.length)a=i[0]===i[1]?SS(bS(t,e),i[0]):SS(bS(M_(t,[1,0]),e),i[1]);else{const n=i[0]!==t.shape.length-1,r=i[1]===e.shape.length-1;a=MS(t,e,n,r)}if(n>0){let t;t=r>s?r+s-3:r-1;const e=[];for(let r=t;r<t+n;++r)e.push(r);a=f_(a,e)}return 1===a.shape.length&&(a=lS(a,1)),a}))}(n,r,e)}interpretAxes(t,e){let n;return n=Array.isArray(this.axes)?this.axes:[xD(this.axes,t.length),xD(this.axes,e.length)],n}computeOutputShape(t){Uf(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new II("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(e,n);e.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=e.concat(n);return 1===s.length&&s.push(1),s}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}yD.className="Dot",aw(yD);class vD extends yA{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return uw((()=>{this.invokeCallHook(t,e);const n=oA(t);return PC((()=>yw(CC(n.shape,0,this.stddev),n)),(()=>n),e.training||!1)}))}}vD.className="GaussianNoise",aw(vD);class bD extends yA{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return uw((()=>{this.invokeCallHook(t,e);const n=oA(t);return this.rate>0&&this.rate<1?PC((()=>{const t=Math.sqrt(this.rate/(1-this.rate));return bS(n,CC(n.shape,1,t))}),(()=>n),e.training||!1):n}))}}bD.className="GaussianDropout",aw(bD);class wD extends yA{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||oA(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return uw((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(t);return PC((()=>{const e=oA(t),r=-1.7580993408473766;let s=mS(QS(n),this.rate);s=wC(s,"float32");const i=((1-this.rate)*(1+this.rate*r**2))**-.5,a=-i*r*this.rate,o=yw(bS(e,s),bS(yw(s,-1),r));return yw(bS(o,i),a)}),(()=>oA(t)),e.training||!1)}return t}))}}function SD(t,e,n,r,s,i=.001){let a;if(2===t.rank)a=Bw(t,e,n,r,s,i);else if(3===t.rank)a=Uw(t,e,n,r,s,i);else{if(4!==t.rank)throw new II(`batchNormalization is not implemented for array of rank ${t.rank} yet`);a=Ww(t,e,n,r,s,i)}return a}wD.className="AlphaDropout",aw(wD);class _D extends yA{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=sA(t.betaInitializer||"zeros"),this.gammaInitializer=sA(t.gammaInitializer||"ones"),this.movingMeanInitializer=sA(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=sA(t.movingVarianceInitializer||"ones"),this.betaConstraint=$A(t.betaConstraint),this.gammaConstraint=$A(t.gammaConstraint),this.betaRegularizer=dN(t.betaRegularizer),this.gammaRegularizer=dN(t.gammaRegularizer)}build(t){t=lA(t);const e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(null==n)throw new kI(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new pA({ndim:t.length,axes:{[e]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return uw((()=>{const n=null!=e.training&&e.training,r=oA(t),s=r.shape,i=s.length,a=yC(0,i),o=this.axis>=0?this.axis:this.axis+i;a.splice(o,1);const l=RI(1,i);l[o]=s[o];const u=a.slice();u.sort();const c=!jf(u,yC(0,i).slice(0,i-1));if(!n)return(()=>{if(c){const t=Pw(this.movingMean.read(),l),e=Pw(this.movingVariance.read(),l),n=this.center?Pw(this.beta.read(),l):null,s=this.scale?Pw(this.gamma.read(),l):null;return SD(r,t,e,n,s,this.epsilon)}return SD(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=function(t,e,n,r,s=.001){return jf(r.slice().sort(),yC(0,t.rank-1))?function(t,e,n,r,s=.001){return uw((()=>{const i=BS(t,r),a=i.mean,o=i.variance;return[SD(t,a,o,n,e,s),a,o]}))}(t,e,n,r,s):function(t,e,n,r,s=.001){return uw((()=>{const i=BS(t,r),a=i.mean,o=i.variance,l=[];for(const e of yC(0,t.rank))-1!==r.indexOf(e)?l.push(1):l.push(t.shape[e]);const u=Pw(a,l),c=Pw(o,l),h=null==e?null:Pw(e,l),d=null==n?null:Pw(n,l);return[SD(t,u,c,d,h,s),a,o]}))}(t,e,n,r,s)}(r,this.gamma.read(),this.beta.read(),a,this.epsilon),f=(t,e,n)=>{uw((()=>{const r=1-n,s=t.read(),i=bS(wS(s,e),r);t.write(wS(s,i))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:rA(this.betaInitializer),gammaInitializer:rA(this.gammaInitializer),movingMeanInitializer:rA(this.movingMeanInitializer),movingVarianceInitializer:rA(this.movingVarianceInitializer),betaRegularizer:cN(this.betaRegularizer),gammaRegularizer:cN(this.gammaRegularizer),betaConstraint:FA(this.betaConstraint),gammaConstraint:FA(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}_D.className="BatchNormalization",aw(_D);class TD extends yA{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=sA(t.betaInitializer||"zeros"),this.gammaInitializer=sA(t.gammaInitializer||"ones"),this.betaRegularizer=dN(t.betaRegularizer),this.gammaRegularizer=dN(t.gammaRegularizer),this.supportsMasking=!0}build(t){const e=(t=lA(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let t=0;t<this.axis.length;++t)this.axis[t]<0&&(this.axis[t]+=e);for(const t of this.axis)if(t<0||t>=e)throw new Error(`Invalid axis: ${t}`);if(this.axis.length!==VI(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((e=>t[e]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(t,e){const n=oA(t),r=n.shape,s=r.length;return uw((()=>{let{mean:t,variance:e}=BS(n,this.axis,!0);const i=RI(1,s);for(const t of this.axis)i[t]=r[t];const a=t=>null!=t&&t.shape.length!==s?Pw(t,i):t;let o=this.scale?a(this.gamma.read()):null,l=this.center?a(this.beta.read()):null;const u=[],c=[];for(let t=0;t<s;++t)-1!==this.axis.indexOf(t)?(u.push(r[t]),c.push(1)):(u.push(1),c.push(r[t]));return t=uS(t,u),e=uS(e,u),null!=o&&(o=uS(o,c)),null!=l&&(l=uS(l,c)),SD(n,t,e,l,o,this.epsilon)}))}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:rA(this.betaInitializer),gammaInitializer:rA(this.gammaInitializer),betaRegularizer:cN(this.betaRegularizer),gammaRegularizer:cN(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}TD.className="LayerNormalization",aw(TD);class MD extends yA{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new kI(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if("number"==typeof t.padding[0])e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new kI(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],2!==t.padding[1].length)throw new kI(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new pA({ndim:4})]}computeOutputShape(t){let e,n;return t=lA(t),"channelsFirst"===this.dataFormat?(e=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],e,n]):(e=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],e,n,t[3]])}call(t,e){return uw((()=>{return e=oA(t),n=this.padding,r=this.dataFormat,uw((()=>{if(4!==e.rank)throw new kI(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new kI("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new kI(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let t;return t="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],qS(e,t)}));var e,n,r}))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}function ED(t,e,n,r,s,i){return uw((()=>{let a;aC(s),lC(i),oC(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),t=SN(t,s);const o="same"===r?"same":"valid";return a="max"===i?ES(t,e,n,o):$w(t,e,n,o),"channelsFirst"===s&&(a=M_(a,[0,3,1,2])),a}))}function kD(t,e,n,r,s,i){return uw((()=>{let a;aC(s),lC(i),oC(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),t=_N(t,s);const o="same"===r?"same":"valid";return a="max"===i?kS(t,e,n,o):Ow(t,e,n,o),"channelsFirst"===s&&(a=M_(a,[0,4,1,2,3])),a}))}MD.className="ZeroPadding2D",aw(MD);class ID extends yA{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new kI(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(qI(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new kI(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}qI(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,oC(this.padding),this.inputSpec=[new pA({ndim:3})]}computeOutputShape(t){const e=bN((t=lA(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return uw((()=>{this.invokeCallHook(t,e),t=SC(oA(t),2);const n=this.poolingFunction(oA(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return f_(n,[2])}))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class CD extends ID{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return aC(s),oC(r),ED(t,e,n,r,s,"max")}}CD.className="MaxPooling1D",aw(CD);class AD extends ID{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return aC(s),oC(r),ED(t,e,n,r,s,"avg")}}AD.className="AveragePooling1D",aw(AD);class RD extends yA{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new kI(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];qI(this.poolSize,"poolSize"),qI(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,aC(this.dataFormat),oC(this.padding),this.inputSpec=[new pA({ndim:4})]}computeOutputShape(t){t=lA(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2];return e=bN(e,this.poolSize[0],this.padding,this.strides[0]),n=bN(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return uw((()=>(this.invokeCallHook(t,e),this.poolingFunction(oA(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class ND extends RD{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return aC(s),oC(r),ED(t,e,n,r,s,"max")}}ND.className="MaxPooling2D",aw(ND);class DD extends RD{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return aC(s),oC(r),ED(t,e,n,r,s,"avg")}}DD.className="AveragePooling2D",aw(DD);class LD extends yA{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new kI(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];qI(this.poolSize,"poolSize"),qI(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,aC(this.dataFormat),oC(this.padding),this.inputSpec=[new pA({ndim:5})]}computeOutputShape(t){t=lA(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],n="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=bN(e,this.poolSize[0],this.padding,this.strides[0]),n=bN(n,this.poolSize[1],this.padding,this.strides[1]),r=bN(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,n,r]:[t[0],e,n,r,t[4]]}call(t,e){return uw((()=>(this.invokeCallHook(t,e),this.poolingFunction(oA(t),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class FD extends LD{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return aC(s),oC(r),kD(t,e,n,r,s,"max")}}FD.className="MaxPooling3D",aw(FD);class PD extends LD{constructor(t){super(t)}poolingFunction(t,e,n,r,s){return aC(s),oC(r),kD(t,e,n,r,s,"avg")}}PD.className="AveragePooling3D",aw(PD);class $D extends yA{constructor(t){super(t),this.inputSpec=[new pA({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new II}}class OD extends $D{constructor(t){super(t||{})}call(t,e){return uw((()=>{const e=oA(t);return CS(e,1)}))}}OD.className="GlobalAveragePooling1D",aw(OD);class zD extends $D{constructor(t){super(t||{})}call(t,e){return uw((()=>{const e=oA(t);return vS(e,1)}))}}zD.className="GlobalMaxPooling1D",aw(zD);class BD extends yA{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,aC(this.dataFormat),this.inputSpec=[new pA({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new II}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class UD extends BD{call(t,e){return uw((()=>{const e=oA(t);return"channelsLast"===this.dataFormat?CS(e,[1,2]):CS(e,[2,3])}))}}UD.className="GlobalAveragePooling2D",aw(UD);class WD extends BD{call(t,e){return uw((()=>{const e=oA(t);return"channelsLast"===this.dataFormat?vS(e,[1,2]):vS(e,[2,3])}))}}WD.className="GlobalMaxPooling2D",aw(WD);class VD extends yA{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){const r=KA(e.layer,n);delete e.layer;const s={layer:r};return Object.assign(s,e),new t(s)}}class GD extends VD{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=lA(t)).length<3)throw new kI(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=lA(t))[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),r=t[1];return[n[0],r].concat(n.slice(1))}call(t,e){return uw((()=>ON(((t,n)=>[oA(this.layer.call(t,e)),[]]),t=oA(t),[],!1,null,null,!1,!0)[1]))}}GD.className="TimeDistributed",aw(GD);class HD extends VD{constructor(t){super(t);const e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=KA(n),e.goBackwards=!0!==e.goBackwards;const r={};var s;if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=KA(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,s=this.mergeMode,HI(sC,"BidirectionalMergeMode",s),t.weights)throw new II("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e,n,r,s=this.forwardLayer.computeOutputShape(t);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),e=s[0]):e=s[0],"concat"===this.mergeMode?(e[e.length-1]*=2,n=[e]):n=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):LI(n)}apply(t,e){let n=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const s=$N(t,n,r,this.numConstants);if(t=s.inputs,n=s.initialState,r=s.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(null==n||0===n.length)&&null==r)return super.apply(t,e);const i=[],a=[];if(null!=n){const t=n.length;if(t%2>0)throw new kI("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);const r=n.map((t=>new pA({shape:t.shape})));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),a.push(...r)}if(null!=r)throw new II("Support for constants in Bidirectional layers is not implemented yet.");const o=i[0]instanceof fA;for(const t of i)if(t instanceof fA!==o)throw new kI("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[t].concat(i),r=this.inputSpec.concat(a),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,e);return this.inputSpec=s,o}return super.apply(t,e)}call(t,e){return uw((()=>{const n=e.initialState;let r,s,i,a;if(null==n)r=this.forwardLayer.call(t,e),s=this.backwardLayer.call(t,e);else{const i=n.slice(0,n.length/2),a=n.slice(n.length/2);r=this.forwardLayer.call(t,Object.assign(e,{initialState:i})),s=this.backwardLayer.call(t,Object.assign(e,{initialState:a}))}return this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=e_(s,1)),"concat"===this.mergeMode?a=EC([r,s]):"sum"===this.mergeMode?a=yw(r,s):"ave"===this.mergeMode?a=bS(.5,yw(r,s)):"mul"===this.mergeMode?a=bS(r,s):null==this.mergeMode&&(a=[r,s]),this.returnState?null==this.mergeMode?a.concat(i):[a].concat(i):a}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){cC(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),cC(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let n;if(Array.isArray(e)&&(e=e[0]),n=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(n)?n.concat(t).concat(t):[n].concat(t).concat(t)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const n=KA(e.layer);if(delete e.layer,null!=e.numConstants)throw new II("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=n,new t(r)}}HD.className="Bidirectional",aw(HD),Sm().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"}(KN||(KN={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(YN||(YN={}));var jD,qD,XD=n(6377);function KD(t,e,n=new Map,r=new Set){if(null==t)return null;if("function"==typeof Blob&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(n.has(t))return n.get(t);const s=e(t);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(QD(t)){const s=Array.isArray(t)?[]:{};r.add(t);for(const i in t){const a=KD(t[i],e,n,r);s[i]=a}return r.delete(t),t.__proto__&&(s.__proto__=t.__proto__),s}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return n.set(t,s.value),s.value}function YD(t,e=ZD){return JD(t,e)}function JD(t,e,n=new Set){const r=t[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=e(t);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(QD(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const i in r){const r=JD(t.map((t=>t[i])),e,n);s[i]=r}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function ZD(t){return null===t?null:QD(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function QD(t){let e=!1;if(Sm().get("IS_BROWSER"))e=t instanceof TextDecoder;else{const{StringDecoder:r}=n(4977);e=t instanceof r}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"==typeof t&&!(t instanceof xv)&&!(t instanceof Promise)&&!e)}function tL(t){return KD(t,eL)}function eL(t){return t instanceof xv?{value:t.clone(),recurse:!1}:QD(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class nL{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}}class rL extends nL{constructor(){super(rL.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,e=new Array(t),n=this.length();for(let t=0;t<n;t++)e[t]=this.get(this.wrap(this.begin+t));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}rL.INITIAL_CAPACITY=32;class sL{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new pL(this,t)}filter(t){return new hL(this,t)}map(t){return new dL(this,t)}mapAsync(t){return new fL(this,t)}serialMapAsync(t){return new fL(this,t).serial()}flatmap(t){return new gL(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t,e=!0){return new cL(this,t,e)}columnMajorBatch(t,e=!0,n=ZD){return this.rowMajorBatch(t,e).map((t=>YD(t,n)))}concatenate(t,e){return new xL(new iL([this,t]),e)}take(t){return t<0||null==t?this:new uL(this,t)}skip(t){return t<0||null==t?this:new lL(this,t)}prefetch(t){return new yL(this,t)}shuffle(t,e){return new vL(this,t,e)}serial(){return new oL(this)}}class iL extends sL{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:tL(t),done:!1}}}class aL extends sL{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class oL extends sL{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class lL extends sL{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;cw(t.value)}return this.upstream.next()}}class uL extends sL{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class cL extends sL{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class hL extends sL{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;cw(t.value)}}}class dL extends sL{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Av(t.value),n=this.transform(t.value),r=Av(n);for(const t of e)Cv(t,r)||t.dispose();return{value:n,done:!1}}}class pL extends sL{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class fL extends sL{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const e=Av(t.value),n=await this.transform(t.value),r=Av(n);for(const t of e)Cv(t,r)||t.dispose();return{value:n,done:!1}}}class mL extends sL{constructor(){super(),this.outputQueue=new rL,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class gL extends mL{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const e=Av(t.value),n=this.transform(t.value),r=Av(n);this.outputQueue.pushAll(n);for(const t of e)Cv(t,r)||t.dispose();return!0}}class xL extends sL{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}(qD=jD||(jD={}))[qD.FAIL=0]="FAIL",qD[qD.SHORTEST=1]="SHORTEST",qD[qD.LONGEST=2]="LONGEST";class yL extends sL{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new nL(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class vL extends yL{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=XD.alea(n||nv().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}class bL{constructor(){this.size=null}batch(t,e=!0){const n=this;let r;return Uf(t>0,(()=>`batchSize needs to be positive, but it is\n      ${t}`)),r=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),wL((async()=>(await n.iterator()).columnMajorBatch(t,e,SL)),r)}concatenate(t){const e=this;let n;return n=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,wL((async()=>(await e.iterator()).concatenate(await t.iterator())),n)}filter(t){const e=this;let n;return n=this.size===1/0?1/0:null,wL((async()=>(await e.iterator()).filter((e=>uw((()=>t(e)))))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return wL((async()=>(await e.iterator()).map((e=>uw((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return wL((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return wL((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let n;return n=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,wL((async()=>{return n=(s=async()=>({value:await e.iterator(),done:!1}),new aL(s)).take(t),new xL(n,r);var n,r,s}),n)}skip(t){const e=this;let n;return n=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,wL((async()=>(await e.iterator()).skip(t)),n)}shuffle(t,e,n=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=XD.alea(e||nv().toString());return wL((async()=>{let e=s.int32();return n&&(e+=s.int32()),(await r.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let n;return n=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,wL((async()=>(await e.iterator()).take(t)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function wL(t,e=null){return new class extends bL{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function SL(t){if(null===t)return null;return null==(e=t[0])||null===(n=e)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(e)||"object"==typeof e&&e instanceof xv||rm(e)?{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof xv?m_(t):Kv(t)}(t),recurse:!1}:{value:null,recurse:!0};var e,n}function _L(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&Uf("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the CPU backend.`))}))}bL.MAX_BUFFER_SIZE=1e4,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const TL=VM;class ML extends Ff{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Lf(this,ow())}nextDataId(){return ML.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,Sm().get("IS_NODE")&&Ay("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:n,refCount:1}),r}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&im(n[0])){const s=n.map((t=>rv(t)));r=this.write(s,t,e)}else r=this.write(n,t,e);return{dataId:r,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){this.data.get(t).refCount++}decRef(t){this.data.has(t)&&this.data.get(t).refCount--}move(t,e,n,r,s){this.data.set(t,{values:e,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:n}=this.data.get(t);return"complex64"===e?cM(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):this.data.get(t).values}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>sv(t)));return Ib(t.shape,t.dtype,n)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ib(t.shape,t.dtype,e)}makeOutput(t,e,n){return ow().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(t);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=nv();return t(),{kernelMs:nv()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){_L([t],"where");const e=this.readSync(t.dataId);return TL(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function EL(t,e,n){return({inputs:r,attrs:s,backend:i})=>{const{x:a}=r;if(_L(a,t),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=i,l=o.data.get(a.dataId).values,u=Hf(a.shape),c=n||a.dtype,h=em(c,u);for(let t=0;t<u;++t)h[t]=e(l[t],s);return o.makeTensorInfo(a.shape,c,h)}}function kL(t,e,n){return({inputs:r,attrs:s,backend:i})=>{const{x:a}=r;if(_L(a,t),"string"===a.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const o=i,l=o.data.get(a.dataId).values,u=n||a.dtype,c=e(l,u,s);return o.makeTensorInfo(a.shape,u,c)}}ML.nextDataId=0,dw("cpu",(()=>new ML),1);const IL=EL(_g,(t=>t>=0?t:Math.exp(t)-1)),CL={kernelName:_g,backendName:"cpu",kernelFunc:IL};function AL(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const RL={kernelName:Bg,backendName:"cpu",kernelFunc:AL};function NL(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:i}=r;_L([s],"leakyRelu");const a=Hf(s.shape),o=n.data.get(s.dataId).values,l=tm("float32",a);for(let t=0;t<o.length;t++)l[t]=o[t]<0?i*o[t]:o[t];return n.makeTensorInfo(s.shape,"float32",l)}const DL={kernelName:jg,backendName:"cpu",kernelFunc:NL};function LL(t){return(e,n,r,s,i)=>{const a=Bb(e,n),o=a.length,l=cm(a),u=tm(i,Hf(a)),c=e.length,h=n.length,d=cm(e),p=cm(n),f=Ob(e,a),m=Ob(n,a);if(f.length+m.length===0)for(let e=0;e<u.length;++e)u[e]=t(r[e%r.length],s[e%s.length]);else for(let e=0;e<u.length;++e){const n=ym(e,o,l),i=n.slice(-c);f.forEach((t=>i[t]=0));const a=xm(i,c,d),g=n.slice(-h);m.forEach((t=>g[t]=0));const x=xm(g,h,p);u[e]=t(r[a],s[x])}return[u,a]}}const FL=LL(((t,e)=>t<0?e*t:t));function PL(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e;_L([r,s],"prelu");const i=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,[o,l]=FL(r.shape,s.shape,i,a,"float32");return n.makeTensorInfo(l,"float32",o)}const $L={kernelName:kx,backendName:"cpu",kernelFunc:PL},OL=EL(Nx,(t=>Math.max(0,t))),zL={kernelName:Nx,backendName:"cpu",kernelFunc:OL},BL=EL(Ox,(t=>Math.min(Math.max(0,t),6))),UL={kernelName:Ox,backendName:"cpu",kernelFunc:BL};function WL(t){return(e,n,r)=>{const s=tm(n,e.length);for(let n=0;n<e.length;++n)s[n]=t(e[n],r);return s}}const VL=WL((t=>1/(1+Math.exp(-t)))),GL=EL(Yx,(t=>1/(1+Math.exp(-t)))),HL={kernelName:Yx,backendName:"cpu",kernelFunc:GL};function jL(t,e,n,r,s){if("linear"===n)return AL({inputs:{x:e},backend:t});if("relu"===n)return OL({inputs:{x:e},backend:t});if("elu"===n)return IL({inputs:{x:e},backend:t});if("relu6"===n)return BL({inputs:{x:e},backend:t});if("prelu"===n)return PL({inputs:{x:e,alpha:r},backend:t});if("leakyrelu"===n)return NL({inputs:{x:e},backend:t,attrs:{alpha:s}});if("sigmoid"===n)return GL({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function qL(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,i=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",i),imag:n.makeTensorInfo(s.shape,"float32",a)},o}const XL={kernelName:Zm,backendName:"cpu",kernelFunc:qL};function KL(t,e,n="float32"){if("complex64"===n)return qL({inputs:{real:KL(t,e,"float32"),imag:KL(t,e,"float32")},backend:t});const r=fm(Hf(e),n);return t.makeTensorInfo(e,n,r)}function YL(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.data.get(r.dataId).complexTensorInfos.real,i=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,i)}const JL={kernelName:Ax,backendName:"cpu",kernelFunc:YL};function ZL(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return AL({inputs:{x:s},backend:n});const t=KL(n,s.shape,s.dtype),e=ZL({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=qL({inputs:{real:e,imag:t},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),r}if("complex64"===s.dtype){const t=YL({inputs:{input:s},backend:n}),e=ZL({inputs:{x:t},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(t),e}if(!nm(s.dtype,i)){const t=AL({inputs:{x:s},backend:n});return{dataId:t.dataId,shape:t.shape,dtype:i}}if("int32"===i){const t=n.data.get(s.dataId).values,e=Int32Array.from(t);return n.makeTensorInfo(s.shape,"int32",e)}if("bool"===i){const t=n.data.get(s.dataId).values,e=ev([0],s.dtype),[r,i]=LL(((t,e)=>t!==e?1:0))(s.shape,[],t,e,"bool");return n.makeTensorInfo(i,"bool",r)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const QL={kernelName:Km,backendName:"cpu",kernelFunc:ZL};function tF(t,e,n,r){return null==n?({inputs:n,backend:s})=>{const{a:i,b:a}=n,o=s;_L([i,a],t);const l=o.data.get(i.dataId).values,u=o.data.get(a.dataId).values,c="string"===i.dtype?UM(l):l,h="string"===i.dtype?UM(u):u,d=r||i.dtype,[p,f]=e(i.shape,a.shape,c,h,d);return o.makeTensorInfo(f,d,p)}:({inputs:t,backend:s})=>{const{a:i,b:a}=t,o=s;if("complex64"===i.dtype||"complex64"===a.dtype){const t=ZL({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),e=o.data.get(t.dataId),r=e.complexTensorInfos.real,s=e.complexTensorInfos.imag,l=o.data.get(r.dataId).values,u=o.data.get(s.dataId).values,c=ZL({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),h=o.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=o.data.get(d.dataId).values,m=o.data.get(p.dataId).values,[g,x,y]=n(i.shape,a.shape,l,u,f,m),v=o.makeTensorInfo(y,"float32",g),b=o.makeTensorInfo(y,"float32",x),w=qL({inputs:{real:v,imag:b},backend:o});return o.disposeIntermediateTensorInfo(t),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(b),w}{const t=o.data.get(i.dataId).values,n=o.data.get(a.dataId).values,s=r||i.dtype,[l,u]=e(i.shape,a.shape,t,n,s);return o.makeTensorInfo(u,s,l)}}}function eF(t){return(e,n,r,s,i,a)=>{const o=Bb(e,n),l=Hf(o),u=o.length,c=cm(o),h=tm("float32",l),d=tm("float32",l),p=Ob(e,o),f=Ob(n,o),m=cM(r,s),g=cM(i,a),x=e.length,y=cm(e),v=n.length,b=cm(n);if(p.length+f.length===0)for(let e=0;e<h.length;e++){const n=e%m.length,r=e%g.length,s=t(m[2*n],m[2*n+1],g[2*r],g[2*r+1]);h[e]=s.real,d[e]=s.imag}else for(let e=0;e<h.length;e++){const n=ym(e,u,c),r=n.slice(-x);p.forEach((t=>r[t]=0));const s=xm(r,x,y),i=n.slice(-v);f.forEach((t=>i[t]=0));const a=xm(i,v,b),o=t(m[2*s],m[2*s+1],g[2*a],g[2*a+1]);h[e]=o.real,d[e]=o.imag}return[h,d,o]}}const nF=LL(((t,e)=>t+e)),rF=eF(((t,e,n,r)=>({real:t+n,imag:e+r}))),sF=tF(Am,nF,rF),iF={kernelName:Am,backendName:"cpu",kernelFunc:sF};function aF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:i}=r,a=Hf(s.shape),o=Jf(i,a),l=Hf(o);Uf(a===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(null!=u.complexTensorInfos){const t=u.complexTensorInfos.real,e=u.complexTensorInfos.imag;t.shape=o,e.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const oF={kernelName:Dx,backendName:"cpu",kernelFunc:aF};function lF(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:i}=e,{transposeA:a,transposeB:o}=r;_L([s,i],"matMul");const l=s.shape.length,u=i.shape.length,c=a?s.shape[l-2]:s.shape[l-1],h=o?i.shape[u-1]:i.shape[u-2],d=a?s.shape[l-1]:s.shape[l-2],p=o?i.shape[u-2]:i.shape[u-1],f=s.shape.slice(0,-2),m=i.shape.slice(0,-2),g=Hf(f),x=Hf(m),y=Bb(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([d,p]);Uf(c===h,(()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${a} and transposeB=${o} must match.`));const v=o?[x,p,h]:[x,h,p],b=aF({inputs:{x:s},backend:n,attrs:{shape:a?[g,c,d]:[g,d,c]}}),w=aF({inputs:{x:i},backend:n,attrs:{shape:v}}),S=a?b.shape[1]:b.shape[2],_=a?b.shape[2]:b.shape[1],T=o?w.shape[1]:w.shape[2],M=Math.max(g,x),E=n.data.get(b.dataId).values,k=n.data.get(w.dataId).values,I=cm(b.shape),C=cm(w.shape),[A,R,N]=a?[I[0],1,I[1]]:[I[0],I[1],1],[D,L,F]=o?[1,C[1],C[0]]:[C[1],1,C[0]],P=_*T,$=Ib([M,_,T],b.dtype),O=$.values,z=n.blockSize;for(let t=0;t<M;t++)for(let e=0;e<_;e+=z)for(let n=0;n<T;n+=z)for(let r=0;r<S;r+=z){const s=Math.min(e+z,_),i=Math.min(n+z,T),a=Math.min(r+z,S);for(let o=e;o<s;o++)for(let e=n;e<i;e++){let n=0;for(let s=r;s<a;s++){const r=Math.min(t,g-1)*A,i=Math.min(t,x-1)*F;n+=E[r+o*R+s*N]*k[s*D+e*L+i]}O[t*P+(o*T+e)]+=n}}return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,$.dtype,$.values)}const uF={kernelName:Hm,backendName:"cpu",kernelFunc:lF},cF={kernelName:ky,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;let d,p,f;const m=[];d=lF({inputs:{a:s,b:i},attrs:{transposeA:l,transposeB:u},backend:n}),a&&(p=sF({inputs:{a:d,b:a},backend:n}),m.push(d),d=p),c&&(f=jL(n,d,c,o,h),m.push(d),d=f);for(const t of m)n.disposeIntermediateTensorInfo(t);return d}};function hF(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const dF={kernelName:km,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend;_L(e,"abs");let r=new Float32Array(Hf(e.shape));return r=hF(n.data.get(e.dataId).values),n.makeOutput(r,e.shape,e.dtype)}},pF=EL(Im,(t=>Math.acos(t))),fF={kernelName:Im,backendName:"cpu",kernelFunc:pF},mF=EL(Cm,(t=>Math.acosh(t))),gF={kernelName:Cm,backendName:"cpu",kernelFunc:mF},xF={kernelName:Rm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,r=e;_L(e,"addN");const s=r.map((t=>n.data.get(t.dataId).values)),i=Ib(r[0].shape,r[0].dtype),a=i.values;for(let t=0;t<r.length;t++){const e=s[t];for(let t=0;t<a.length;t++)a[t]+=e[t]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}};function yF(t,e,n,r,s){const i=e.length,a=Hf(e),o=cm(e),l=cm(s),u=tm(n,Hf(s));for(let e=0;e<a;++e){const n=ym(e,i,o),s=new Array(n.length);for(let t=0;t<s.length;t++)s[t]=n[r[t]];u[xm(s,i,l)]=t[e]}return u}function vF(t){const{inputs:e,attrs:n,backend:r}=t,{x:s}=e,{perm:i}=n;_L(s,"transpose");const a=s.shape.length,o=new Array(a);for(let t=0;t<o.length;t++)o[t]=s.shape[i[t]];const l=yF(r.data.get(s.dataId).values,s.shape,s.dtype,i,o);return{dataId:r.write(l,o,s.dtype),shape:o,dtype:s.dtype}}const bF={kernelName:by,backendName:"cpu",kernelFunc:vF},wF={kernelName:Nm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r;_L(s,"all");const o=Zf(i,s.shape);let l=o;const u=PS(l,s.shape.length);let c=s;null!=u&&(c=vF({inputs:{x:s},backend:n,attrs:{perm:u}}),l=OS(l.length,s.shape.length)),FS("all",l,c.shape.length);const[h,d]=DS(c.shape,l),p=Hf(d),f=fm(Hf(h),c.dtype),m=n.data.get(c.dataId).values;for(let t=0;t<f.length;++t){const e=t*p;let n=m[e];for(let t=0;t<p;++t){const r=m[e+t];n=n&&r}f[t]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const t=aF({inputs:{x:g},backend:n,attrs:{shape:LS(h,o)}});return n.disposeIntermediateTensorInfo(g),t}return g}},SF={kernelName:Dm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r;_L(s,"any");const o=Zf(i,s.shape);let l=o;const u=PS(l,s.shape.length);let c=s;null!=u&&(c=vF({inputs:{x:s},backend:n,attrs:{perm:u}}),l=OS(l.length,s.shape.length)),FS("any",l,c.shape.length);const[h,d]=DS(c.shape,l),p=Hf(d),f=fm(Hf(h),c.dtype),m=n.data.get(c.dataId).values;for(let t=0;t<f.length;++t){const e=t*p;let n=m[e];for(let t=0;t<p;++t){const r=m[e+t];n=n||r}f[t]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const t=aF({inputs:{x:g},backend:n,attrs:{shape:LS(h,o)}});return n.disposeIntermediateTensorInfo(g),t}return g}},_F={kernelName:Lm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i}=r;_L(s,"argMax");let a=Zf(i,s.shape);const o=PS(a,s.shape.length);let l=s;const u=[];null!=o&&(l=vF({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),a=OS(a.length,l.shape.length)),a=[a[0]],FS("argMax",a,l.shape.length);const[c,h]=DS(l.shape,a),d=fm(Hf(c),"int32"),p=Hf(h),f=n.data.get(l.dataId).values;for(let t=0;t<d.length;++t){const e=t*p;let n=f[e],r=0;for(let t=0;t<p;++t){const s=f[e+t];s>n&&(n=s,r=t)}d[t]=r}return u.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(c,"int32",d)}},TF={kernelName:Fm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i}=r;_L(s,"argMin");let a=Zf(i,s.shape);const o=PS(a,s.shape.length);let l=s;const u=[];null!=o&&(l=vF({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),a=OS(a.length,l.shape.length)),a=[a[0]],FS("argMin",a,l.shape.length);const[c,h]=DS(l.shape,a),d=fm(Hf(c),"int32"),p=Hf(h),f=n.data.get(l.dataId).values;for(let t=0;t<d.length;++t){const e=t*p;let n=f[e],r=0;for(let t=0;t<p;++t){const s=f[e+t];s<n&&(n=s,r=t)}d[t]=r}return u.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(c,"int32",d)}},MF=EL(Pm,(t=>Math.asin(t))),EF={kernelName:Pm,backendName:"cpu",kernelFunc:MF},kF=EL($m,(t=>Math.asinh(t))),IF={kernelName:$m,backendName:"cpu",kernelFunc:kF},CF=EL(Om,(t=>Math.atan(t))),AF={kernelName:Om,backendName:"cpu",kernelFunc:CF},RF=LL(((t,e)=>Math.atan2(t,e))),NF=tF(Bm,RF),DF={kernelName:Bm,backendName:"cpu",kernelFunc:NF},LF=EL(zm,(t=>Math.atanh(t))),FF={kernelName:zm,backendName:"cpu",kernelFunc:LF};function PF(t,e,n,r,s,i){const a=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Ib(s.outShape,n),g=m.values,x=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let e=0;e<s.batchSize;++e){const n=e*x,m=e*r[0];for(let e=0;e<s.inChannels;++e)for(let x=0;x<s.outHeight;++x){const b=x*a-d,w=Math.max(0,b),S=Math.min(s.inHeight,c+b),_=n+x*y;for(let n=0;n<s.outWidth;++n){const a=n*o-p,c=Math.max(0,a),d=Math.min(s.inWidth,h+a);let x=f,y=0,b=0;for(let n=w;n<S;n+=l){const s=m+n*r[1];for(let n=c;n<d;n+=u){const a=t[s+n*r[2]+e];"max"===i&&a>x?x=a:"avg"===i&&(y+=a,b++)}if(isNaN(x))break}g[_+n*v+e]="avg"===i?y/b:x}}}return m}function $F(t,e,n,r,s=!1,i=!1){const a=Ib(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Ib(e,n,t);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let n=0;n<r.outHeight;++n){const g=n*o-p;let x=g;for(;x<0;)x+=u;const y=Math.min(r.inHeight,h+g);for(let o=0;o<r.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=c;const v=Math.min(r.inWidth,d+h);let b=Number.NEGATIVE_INFINITY,w=-1;for(let n=x;n<y;n+=u){const a=n-g;for(let o=p;o<v;o+=c){const l=o-h,u=m.get(t,n,o,e);u>b&&(b=u,w=s?i?((t*r.inHeight+n)*r.inWidth+o)*r.inChannels+e:(n*r.inWidth+o)*r.inChannels+e:a*d+l)}}a.set(w,t,n,o,e)}}return a}function OF(t,e,n,r,s,i){const a=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,x=s.padInfo.left,y="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Ib(s.outShape,n),b=v.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[2]*s.outShape[3]*s.outShape[4],_=s.outShape[3]*s.outShape[4],T=s.outShape[4];for(let e=0;e<s.batchSize;++e){const n=e*w,v=e*r[0];for(let e=0;e<s.inChannels;++e)for(let w=0;w<s.outDepth;++w){const M=w*a-m;let E=M;for(;E<0;)E+=u;const k=Math.min(s.inDepth,d+M),I=n+w*S;for(let n=0;n<s.outHeight;++n){const a=n*o-g;let d=a;for(;d<0;)d+=c;const m=Math.min(s.inHeight,p+a),w=I+n*_;for(let n=0;n<s.outWidth;++n){const a=n*l-x;let o=a;for(;o<0;)o+=h;const p=Math.min(s.inWidth,f+a),g=w+n*T;let S=y,_=0,M=0;for(let n=E;n<k;n+=u){const s=v+n*r[1];for(let n=d;n<m;n+=c){const a=s+n*r[2];for(let n=o;n<p;n+=h){const s=t[a+n*r[3]+e];if("max"===i&&s>S?S=s:"avg"===i&&(_+=s,M++),isNaN(S))break}if(isNaN(S))break}if(isNaN(S))break}b[g+e]="avg"===i?_/M:S}}}}return v}const zF={kernelName:Um,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;_L(s,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=r;Uf(Dw(a,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=_w(s.shape,i,a,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&jf(u.inShape,u.outShape))c=AL({inputs:{x:s},backend:n});else{const t=n.data.get(s.dataId).values,e=cm(s.shape),r=PF(t,s.shape,s.dtype,e,u,"avg");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}},BF={kernelName:Vm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r;_L(s,"avgPool3d");const c=Tw(s.shape,i,a,1,o,l,u),h=OF(n.data.get(s.dataId).values,s.shape,s.dtype,cm(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},UF={kernelName:Gm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;_L([s,i],"avgPool3DGrad");const c=Tw(i.shape,a,o,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,x=c.dilationDepth,y=c.dilationHeight,v=c.dilationWidth,b=c.effectiveFilterDepth,w=c.effectiveFilterHeight,S=c.effectiveFilterWidth,_=b-1-c.padInfo.front,T=S-1-c.padInfo.left,M=w-1-c.padInfo.top,E=Ib(i.shape,"float32"),k=1/(f*m*g),I=n.bufferSync(s);for(let t=0;t<c.batchSize;++t)for(let e=0;e<c.inChannels;++e)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let s=0;s<c.inWidth;++s){const i=n-_,a=r-M,o=s-T;let l=0;for(let n=0;n<b;n+=x){const r=(i+n)/h;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let n=0;n<w;n+=y){const s=(a+n)/d;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let n=0;n<S;n+=v){const i=(o+n)/p;i<0||i>=c.outWidth||Math.floor(i)!==i||(l+=I.get(t,r,s,i,e))}}}E.set(l*k,t,n,r,s,e)}return n.makeTensorInfo(E.shape,E.dtype,E.values)}},WF={kernelName:Wm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,a=i;_L([s,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=_w(a.shape,o,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,x=c.effectiveFilterHeight,y=c.effectiveFilterWidth,v=y-1-c.padInfo.left,b=x-1-c.padInfo.top,w=Ib(a.shape,"float32"),S=1/(p*f),_=n.data.get(s.dataId).values,T=Ib(s.shape,"float32",_);for(let t=0;t<c.batchSize;++t)for(let e=0;e<c.inChannels;++e)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=n-b,i=r-v;let a=0;for(let n=0;n<x;n+=m){const r=(s+n)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let n=0;n<y;n+=g){const s=(i+n)/d;s<0||s>=c.outWidth||Math.floor(s)!==s||(a+=T.get(t,r,s,e))}}w.set(a*S,t,n,r,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},VF={kernelName:Fg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,scale:i,offset:a,mean:o,variance:l}=e;Uf(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Uf(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Uf(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),_L([s,o,l,i,a],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=i?n.data.get(i.dataId).values:new Float32Array([1]),f=a?n.data.get(a.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,x=p.length,y=d.length,v=h.length;let b=0,w=0,S=0,_=0;for(let t=0;t<c.length;++t)m[t]=f[b++]+(c[t]-h[w++])*p[S++]/Math.sqrt(d[_++]+u),b>=g&&(b=0),w>=v&&(w=0),S>=x&&(S=0),_>=y&&(_=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function GF(t,e,n,r,s){const i=Qb(r,e,n),a=Hf(n),o=cm(r);if(i){const n=tw(e,o);return"string"===s?t.slice(n,n+a):t.subarray(n,n+a)}const l=Ib(r,s,"string"===s?UM(t):t),u=Ib(n,s);for(let t=0;t<u.size;++t){const n=u.indexToLoc(t),r=n.map(((t,n)=>t+e[n]));u.set(l.get(...r),...n)}return"string"===s?WM(u.values):u.values}function HF(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:i,size:a}=r;_L(s,"slice");const[o,l]=ew(s,i,a);Ub(s,o,l);const u=GF(n.data.get(s.dataId).values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,u)}const jF={kernelName:jx,backendName:"cpu",kernelFunc:HF},qF={kernelName:jm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:i,crops:a}=r;_L([s],"batchToSpaceND");const o=i.reduce(((t,e)=>t*e)),l=qT(s.shape,i,o),u=XT(l.length,i.length),c=KT(s.shape,i,o),h=YT(a,i.length),d=JT(c,a,i.length),p=aF({inputs:{x:s},backend:n,attrs:{shape:l}}),f=vF({inputs:{x:p},backend:n,attrs:{perm:u}}),m=aF({inputs:{x:f},backend:n,attrs:{shape:c}}),g=HF({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function XF(t,e,n,r,s){const i=Hf(r),a=fm(s,n);for(let n=0;n<t.length;n++){const r=t[n];if(r<0)throw new Error("Input x must be non-negative!");r>=s||(a[r]+=i>0?e[n]:1)}return a}function KF(t,e,n,r=!1){const s=t.shape[0],i=t.shape[1],a=Ib([s,n],e.dtype);for(let o=0;o<s;o++)for(let s=0;s<i;s++){const i=t.get(o,s);if(i<0)throw new Error("Input x must be non-negative!");i>=n||(r?a.set(1,o,i):e.size>0?a.set(a.get(o,i)+e.get(o,s),o,i):a.set(a.get(o,i)+1,o,i))}return a}const YF={kernelName:qm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:i}=e,{size:a}=r,o=XF(n.data.get(s.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,o)}},JF={kernelName:Xm,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,i=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values,o=Bb(Array.from(i),Array.from(a));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},ZF=WL((t=>Math.ceil(t))),QF=kL(Ym,ZF),tP={kernelName:Ym,backendName:"cpu",kernelFunc:QF},eP=EL(Jm,((t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t})),nP={kernelName:Jm,backendName:"cpu",kernelFunc:eP},rP={kernelName:Qm,backendName:"cpu",kernelFunc:t=>{const{x:e}=t.inputs,n=t.backend,r=new Float32Array(Hf(e.shape)),s=n.data.get(e.dataId),i=s.complexTensorInfos.real,a=s.complexTensorInfos.imag,o=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values;for(let t=0;t<o.length;t++){const e=o[t],n=l[t];r[t]=Math.hypot(e,n)}return n.makeOutput(r,e.shape,"float32")}};function sP(t,e,n,r){const s=em(n,Hf(e));if(r&&"string"!==n){let e=0;t.forEach((t=>{const n=Hf(t.shape);s.set(t.vals,e),e+=n}))}else{let r=0;t.forEach((t=>{const i="string"===n?UM(t.vals):t.vals;let a=0;for(let n=0;n<t.shape[0];++n){const o=n*e[1]+r;for(let e=0;e<t.shape[1];++e)s[o+e]=i[a++]}r+=t.shape[1]}))}return s}function iP(t){const{inputs:e,backend:n}=t,{input:r}=e,s=n.data.get(r.dataId).complexTensorInfos.imag,i=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,i)}const aP={kernelName:Wg,backendName:"cpu",kernelFunc:iP};function oP(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,i=Zf(s,e[0].shape)[0];let a=VT(e.map((t=>t.shape)),i);if(0===Hf(a))return n.makeTensorInfo(a,e[0].dtype,[]);const o=e.filter((t=>Hf(t.shape)>0));if(1===o.length)return AL({inputs:{x:o[0]},backend:n});if(WT(o.map((t=>t.shape)),i),"complex64"===o[0].dtype){const t=o.map((t=>YL({inputs:{input:t},backend:n}))),e=o.map((t=>iP({inputs:{input:t},backend:n}))),r=oP({inputs:t,backend:n,attrs:{axis:i}}),s=oP({inputs:e,backend:n,attrs:{axis:i}}),a=qL({inputs:{real:r,imag:s},backend:n});return t.forEach((t=>n.disposeIntermediateTensorInfo(t))),e.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),a}const l=o.map((t=>{const e=Hf(t.shape.slice(i));return aF({inputs:{x:t},backend:n,attrs:{shape:[-1,e]}})})),u=l.map((t=>({vals:n.data.get(t.dataId).values,shape:t.shape})));a=VT(l.map((t=>t.shape)),1);const c=1===l[0].shape[0],h=sP(u,a,e[0].dtype,c),d=VT(o.map((t=>t.shape)),i),p=n.makeTensorInfo(d,e[0].dtype,h);return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}const lP={kernelName:tg,backendName:"cpu",kernelFunc:oP};function uP(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;_L([s,i],"conv2d");const h=Lw(l),d=Mw(s.shape,i.shape,a,u,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,x=d.padInfo.left,y=d.padInfo.top,v="channelsLast"===d.dataFormat,b=new pv(d.outShape,s.dtype),w=cm(s.shape),S=cm(i.shape),_=w[0],T=v?w[1]:w[2],M=v?w[2]:1,E=v?1:w[1],k=b.strides[0],I=v?b.strides[1]:b.strides[2],C=v?b.strides[2]:1,A=v?1:b.strides[1],R=n.data.get(s.dataId).values,N=n.data.get(i.dataId).values,D=b.values;for(let t=0;t<d.batchSize;++t){const e=t*_,n=t*k;for(let t=0;t<d.outHeight;++t){const r=n+t*I,s=t*d.strideHeight-y;for(let t=0;t<p;++t){const n=s+t*m;if(n<0||n>=d.inHeight)continue;const i=t*S[0],a=e+n*T;for(let t=0;t<d.outWidth;++t){const e=r+t*C,n=t*d.strideWidth-x;for(let t=0;t<f;++t){const r=n+t*g;if(r<0||r>=d.inWidth)continue;const s=a+r*M;let o=i+t*S[1];for(let t=0;t<d.inChannels;++t){const n=R[s+t*E];for(let t=0;t<d.outChannels;++t)D[e+t*A]+=n*N[o+t];o+=d.outChannels}}}}}}return n.makeTensorInfo(b.shape,b.dtype,D)}const cP={kernelName:eg,backendName:"cpu",kernelFunc:uP},hP={kernelName:ng,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;_L([s,i],"conv2dBackpropFilter");const h=Lw(l),d=Mw(s.shape,c,a,1,o,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,x="channelsLast"===d.dataFormat,y=new pv(d.filterShape,"float32"),v=d.padInfo.left,b=d.padInfo.top,w=n.data.get(s.dataId).values,S=n.data.get(i.dataId).values,_=new pv(s.shape,s.dtype,w),T=new pv(i.shape,i.dtype,S);for(let t=0;t<m;++t){const e=Math.max(0,Math.ceil((b-t)/p)),n=Math.min(d.outHeight,(d.inHeight+b-t)/p);for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((v-r)/f)),i=Math.min(d.outWidth,(d.inWidth+v-r)/f);for(let a=0;a<d.inChannels;++a)for(let o=0;o<d.outChannels;++o){let l=0;for(let u=0;u<d.batchSize;++u)for(let c=e;c<n;++c){const e=t+c*p-b;for(let t=s;t<i;++t){const n=r+t*f-v;l+=x?_.get(u,e,n,a)*T.get(u,c,t,o):_.get(u,a,e,n)*T.get(u,o,c,t)}}y.set(l,t,r,a,o)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},dP={kernelName:rg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;_L([s,i],"conv2dBackpropInput");const h=cm(i.shape),d=cm(s.shape);let p=Lw(u);const f=Mw(a,i.shape,o,1,l,c,!1,p),m=new pv(f.inShape,"float32"),g=m.values,x=n.data.get(s.dataId).values,y=n.data.get(i.dataId).values,[v,b,w]=h,{batchSize:S,filterHeight:_,filterWidth:T,inChannels:M,inHeight:E,inWidth:k,outChannels:I,outHeight:C,outWidth:A,strideHeight:R,strideWidth:N}=f;p=f.dataFormat;const D=_-1-f.padInfo.top,L=T-1-f.padInfo.left,F="channelsLast"===p,P=m.strides[0],$=F?m.strides[1]:m.strides[2],O=F?m.strides[2]:1,z=F?1:m.strides[1],B=d[0],U=F?d[1]:d[2],W=F?d[2]:1,V=F?1:d[1];for(let t=0;t<S;++t)for(let e=0;e<M;++e)for(let n=0;n<E;++n){const r=n-D,s=Math.max(0,Math.ceil(r/R)),i=Math.min(C,(_+r)/R);for(let a=0;a<k;++a){const o=a-L,l=Math.max(0,Math.ceil(o/N)),u=Math.min(A,(T+o)/N);let c=0;for(let n=s;n<i;++n){const s=n*R-r;for(let r=l;r<u;++r){const i=B*t+U*n+W*r,a=v*(_-1-s)+b*(T-1-(r*N-o))+w*e;for(let t=0;t<I;++t)c+=x[i+V*t]*y[a+t]}}g[P*t+$*n+O*a+z*e]=c}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},pP={kernelName:sg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:a,pad:o,dilations:l}=r;_L([s,i],"conv3d");const u=Ew(s.shape,i.shape,a,l,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,x=g.front,y=g.left,v=g.top,b=new pv(u.outShape,s.dtype),w=n.data.get(s.dataId).values,S=n.data.get(i.dataId).values,_=b.values,T=cm(s.shape),M=cm(i.shape);for(let t=0;t<u.batchSize;++t){const e=t*T[0],n=t*b.strides[0];for(let t=0;t<u.outDepth;++t){const r=n+t*b.strides[1],s=t*u.strideDepth-x;for(let t=0;t<c;++t){const n=s+t*p;if(n<0||n>=u.inDepth)continue;const i=t*M[0],a=e+n*T[1];for(let t=0;t<u.outHeight;++t){const e=r+t*b.strides[2],n=t*u.strideHeight-v;for(let t=0;t<h;++t){const r=n+t*f;if(r<0||r>=u.inHeight)continue;const s=i+t*M[1],o=a+r*T[2];for(let t=0;t<u.outWidth;++t){const n=e+t*u.outChannels,r=t*u.strideWidth-y;for(let t=0;t<d;++t){const e=r+t*m;if(e<0||e>=u.inWidth)continue;const i=s+t*M[2],a=o+e*u.inChannels;let l=i;for(let t=0;t<u.inChannels;++t){const e=w[a+t];for(let t=0;t<u.outChannels;++t)_[n+t]+=e*S[l+t];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},fP={kernelName:ig,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:a,pad:o,filterShape:l}=r;_L([s,i],"conv3dBackpropFilterV2");const u=cm(s.shape),c=cm(i.shape),h=Ew(s.shape,l,a,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,x=h.filterWidth,y=new pv(h.filterShape,"float32"),v=y.values,[b,w,S,_]=y.strides,T=n.data.get(i.dataId).values,[M,E,k,I]=c,C=n.data.get(s.dataId).values,[A,R,N,D]=u,L=h.padInfo.front,F=h.padInfo.left,P=h.padInfo.top;for(let t=0;t<m;++t){const e=Math.max(0,Math.ceil((L-t)/d)),n=Math.min(h.outDepth,(h.inDepth+L-t)/d),r=t*b;for(let s=0;s<g;++s){const i=Math.max(0,Math.ceil((P-s)/p)),a=Math.min(h.outHeight,(h.inHeight+P-s)/p),o=s*w+r;for(let r=0;r<x;++r){const l=Math.max(0,Math.ceil((F-r)/f)),u=Math.min(h.outWidth,(h.inWidth+F-r)/f),c=r*S+o;for(let o=0;o<h.inChannels;++o){const m=o*_+c;for(let c=0;c<h.outChannels;++c){let g=0;for(let m=0;m<h.batchSize;++m){const h=m*A,x=m*M;for(let m=e;m<n;++m){const e=(t+m*d-L)*R+h,n=m*E+x;for(let t=i;t<a;++t){const i=(s+t*p-P)*N+e,a=t*k+n;for(let t=l;t<u;++t){const e=t*I+a;g+=C[(r+t*f-F)*D+i+o]*T[e+c]}}}}v[m+c]=g}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},mP={kernelName:ag,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{pad:a,strides:o,inputShape:l}=r;_L([s],"conv3dBackpropInputV2");const u=cm(s.shape),c=cm(i.shape),h=Ew(l,i.shape,o,1,a),d=new pv(h.inShape,"float32"),p=d.values,[f,m,g,x]=d.strides,y=n.data.get(s.dataId).values,[v,b,w,S]=u,_=n.data.get(i.dataId).values,[T,M,E,k]=c,{batchSize:I,filterDepth:C,filterHeight:A,filterWidth:R,inChannels:N,inDepth:D,inHeight:L,inWidth:F,outChannels:P,outDepth:$,outHeight:O,outWidth:z,strideDepth:B,strideHeight:U,strideWidth:W}=h,V=C-1-h.padInfo.front,G=A-1-h.padInfo.top,H=R-1-h.padInfo.left;for(let t=0;t<I;++t)for(let e=0;e<N;++e)for(let n=0;n<D;++n){const r=n-V,s=Math.max(0,Math.ceil(r/B)),i=Math.min($,(C+r)/B);for(let a=0;a<L;++a){const o=a-G,l=Math.max(0,Math.ceil(o/U)),u=Math.min(O,(A+o)/U);for(let c=0;c<F;++c){const h=c-H,d=Math.max(0,Math.ceil(h/W)),I=Math.min(z,(R+h)/W);let N=0;for(let n=s;n<i;++n){const s=n*B-r;for(let r=l;r<u;++r){const i=r*U-o;for(let a=d;a<I;++a){const o=v*t+b*n+w*r+S*a,l=T*(C-1-s)+M*(A-1-i)+E*(R-1-(a*W-h))+k*e;for(let t=0;t<P;++t)N+=y[o+t]*_[l+t]}}}p[f*t+m*n+g*a+x*c+e]=N}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},gP=EL(og,(t=>Math.cos(t))),xP={kernelName:og,backendName:"cpu",kernelFunc:gP},yP=EL(lg,(t=>Math.cosh(t))),vP={kernelName:lg,backendName:"cpu",kernelFunc:yP},bP={kernelName:hg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=r,[c,h,d,p]=s.shape,f=i.shape[0],[m,g]=o,x=Ib([f,m,g,p],"float32"),y=n.data.get(i.dataId).values,v=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,w=cm(s.shape),S=cm(x.shape);for(let t=0;t<f;t++){const e=4*t,n=y[e],r=y[e+1],s=y[e+2],i=y[e+3],a=v[t];if(a>=c)continue;const o=m>1?(s-n)*(h-1)/(m-1):0,f=g>1?(i-r)*(d-1)/(g-1):0;for(let e=0;e<m;e++){const c=m>1?n*(h-1)+e*o:.5*(n+s)*(h-1);if(c<0||c>h-1)for(let n=0;n<g;n++)for(let r=0;r<p;r++){const s=r+n*S[2]+e*S[1]+t*S[0];x.values[s]=u}else if("bilinear"===l){const n=Math.floor(c),s=Math.ceil(c),o=c-n;for(let l=0;l<g;l++){const c=g>1?r*(d-1)+l*f:.5*(r+i)*(d-1);if(c<0||c>d-1){for(let n=0;n<p;n++){const r=n+l*S[2]+e*S[1]+t*S[0];x.values[r]=u}continue}const h=Math.floor(c),m=Math.ceil(c),y=c-h;for(let r=0;r<p;r++){let i=r+h*w[2]+n*w[1]+a*w[0];const u=b[i];i=r+m*w[2]+n*w[1]+a*w[0];const c=b[i];i=r+h*w[2]+s*w[1]+a*w[0];const d=b[i];i=r+m*w[2]+s*w[1]+a*w[0];const p=u+(c-u)*y,f=d+(b[i]-d)*y;i=r+l*S[2]+e*S[1]+t*S[0],x.values[i]=p+(f-p)*o}}}else for(let n=0;n<g;++n){const s=g>1?r*(d-1)+n*f:.5*(r+i)*(d-1);if(s<0||s>d-1){for(let r=0;r<p;r++){const s=r+n*S[2]+e*S[1]+t*S[0];x.values[s]=u}continue}const o=Math.round(s),l=Math.round(c);for(let r=0;r<p;r++){const s=r+o*w[2]+l*w[1]+a*w[0],i=r+n*S[2]+e*S[1]+t*S[0];x.values[i]=b[s]}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},wP={kernelName:ug,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,exclusive:a,reverse:o}=r;_L(s,"cumprod");const l=PS([i],s.shape.length);let u=s;null!=l&&(u=vF({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=OS(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Ev(u.dtype,"int32"),d=pm(Hf(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let t=0;t<p.length;t+=f)for(let e=0;e<f;e++){const n=m(t,e);if(0===e)d[n]=a?1:p[n];else{const r=m(t,e-1);d[n]=a?p[r]*d[r]:p[n]*d[r]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const t=vF({inputs:{x:g},backend:n,attrs:{perm:$S(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}},SP={kernelName:cg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,exclusive:a,reverse:o}=r;_L(s,"cumsum");const l=PS([i],s.shape.length);let u=s;null!=l&&(u=vF({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=OS(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Ev(u.dtype,"int32"),d=fm(Hf(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(t,e)=>t+f-e-1:(t,e)=>t+e;for(let t=0;t<p.length;t+=f)for(let e=0;e<f;e++){const n=m(t,e);if(0===e)d[n]=a?0:p[n];else{const r=m(t,e-1);d[n]=a?p[r]+d[r]:p[n]+d[r]}}const g=n.makeTensorInfo(u.shape,h,d);if(null!=l){const t=vF({inputs:{x:g},backend:n,attrs:{perm:$S(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}},_P={kernelName:dg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:i}=e,{size:a,binaryOutput:o}=r;if(1===s.shape.length){const t=XF(n.data.get(s.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,t)}if(2===s.shape.length){const t=KF(n.bufferSync(s),n.bufferSync(i),a,o);return n.makeTensorInfo(t.shape,i.dtype,t.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},TP={kernelName:pg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:i,dataFormat:a}=r;Uf("NHWC"===a,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`));const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],h=l*i,d=u*i,p=c/(i*i),f=n.data.get(s.dataId).values,m=new Float32Array(o*h*d*p);let g=0;for(let t=0;t<o;++t)for(let e=0;e<h;++e){const n=Math.floor(e/i),r=e%i;for(let e=0;e<d;++e){const s=Math.floor(e/i),a=(r*i+e%i)*p;for(let e=0;e<p;++e){const r=e+a+c*(s+u*(n+l*t));m[g++]=f[r]}}}return n.makeTensorInfo([o,h,d,p],s.dtype,m)}};function MP(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=r;_L([s,i],"depthwiseConv2DNative");const c=cm(s.shape),h=cm(i.shape);let d=l;null==d&&(d=[1,1]),Uf(Dw(a,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`));const p=Mw(s.shape,i.shape,a,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:x,padInfo:y}=p,v=y.left,b=y.top,w=p.outChannels/p.inChannels,S=new pv(p.outShape,s.dtype),_=n.data.get(s.dataId).values,T=n.data.get(i.dataId).values,M=S.values;for(let t=0;t<p.batchSize;++t){const e=t*c[0],n=t*S.strides[0];for(let t=0;t<p.outHeight;++t){const r=n+t*S.strides[1],s=t*p.strideHeight-b;for(let t=0;t<f;++t){const n=s+t*g;if(n<0||n>=p.inHeight)continue;const i=t*h[0],a=e+n*c[1];for(let t=0;t<p.outWidth;++t){const e=r+t*S.strides[2],n=t*p.strideWidth-v;for(let t=0;t<m;++t){const r=n+t*x;if(r<0||r>=p.inWidth)continue;const s=i+t*h[1],o=a+r*p.inChannels;let l=e,u=s;for(let t=0;t<p.inChannels;++t){const e=_[o+t];for(let t=0;t<w;++t)M[l+t]+=e*T[u+t];l+=w,u+=w}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const EP={kernelName:fg,backendName:"cpu",kernelFunc:MP},kP={kernelName:mg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;_L([s,i],"depthwiseConv2dNativeBackpropFilter");const h=Mw(s.shape,c,a,o,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new pv(h.filterShape,"float32"),x=h.padInfo.left,y=h.padInfo.top,v=h.outChannels/h.inChannels,b=n.data.get(s.dataId).values,w=new pv(s.shape,s.dtype,b),S=n.data.get(i.dataId).values,_=new pv(i.shape,i.dtype,S);for(let t=0;t<f;++t){const e=Math.max(0,Math.ceil((y-t)/d)),n=Math.min(h.outHeight,(h.inHeight+y-t)/d);for(let r=0;r<m;++r){const s=Math.max(0,Math.ceil((x-r)/p)),i=Math.min(h.outWidth,(h.inWidth+x-r)/p);for(let a=0;a<h.outChannels;++a){const o=Math.trunc(a/v),l=a%v;let u=0;for(let l=0;l<h.batchSize;++l)for(let c=e;c<n;++c){const e=t+c*d-y;for(let t=s;t<i;++t){const n=r+t*p-x;u+=w.get(l,e,n,o)*_.get(l,c,t,a)}}g.set(u,t,r,o,l)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},IP={kernelName:gg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;_L([s,i],"depthwiseConv2DNativeBackpropInput");const h=cm(s.shape),d=cm(i.shape),p=Mw(c,i.shape,a,o,l,u,!0),f=new pv(p.inShape,"float32"),m=f.values,[g,x,y]=f.strides,v=n.data.get(s.dataId).values,[b,w,S]=h,_=n.data.get(i.dataId).values,[T,M,E]=d,{batchSize:k,filterHeight:I,filterWidth:C,inChannels:A,inHeight:R,inWidth:N,outChannels:D,outHeight:L,outWidth:F,strideHeight:P,strideWidth:$}=p,O=I-1-p.padInfo.top,z=C-1-p.padInfo.left,B=D/A;for(let t=0;t<k;++t)for(let e=0;e<A;++e)for(let n=0;n<R;++n){const r=n-O,s=Math.max(0,Math.ceil(r/P)),i=Math.min(L,(I+r)/P);for(let a=0;a<N;++a){const o=a-z,l=Math.max(0,Math.ceil(o/$)),u=Math.min(F,(C+o)/$);let c=0;for(let n=s;n<i;++n){const s=n*P-r;for(let r=l;r<u;++r){const i=b*t+w*n+S*r,a=T*(I-1-s)+M*(C-1-(r*$-o))+E*e;for(let t=0;t<B;++t)c+=v[i+(e*B+t)]*_[a+t]}}m[g*t+x*n+y*a+e]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},CP={kernelName:xg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,s=Hf(r.shape),i=n.data.get(r.dataId).values,a=Ib([s,s],r.dtype),o=a.values;for(let t=0;t<i.length;t++)o[t*s+t]=i[t];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,a.dtype,a.values)}},AP={kernelName:yg,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s}=t,{strides:i,pad:a,dilations:o}=n,l=e,u=l.data.get(r.dataId).values,c=r.shape.length,h=l.data.get(s.dataId).values,d=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:x,outWidth:y,padInfo:v,strideHeight:b,strideWidth:w,filterHeight:S,filterWidth:_,dilationHeight:T,dilationWidth:M,outShape:E}=Sw(r.shape,s.shape,i,a,"NHWC",o),k=Hf(E),I=E.length,C=em(r.dtype,k);for(let t=0;t<p;++t)for(let e=0;e<x;++e){const n=e*b-v.top;for(let i=0;i<y;++i){const a=i*w-v.left;for(let o=0;o<g;++o){let l=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const i=n+e*T;if(i>=0&&i<f)for(let n=0;n<_;++n){const p=a+n*M;if(p>=0&&p<m){const a=xm([t,i,p,o],c,cm(r.shape)),f=xm([e,n,o],d,cm(s.shape)),m=u[a]+h[f];m>l&&(l=m)}}}C[xm([t,e,i,o],I,cm(E))]=l}}}return{dataId:l.write(ev(C,r.dtype),E,r.dtype),shape:E,dtype:r.dtype}}},RP={kernelName:bg,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s,dy:i}=t,{strides:a,pad:o,dilations:l}=n,u=e,c=dm(r.shape,u.data.get(r.dataId).values),h=dm(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:x,padInfo:y,strideHeight:v,strideWidth:b,filterHeight:w,filterWidth:S,dilationHeight:_,dilationWidth:T,outShape:M}=Sw(r.shape,s.shape,a,o,"NHWC",l);Uf(i.rank===M.length,(()=>`Error in Dilation2DBackpropFilter, dy must have the same rank as output ${M.length}, but got ${i.rank}`));const E=dm(M,u.data.get(i.dataId).values),k=mm(s.shape,s.dtype);for(let t=0;t<d;++t)for(let e=0;e<g;++e){const n=e*v-y.top;for(let r=0;r<x;++r){const s=r*b-y.left;for(let i=0;i<m;++i){let a=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let e=0;e<w;++e){const r=n+e*_;if(r>=0&&r<p)for(let n=0;n<S;++n){const u=s+n*T;if(u>=0&&u<f){const s=c[t][r][u][i]+h[e][n][i];s>a&&(a=s,o=e,l=n)}}}k[o][l][i]+=E[t][e][r][i]}}}return{dataId:u.write(ev(k,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},NP={kernelName:vg,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,filter:s,dy:i}=t,{strides:a,pad:o,dilations:l}=n,u=e,c=dm(r.shape,u.data.get(r.dataId).values),h=dm(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:x,padInfo:y,strideHeight:v,strideWidth:b,filterHeight:w,filterWidth:S,dilationHeight:_,dilationWidth:T,outShape:M}=Sw(r.shape,s.shape,a,o,"NHWC",l);Uf(i.rank===M.length,(()=>`Error in Dilation2DBackpropInput, dy must have the same rank as output ${M.length}, but got ${i.rank}`));const E=dm(M,u.data.get(i.dataId).values),k=mm(r.shape,r.dtype);for(let t=0;t<d;++t)for(let e=0;e<g;++e){const n=e*v-y.top;for(let r=0;r<x;++r){const s=r*b-y.left;for(let i=0;i<m;++i){let a=Number.MIN_SAFE_INTEGER,o=n<0?0:n,l=s<0?0:s;for(let e=0;e<w;++e){const r=n+e*_;if(r>=0&&r<p)for(let n=0;n<S;++n){const u=s+n*T;if(u>=0&&u<f){const s=c[t][r][u][i]+h[e][n][i];s>a&&(a=s,o=r,l=u)}}}k[t][o][l][i]+=E[t][e][r][i]}}}return{dataId:u.write(ev(k,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},DP=LL(((t,e)=>t*e)),LP=eF(((t,e,n,r)=>({real:t*n-e*r,imag:t*r+e*n}))),FP=tF(gx,DP,LP),PP={kernelName:gx,backendName:"cpu",kernelFunc:FP};function $P(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r;let o;_L(s,"sum"),o="bool"===s.dtype?ZL({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):AL({inputs:{x:s},backend:n});const l=o.shape.length,u=Zf(i,o.shape),c=PS(u,l);let h=u,d=o;null!=c&&(d=vF({inputs:{x:o},backend:n,attrs:{perm:c}}),h=OS(h.length,l)),FS("sum",h,d.shape.length);const[p,f]=DS(d.shape,h);let m=KL(n,p,Ev(d.dtype,"int32"));const g=Hf(f),x=n.data.get(m.dataId).values,y=n.data.get(d.dataId).values;for(let t=0;t<x.length;++t){const e=t*g;let n=0;for(let t=0;t<g;++t)n+=y[e+t];x[t]=n}if(a){const t=m;m=aF({inputs:{x:m},backend:n,attrs:{shape:LS(m.shape,u)}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),m}const OP={kernelName:Qx,backendName:"cpu",kernelFunc:$P},zP={kernelName:Sg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,i=e,{allDims:a,summedDims:o,idDims:l}=vM(s,i.length);wM(a.length,l,i);const{path:u,steps:c}=SM(o,l),h=c.length;let d=null,p=a.length;const f=[];for(let t=0;t<h;++t){for(const e of c[t]){const{permutationIndices:t,expandDims:r}=bM(p,l[e]);let s;_M(t)?s=i[e]:(s=vF({inputs:{x:i[e]},backend:n,attrs:{perm:t}}),f.push(s));const a=s.shape.slice();for(let t=0;t<r.length;++t)a.splice(r[t],0,1);jf(s.shape,a)||(s=aF({inputs:{x:s},backend:n,attrs:{shape:a}}),f.push(s)),null===d?d=s:(d=FP({inputs:{a:s,b:d},backend:n}),f.push(d))}t<h-1&&(u[t]>=0&&(d=$P({inputs:{x:d},backend:n,attrs:{axis:u[t]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const t of f)t!==d&&n.disposeIntermediateTensorInfo(t);return d}},BP={kernelName:Tg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{dy:r,y:s}=e;_L([r,s],"eluGrad");const i=new Float32Array(Hf(s.shape)),a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let t=0;t<a.length;++t){const e=a[t];i[t]=e>=1?o[t]:o[t]*(e+1)}return n.makeTensorInfo(s.shape,"float32",i)}},UP=LL(((t,e)=>t===e?1:0)),WP=tF(Eg,UP,null,"bool"),VP={kernelName:Eg,backendName:"cpu",kernelFunc:WP},GP=sM,HP=iM,jP=aM,qP=oM,XP=lM,KP=uM,YP=EL(Mg,(t=>{const e=Math.sign(t),n=Math.abs(t),r=1/(1+GP*n);return e*(1-((((KP*r+XP)*r+qP)*r+jP)*r+HP)*r*Math.exp(-n*n))})),JP={kernelName:Mg,backendName:"cpu",kernelFunc:YP},ZP=WL((t=>Math.exp(t))),QP=kL(kg,ZP,"float32"),t$={kernelName:kg,backendName:"cpu",kernelFunc:QP};function e$(t){const{inputs:e,backend:n,attrs:r}=t,{input:s}=e,{dim:i}=r,a=s.shape.length,o=s.shape.slice();let l=i;return i<0&&(Uf(-(a+1)<=i,(()=>`Axis must be in the interval [${-(a+1)}, ${a}]`)),l=a+i+1),o.splice(l,0,1),aF({inputs:{x:s},backend:n,attrs:{shape:o}})}const n$={kernelName:Ig,backendName:"cpu",kernelFunc:e$},r$=WL((t=>Math.expm1(t))),s$=kL(Cg,r$),i$={kernelName:Cg,backendName:"cpu",kernelFunc:s$},a$=LL(((t,e)=>t/e)),o$=tF(wg,a$),l$={kernelName:wg,backendName:"cpu",kernelFunc:o$},u$=LL(((t,e)=>t-e)),c$=eF(((t,e,n,r)=>({real:t-n,imag:e-r}))),h$=tF(fy,u$,c$),d$={kernelName:fy,backendName:"cpu",kernelFunc:h$};function p$(t,e,n){const r=t.shape,s=r[0],i=r[1],a=n.data.get(t.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[s,i],c=Hf(u),h=tm("float32",c),d=tm("float32",c);for(let t=0;t<s;t++){const r=HF({inputs:{x:o},backend:n,attrs:{begin:[t,0],size:[1,i]}}),s=HF({inputs:{x:l},backend:n,attrs:{begin:[t,0],size:[1,i]}}),a=qL({inputs:{real:r,imag:s},backend:n}),{real:u,imag:c}=f$(a,e,n),p=cM(u,c);for(let e=0;e<i;e++){const n=fM(p,e);h[t*i+e]=n.real,d[t*i+e]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a)}const p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),m=qL({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function f$(t,e,n){const r=Hf(t.shape),s=n.data.get(t.dataId),i=n.data.get(s.complexTensorInfos.real.dataId).values,a=n.data.get(s.complexTensorInfos.imag.dataId).values;if(0==((o=r)&o-1)){const s=m$(i,a,r,e,n),o=[t.shape[0],t.shape[1]];if(e){const t=n.makeTensorInfo(o,"float32",s.real),e=n.makeTensorInfo(o,"float32",s.imag),i=n.makeTensorInfo([],"float32",tv(r,"float32")),a=AL({inputs:{x:i},backend:n}),l=l$.kernelFunc({inputs:{a:t,b:i},backend:n}),u=l$.kernelFunc({inputs:{a:e,b:a},backend:n}),c=n.data.get(l.dataId).values,h=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:h}}return s}{const t=function(t,e,n){const r=new Float32Array(2*e);for(let s=0;s<e;s++){let i=0,a=0;for(let r=0;r<e;r++){const o=xM(s*r,e,n),l=fM(t,r);i+=l.real*o.real-l.imag*o.imag,a+=l.real*o.imag+l.imag*o.real}n&&(i/=e,a/=e),mM(r,i,a,s)}return r}(cM(i,a),r,e);return hM(t)}var o}function m$(t,e,n,r,s){if(1===n)return{real:t,imag:e};const i=cM(t,e),a=n/2,o=dM(i),l=o.real,u=o.imag,c=[l.length],h=s.makeTensorInfo(c,"float32",l),d=s.makeTensorInfo(c,"float32",u),p=qL({inputs:{real:h,imag:d},backend:s}),f=pM(i),m=f.real,g=f.imag,x=[m.length],y=s.makeTensorInfo(x,"float32",m),v=s.makeTensorInfo(x,"float32",g),b=qL({inputs:{real:y,imag:v},backend:s}),w=m$(l,u,a,r,s),S=w.real,_=w.imag,T=[S.length],M=s.makeTensorInfo(T,"float32",S),E=s.makeTensorInfo(T,"float32",_),k=qL({inputs:{real:M,imag:E},backend:s}),I=m$(m,g,a,r,s),C=I.real,A=I.imag,R=[C.length],N=s.makeTensorInfo(R,"float32",C),D=s.makeTensorInfo(R,"float32",A),L=qL({inputs:{real:N,imag:D},backend:s}),F=gM(n,r),P=[F.real.length],$=s.makeTensorInfo(P,"float32",F.real),O=s.makeTensorInfo(P,"float32",F.imag),z=qL({inputs:{real:$,imag:O},backend:s}),B=FP({inputs:{a:z,b:L},backend:s}),U=sF({inputs:{a:k,b:B},backend:s}),W=h$({inputs:{a:k,b:B},backend:s}),V=YL({inputs:{input:U},backend:s}),G=YL({inputs:{input:W},backend:s}),H=iP({inputs:{input:U},backend:s}),j=iP({inputs:{input:W},backend:s}),q=oP({inputs:[V,G],backend:s,attrs:{axis:0}}),X=oP({inputs:[H,j],backend:s,attrs:{axis:0}}),K=s.data.get(q.dataId).values,Y=s.data.get(X.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(k),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(X),{real:K,imag:Y}}const g$={kernelName:Ag,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,s=Hf(r.shape),i=r.shape[r.shape.length-1],a=aF({inputs:{x:r},backend:n,attrs:{shape:[s/i,i]}}),o=p$(a,!1,n),l=aF({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}};function x$(t){const{backend:e,attrs:n}=t,{shape:r,value:s,dtype:i}=n,a=i||om(s),o=em(a,Hf(r));return function(t,e,n){t.fill(e)}(o,s),e.makeTensorInfo(r,a,o)}const y$={kernelName:Rg,backendName:"cpu",kernelFunc:x$},v$={kernelName:Ng,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,s=n,i=tm(r.dtype,Hf(r.shape)),[a,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let t=0;t<a;t++){const e=t*l*o*u;for(let t=0;t<o;t++){const n=t*(l*u);for(let t=0;t<l;t++){const r=t*u;for(let s=0;s<u;s++){const a=Math.round(l-t-1),o=e+n+r+s;let h=c[o];a>=0&&a<l&&(h=c[e+n+a*u+s]),i[o]=h}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},b$=WL((t=>Math.floor(t))),w$=kL(Dg,b$),S$={kernelName:Dg,backendName:"cpu",kernelFunc:w$},_$=LL(((t,e)=>Math.floor(t/e))),T$=tF(Lg,_$,null,"int32"),M$={kernelName:Lg,backendName:"cpu",kernelFunc:T$},E$={kernelName:Iy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=uP({inputs:{x:s,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const t=m;if("NCHW"===c&&1===a.shape.length&&1!==a.shape[0]){const t=aF({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});m=sF({inputs:{a:m,b:t},backend:n}),n.disposeIntermediateTensorInfo(t)}else m=sF({inputs:{a:m,b:a},backend:n});n.disposeIntermediateTensorInfo(t)}if(p){const t=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const t=aF({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=jL(n,m,p,t,f),n.disposeIntermediateTensorInfo(t)}else m=jL(n,m,p,o,f);n.disposeIntermediateTensorInfo(t)}return m}},k$={kernelName:Cy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let m=MP({inputs:{x:s,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const t=m;m=sF({inputs:{a:m,b:a},backend:n}),n.disposeIntermediateTensorInfo(t)}if(p){const t=m;m=jL(n,m,p,o,f),n.disposeIntermediateTensorInfo(t)}return m}};function I$(t,e,n,r,s,i,a,o,l){const u=Ib([r,i],n);for(let n=0;n<r;n++){const r=[];let c=0;for(let e=0;e<s;e++){const i=t[n*s+e];c+=i*a[e],r.push(i)}if(c<0||c>=l/i)throw new Error(`Invalid indices: ${r} does not index into ${o}`);for(let t=0;t<i;t++)u.values[n*i+t]=e.get(...e.indexToLoc(c*i+t))}return u}const C$={kernelName:$g,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,i=Hf(r.shape),a=s.shape,o=a[a.length-1],[l,u,c,h]=ZT(r,s);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const d=I$(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,u,o,c,h,r.shape,i);return n.makeTensorInfo(l,r.dtype,d.values)}};function A$(t,e,n){const r=Ib(n,t.dtype);for(let n=0;n<r.size;++n){const s=r.indexToLoc(n).slice(),i=s[0],a=s[2],o=e.locToIndex([i,a]);s[2]=e.values[o];const l=t.locToIndex(s);0<=l&&l<t.values.length&&(r.values[n]=t.values[l])}return r}const R$={kernelName:Pg,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:i}=e,{axis:a,batchDims:o}=r;_L([s,i],"gatherV2");const l=Zf(a,s.shape)[0],u=n.data.get(i.dataId).values,c=s.shape[l];for(let t=0;t<u.length;++t){const e=u[t];Uf(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let h=o;null==o&&(h=0);const d=Hf(i.shape),p=BM(s,i,l,h),f=aF({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=aF({inputs:{x:i},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],x=n.bufferSync(m),y=A$(n.bufferSync(f),x,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},N$=LL(((t,e)=>t>e?1:0)),D$=tF(Og,N$,null,"bool"),L$={kernelName:Og,backendName:"cpu",kernelFunc:D$},F$=LL(((t,e)=>t>=e?1:0)),P$=tF(zg,F$,null,"bool"),$$={kernelName:zg,backendName:"cpu",kernelFunc:P$},O$={kernelName:Ug,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e,s=Hf(r.shape),i=r.shape[r.shape.length-1],a=aF({inputs:{x:r},backend:n,attrs:{shape:[s/i,i]}}),o=p$(a,!0,n),l=aF({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}},z$=EL(Vg,(t=>Number.isFinite(t)?1:0),"bool"),B$={kernelName:Vg,backendName:"cpu",kernelFunc:z$},U$=EL(Gg,(t=>Math.abs(t)===1/0?1:0),"bool"),W$={kernelName:Gg,backendName:"cpu",kernelFunc:U$},V$=EL(Hg,(t=>Number.isNaN(t)?1:0),"bool"),G$={kernelName:Hg,backendName:"cpu",kernelFunc:V$},H$=LL(((t,e)=>t<e?1:0)),j$=tF(qg,H$,null,"bool"),q$={kernelName:qg,backendName:"cpu",kernelFunc:j$},X$=LL(((t,e)=>t<=e?1:0)),K$=tF(Xg,X$,null,"bool"),Y$={kernelName:Xg,backendName:"cpu",kernelFunc:K$};function J$(t,e,n){const r=(e-t)/(n-1),s=fm(n,"float32");s[0]=t;for(let t=1;t<s.length;t++)s[t]=s[t-1]+r;return s}const Z$={kernelName:Kg,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:i}=n,a=J$(r,s,i);return e.makeTensorInfo([a.length],"float32",a)}},Q$=WL((t=>Math.log(t))),tO=kL(Yg,Q$),eO={kernelName:Yg,backendName:"cpu",kernelFunc:tO},nO=EL(Jg,(t=>Math.log1p(t))),rO={kernelName:Jg,backendName:"cpu",kernelFunc:nO},sO=LL(((t,e)=>t&&e)),iO=tF(Zg,sO,null,"bool"),aO={kernelName:Zg,backendName:"cpu",kernelFunc:iO},oO=EL(Qg,(t=>t?0:1),"bool"),lO={kernelName:Qg,backendName:"cpu",kernelFunc:oO},uO=LL(((t,e)=>t||e)),cO=tF(tx,uO,null,"bool"),hO={kernelName:tx,backendName:"cpu",kernelFunc:cO},dO={kernelName:ex,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=r;_L(s,"LRN");const u=s.shape[3],c=u-1,h=n.data.get(s.dataId).values,d=Hf(s.shape),p=new Float32Array(d);function f(t){const e=t%u;let n=t-e+Math.max(0,e-i);const r=t-e+Math.min(e+i,c);let s=0;for(;n<=r;n++){const t=h[n];s+=t*t}return s}for(let t=0;t<d;t++){const e=f(t),n=h[t]*Math.pow(a+o*e,-l);p[t]=n}return n.makeTensorInfo(s.shape,s.dtype,p)}},pO={kernelName:nx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=r;_L(a,"LRNGrad");const h=Hf(a.shape),d=a.shape[3],p=n.data.get(a.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(i.dataId).values,g=new Float32Array(h),x=h;for(let t=0;t<x;t++){const e=t%d,n=t-e+Math.max(0,e-o),r=t-e+Math.min(d,e+o+1);let s=0;for(let t=n;t<r;t++)s+=Math.pow(f[t],2);s=u*s+l;for(let e=n;e<r;e++){let n=-2*u*c*f[e]*m[t]/s;t===e&&(n+=Math.pow(s,-c)),n*=p[t],g[e]+=n}}return n.makeTensorInfo(a.shape,s.dtype,g)}};function fO(t,e,n,r){const s=tm(r,Hf(n));for(let n=0;n<s.length;++n){const r=n*e;let i=t[r];for(let n=0;n<e;++n){const e=t[r+n];(Number.isNaN(e)||e>i)&&(i=e)}s[n]=i}return s}function mO(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:i,keepDims:a}=r,o=n;let l=s.shape;const u=l.length,c=Zf(i,l);let h=c;const d=PS(h,u);let p=o.data.get(s.dataId).values;if(null!=d){const t=new Array(u);for(let e=0;e<t.length;e++)t[e]=l[d[e]];p=yF(p,l,s.dtype,d,t),h=OS(h.length,u),l=t}_L(s,"max"),FS("max",h,u);const[f,m]=DS(l,h),g=fO(p,Hf(m),f,s.dtype),x=o.write(g,f,s.dtype);let y=f;return a&&(y=LS(f,c)),{dataId:x,shape:y,dtype:s.dtype}}const gO={kernelName:rx,backendName:"cpu",kernelFunc:mO},xO=LL(((t,e)=>Math.max(t,e))),yO=tF(sx,xO),vO={kernelName:sx,backendName:"cpu",kernelFunc:yO},bO={kernelName:ix,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;_L(s,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=r;Uf(Dw(a,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=_w(s.shape,i,a,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&jf(u.inShape,u.outShape))c=AL({inputs:{x:s},backend:n});else{const t=n.data.get(s.dataId).values,e=cm(s.shape),r=PF(t,s.shape,s.dtype,e,u,"max");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}},wO={kernelName:ox,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r;_L(s,"maxPool3d");const c=Tw(s.shape,i,a,1,o,l,u),h=OF(n.data.get(s.dataId).values,s.shape,s.dtype,cm(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},SO={kernelName:lx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=r;_L([s,i],"maxPool3DGrad");const c=Tw(i.shape,a,o,1,l,u),h=function(t,e){const n=Ib(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let x=0;x<e.outDepth;++x){const y=x*r-d;let v=y;for(;v<0;)v+=a;const b=Math.min(e.inDepth,u+y);for(let r=0;r<e.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=o;const w=Math.min(e.inHeight,c+u);for(let s=0;s<e.outWidth;++s){const p=s*i-f;let S=p;for(;S<0;)S+=l;const _=Math.min(e.inWidth,h+p);let T=Number.NEGATIVE_INFINITY,M=-1;for(let e=v;e<b;e+=a){const n=e-y;for(let r=d;r<w;r+=o){const s=r-u;for(let i=S;i<_;i+=l){const a=i-p,o=t.get(m,e,r,i,g);o>=T&&(T=o,M=n*c*h+s*c+a)}}}n.set(M,m,x,r,s,g)}}}return n}(n.bufferSync(i),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,x=c.dilationWidth,y=c.effectiveFilterDepth,v=c.effectiveFilterHeight,b=c.effectiveFilterWidth,w=y-1-c.padInfo.front,S=b-1-c.padInfo.left,_=v-1-c.padInfo.top,T=Ib(i.shape,"float32"),M=n.bufferSync(s);for(let t=0;t<c.batchSize;++t)for(let e=0;e<c.inChannels;++e)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let s=0;s<c.inWidth;++s){const i=n-w,a=r-_,o=s-S;let l=0;for(let n=0;n<y;n+=m){const r=(i+n)/d;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let s=0;s<v;s+=g){const i=(a+s)/p;if(!(i<0||i>=c.outHeight||Math.floor(i)!==i))for(let a=0;a<b;a+=x){const u=(o+a)/f;if(u<0||u>=c.outWidth||Math.floor(u)!==u)continue;const d=y*v*b-1-h.get(t,r,i,u,e)===n*v*b+s*b+a?1:0;0!==d&&(l+=M.get(t,r,i,u,e)*d)}}}T.set(l,t,n,r,s,e)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}},_O={kernelName:ax,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i,output:a}=e,o=i;_L([i,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=_w(o.shape,l,u,1,c,h),p=n.data.get(o.dataId).values,f=Ib(d.outShape,o.dtype,$F(p,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,x=d.dilationHeight,y=d.dilationWidth,v=d.effectiveFilterHeight,b=d.effectiveFilterWidth,w=b-1-d.padInfo.left,S=v-1-d.padInfo.top,_=Ib(o.shape,"float32"),T=n.data.get(s.dataId).values,M=Ib(s.shape,"float32",T);for(let t=0;t<d.batchSize;++t)for(let e=0;e<d.inChannels;++e)for(let n=0;n<d.inHeight;++n)for(let r=0;r<d.inWidth;++r){const s=n-S,i=r-w;let a=0;for(let n=0;n<v;n+=x){const r=(s+n)/m;if(!(r<0||r>=d.outHeight||Math.floor(r)!==r))for(let s=0;s<b;s+=y){const o=(i+s)/g;if(o<0||o>=d.outWidth||Math.floor(o)!==o)continue;const l=v*b-1-f.get(t,r,o,e)===n*b+s?1:0;0!==l&&(a+=M.get(t,r,o,e)*l)}}_.set(a,t,n,r,e)}return n.makeTensorInfo(_.shape,_.dtype,_.values)}},TO={kernelName:ux,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:i,pad:a,includeBatchInIndex:o}=e,l=n;_L(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=_w(r.shape,s,i,[1,1],a),[h,d]=function(t,e,n,r,s){const i=PF(t,0,n,cm(e),s,"max"),a=$F(t,e,n,s,!0,r);return[i.values,a.values]}(u,r.shape,r.dtype,o,c),p=l.write(h,c.outShape,r.dtype),f=l.write(d,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},MO={kernelName:cx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r,o=Zf(i,s.shape),l=Hf(DS(s.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const h=ZL({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});u.push(h);const d=o$({inputs:{a:h,b:c},backend:n});u.push(d);const p=$P({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:a}});return u.forEach((t=>n.disposeIntermediateTensorInfo(t))),p}},EO={kernelName:hx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r;_L(s,"min");const o=Zf(i,s.shape);let l=o;const u=PS(l,s.shape.length);let c=s;null!=u&&(c=vF({inputs:{x:s},backend:n,attrs:{perm:u}}),l=OS(l.length,s.shape.length)),FS("min",l,c.shape.length);const[h,d]=DS(c.shape,l),p=Hf(d),f=fm(Hf(h),c.dtype),m=n.data.get(c.dataId).values;for(let t=0;t<f.length;++t){const e=t*p;let n=m[e];for(let t=0;t<p;++t){const r=m[e+t];(Number.isNaN(r)||r<n)&&(n=r)}f[t]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(h,c.dtype,f);if(a){const t=aF({inputs:{x:g},backend:n,attrs:{shape:LS(h,o)}});return n.disposeIntermediateTensorInfo(g),t}return g}},kO=LL(((t,e)=>Math.min(t,e))),IO=tF(dx,kO),CO={kernelName:dx,backendName:"cpu",kernelFunc:IO},AO={kernelName:px,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:i,mode:a}=r;_L(s,"mirrorPad");const o=i.map(((t,e)=>t[0]+s.shape[e]+t[1])),l=i.map((t=>t[0])),u=i.map(((t,e)=>t[0]+s.shape[e])),c="reflect"===a?0:1,h=n.data.get(s.dataId).values,d=s.shape.length,p=cm(s.shape),f=Hf(o),m=o.length,g=cm(o),x=tm(s.dtype,f);for(let t=0;t<f;t++){let e=ym(t,m,g);for(let t=0;t<m;t++)e[t]<l[t]?e[t]=2*l[t]-e[t]-c:e[t]>=u[t]&&(e[t]=2*(u[t]-1)-e[t]+c);e=e.map(((t,e)=>t-l[e]));const n=xm(e,d,p);x[t]=h[n]}return{dataId:n.write(x,o,s.dtype),shape:o,dtype:s.dtype}}},RO=LL(((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e})),NO=tF(fx,RO),DO={kernelName:fx,backendName:"cpu",kernelFunc:NO};var LO=n(2948);function FO(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:i}=r,a=s.shape.length;let o=i;if(-1===o&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=Zf([o],s.shape),u=mO({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=LS(u.shape,l),h=aF({inputs:{x:u},backend:n,attrs:{shape:c}}),d=h$({inputs:{a:s,b:h},backend:n}),p=QP({inputs:{x:d},backend:n}),f=$P({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=aF({inputs:{x:f},backend:n,attrs:{shape:c}}),g=o$({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const PO={kernelName:ny,backendName:"cpu",kernelFunc:FO},$O={kernelName:mx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:i,seed:a,normalized:o}=r;_L(s,"multinomial");const l=o?s:FO({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,i],p=fm(Hf(d),"int32");for(let t=0;t<u;++t){const e=t*c,n=new Float32Array(c-1);n[0]=h[e];for(let t=1;t<n.length;++t)n[t]=n[t-1]+h[e+t];const r=LO.alea(a.toString()),s=t*i;for(let t=0;t<i;++t){const e=r();p[s+t]=n.length;for(let r=0;r<n.length;r++)if(e<n[r]){p[s+t]=r;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function OO(t,e,n){const r=tv(-1,n);return DP([],e,r,t,n)}const zO={kernelName:xx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;_L(r,"neg");const s=n.data.get(r.dataId).values,[i,a]=OO(s,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,i)}},BO=tT,UO={kernelName:vx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=r;_L(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:h}=BO(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},WO=eT,VO={kernelName:bx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;_L(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=WO(c,h,a,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},GO=nT,HO={kernelName:wx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;_L(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,h=n.data.get(i.dataId).values,d=a,p=o,f=l,m=u,{selectedIndices:g,selectedScores:x}=GO(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}},jO=LL(((t,e)=>t!==e?1:0)),qO=tF(yx,jO,null,"bool"),XO={kernelName:yx,backendName:"cpu",kernelFunc:qO},KO={kernelName:_x,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{depth:i,onValue:a,offValue:o}=r;_L(s,"oneHot");const l=Hf(s.shape),u=new Float32Array(l*i);u.fill(o);const c=n.data.get(s.dataId).values;for(let t=0;t<l;++t)c[t]>=0&&c[t]<i&&(u[t*i+c[t]]=a);return n.makeTensorInfo([...s.shape,i],"int32",u)}};function YO(t){const{inputs:e,backend:n}=t,{x:r}=e;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const t=YL({inputs:{input:r},backend:n}),e=YO({inputs:{x:t},backend:n}),s=iP({inputs:{input:r},backend:n}),i=YO({inputs:{x:s},backend:n}),a=qL({inputs:{real:e,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),a}return x$({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const JO={kernelName:Ty,backendName:"cpu",kernelFunc:YO},ZO={kernelName:Sx,backendName:"cpu",kernelFunc:function t(e){const{inputs:n,backend:r}=e,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const e=YL({inputs:{input:s},backend:r}),n=t({inputs:{x:e},backend:r}),i=iP({inputs:{input:s},backend:r}),a=YO({inputs:{x:i},backend:r}),o=qL({inputs:{real:n,imag:a},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),o}return x$({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function QO(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(1===e.length)return e$({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const i=e[0].shape,a=e[0].dtype;e.forEach((t=>{Wf(i,t.shape,"All tensors passed to stack must have matching shapes"),Uf(a===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=oP({inputs:e.map((t=>{const e=e$({inputs:{input:t},backend:n,attrs:{dim:s}});return o.push(e),e})),backend:n,attrs:{axis:s}});return o.forEach((t=>n.disposeIntermediateTensorInfo(t))),l}const tz={kernelName:Tx,backendName:"cpu",kernelFunc:QO},ez={kernelName:Mx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:i,constantValue:a}=r;_L(s,"pad");const o=i.map(((t,e)=>t[0]+s.shape[e]+t[1])),l=i.map((t=>t[0])),u=n.data.get(s.dataId).values,c=Hf(s.shape),h=s.shape.length,d=cm(s.shape),p=Hf(o),f=o.length,m=cm(o),g=tm(s.dtype,p);0!==a&&g.fill(a);for(let t=0;t<c;t++)g[xm(ym(t,h,d).map(((t,e)=>t+l[e])),f,m)]=u[t];return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},nz=LL(((t,e)=>Math.pow(t,e))),rz=tF(Ex,nz),sz={kernelName:Ex,backendName:"cpu",kernelFunc:rz};function iz(t,e,n,r){const[s,i]=DS(t,r),a=Ev(e,"int32"),o=fm(Hf(s),a),l=Hf(i);for(let t=0;t<o.length;++t){const e=t*l;let r=1;for(let t=0;t<l;++t)r*=n[e+t];o[t]=r}return{outVals:o,outShape:s,outDtype:a}}const az={kernelName:Ix,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r;_L(s,"prod");const o=s.shape.length,l=Zf(i,s.shape),u=PS(l,o);let c=l,h=s;const d=[];null!=u&&(h=vF({inputs:{x:s},backend:n,attrs:{perm:u}}),d.push(h),c=OS(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=iz(h.shape,h.dtype,p,c);let x=m;return a&&(x=LS(m,l)),d.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(x,g,f)}};function oz(t,e,n,r){if(t===e||t<e&&n<0||e<t&&n>1)return fm(0,r);const s=fm(Math.abs(Math.ceil((e-t)/n)),r);e<t&&1===n&&(n=-1),s[0]=t;for(let t=1;t<s.length;t++)s[t]=s[t-1]+n;return s}const lz={kernelName:Cx,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:s,dtype:i,step:a}=n,o=oz(r,s,a,i);return e.makeTensorInfo([o.length],i,o)}},uz=EL(Rx,(t=>1/t)),cz={kernelName:Rx,backendName:"cpu",kernelFunc:uz},hz={kernelName:Px,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:i,halfPixelCenters:a,size:o}=r;_L(s,"resizeBilinear");const l=cm(s.shape),[u,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(Hf([h,u,c,f])),x=[i&&u>1?d-1:d,i&&c>1?p-1:p],y=[i&&u>1?u-1:u,i&&c>1?c-1:c];let v=0;const b=x[0]/y[0],w=x[1]/y[1];for(let t=0;t<h;t++)for(let e=0;e<u;e++){let n;n=a?b*(e+.5)-.5:b*e;const r=Math.max(0,Math.floor(n)),s=n-r,i=Math.min(d-1,Math.ceil(n)),o=t*l[0]+r*l[1],u=t*l[0]+i*l[1];for(let t=0;t<c;t++){let e;e=a?w*(t+.5)-.5:w*t;const n=Math.max(0,Math.floor(e)),r=e-n,i=Math.min(p-1,Math.ceil(e)),c=o+n*l[2],h=u+n*l[2],d=o+i*l[2],x=u+i*l[2];for(let t=0;t<f;t++){const e=m[c+t],n=m[h+t],i=e+(m[d+t]-e)*r,a=i+(n+(m[x+t]-n)*r-i)*s;g[v++]=a}}}return n.makeTensorInfo([h,u,c,f],"float32",g)}},dz={kernelName:$x,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:i}=e,{alignCorners:a}=r;_L([i,s],"resizeBilinearGrad");const o=cm(s.shape),[l,u,c,h]=s.shape,[,d,p]=i.shape,f=new Float32Array(l*u*c*h),m=[a&&d>1?u-1:u,a&&p>1?c-1:c],g=[a&&d>1?d-1:d,a&&p>1?p-1:p],x=m[0]/g[0],y=m[1]/g[1],v=n.data.get(i.dataId).values;let b=0;for(let t=0;t<l;t++){const e=t*o[0];for(let t=0;t<d;t++){const n=t*x,r=Math.floor(n),s=Math.min(Math.ceil(n),u-1),i=e+r*o[1],a=e+s*o[1],l=n-r,d=1-l;for(let t=0;t<p;t++){const e=t*y,n=Math.floor(e),r=Math.min(Math.ceil(e),c-1),s=e-n,u=1-s,p=i+n*o[2],m=i+r*o[2],g=a+n*o[2],x=a+r*o[2],w=d*u,S=d*s,_=l*u,T=l*s;for(let t=0;t<h;t++){const e=v[b++];f[p+t]+=e*w,f[m+t]+=e*S,f[g+t]+=e*_,f[x+t]+=e*T}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}},pz={kernelName:Lx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:i,halfPixelCenters:a,size:o}=r;_L(s,"resizeNearestNeighbor");const l=cm(s.shape),[u,c]=o,[h,d,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(h*u*c*f),x=[i&&u>1?d-1:d,i&&c>1?p-1:p],y=[i&&u>1?u-1:u,i&&c>1?c-1:c],v=x[0]/y[0],b=x[1]/y[1];let w=0;for(let t=0;t<h;t++){const e=t*l[0];for(let t=0;t<u;t++){const n=a?v*(t+.5):v*t;let r=Math.min(d-1,i?Math.round(n):Math.floor(n));a&&(r=Math.max(0,r));const s=e+r*l[1];for(let t=0;t<c;t++){const e=a?b*(t+.5):b*t;let n=Math.min(p-1,i?Math.round(e):Math.floor(e));a&&(n=Math.max(0,n));const r=s+n*l[2];for(let t=0;t<f;t++){const e=m[r+t];g[w++]=e}}}}return n.makeTensorInfo([h,u,c,f],s.dtype,g)}},fz={kernelName:Fx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:i}=e,{alignCorners:a}=r;_L([i,s],"resizeNearestNeighborGrad");const o=cm(s.shape),l=cm(i.shape),[u,c,h,d]=s.shape,[,p,f]=i.shape,m=new Float32Array(u*c*h*d),g=n.data.get(i.dataId).values,x=[a&&p>1?c-1:c,a&&f>1?h-1:h],y=[a&&p>1?p-1:p,a&&f>1?f-1:f],v=x[0]/y[0],b=x[1]/y[1],w=1/v,S=1/b,_=2*Math.ceil(w)+2,T=2*Math.ceil(S)+2;for(let t=0;t<u;t++){const e=t*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),s=Math.floor(r-_/2);for(let r=0;r<h;r++){const i=n+r*o[2],u=Math.floor(r*S),x=Math.floor(u-T/2);for(let n=0;n<d;n++){let o=0;for(let i=0;i<_;i++){const u=i+s;if(u<0||u>=p)continue;const d=e+u*l[1],m=u*v;if(t===Math.min(c-1,a?Math.round(m):Math.floor(m)))for(let t=0;t<T;t++){const e=t+x;if(e<0||e>=f)continue;const s=d+e*l[2],i=e*b;r===Math.min(h-1,a?Math.round(i):Math.floor(i))&&(o+=g[s+n])}}m[i+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}},mz={kernelName:zx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:i}=r;_L(s,"reverse");const a=s.shape.length,o=Zf(i,s.shape);if(0===a)return AL({inputs:{x:s},backend:n});const l=new pv(s.shape,s.dtype),u=n.bufferSync(s);for(let t=0;t<l.size;t++){const e=l.indexToLoc(t),n=e.slice();o.forEach((t=>n[t]=s.shape[t]-1-n[t])),l.set(u.get(...n),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},gz={kernelName:Ey,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:i,center:a}=e,o=n,l=tm(r.dtype,Hf(r.shape)),[u,c,h,d]=r.shape,[p,f]=jT(a,c,h),m=Math.sin(s),g=Math.cos(s),x=o.data.get(r.dataId).values;for(let t=0;t<u;t++){const e=t*h*c*d;for(let t=0;t<c;t++){const n=t*(h*d);for(let r=0;r<h;r++){const s=r*d;for(let a=0;a<d;a++){const o=[u,t,r,a],y=o[2],v=o[1];let b=(y-p)*g-(v-f)*m,w=(y-p)*m+(v-f)*g;b=Math.round(b+p),w=Math.round(w+f);let S=i;"number"!=typeof i&&(S=3===a?255:i[a]),b>=0&&b<h&&w>=0&&w<c&&(S=x[e+w*(h*d)+b*d+a]),l[e+n+s+a]=S}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},xz=EL(Bx,(t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2==0?e:e+1})),yz={kernelName:Bx,backendName:"cpu",kernelFunc:xz},vz=WL((t=>1/Math.sqrt(t))),bz=kL(Ux,vz),wz={kernelName:Ux,backendName:"cpu",kernelFunc:bz};function Sz(t,e,n,r,s,i,a,o,l,u){const c=[r/s,s],h=t.values,d=e.values;if(0===r)return Ib(n,e.dtype);const p=Ib(c,e.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let t=0;t<i;t++){const i=[];let l=0;for(let e=0;e<a;e++){const n=h[t*a+e];i.push(n),l+=n*o[e]}if(l<0||l>=r/s)throw new Error(`Invalid indices: ${i} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[l*s+n]+=d[t*s+n]:p.values[l*s+n]=0===e.rank?d[0]:d[t*s+n]}return p}const _z={kernelName:Wx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:i}=e,{shape:a}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=eM(0,s,a),d=Sz(n.bufferSync(s),n.bufferSync(i),a,h,u,l,o,c,0,!0);return n.makeTensorInfo(a,d.dtype,d.values)}};function Tz(t,e){let n=0,r=t.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),t[s]<e?n=s+1:r=s;return r}function Mz(t,e){let n=0,r=t.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),t[s]<=e?n=s+1:r=s;return r}const Ez={kernelName:Vx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:i}=e,{side:a}=r,o=function(t,e,n,r,s,i){const a=em("int32",n*s);for(let o=0;o<n;++o){const n=t.slice(o*r,(o+1)*r),l=o*s;for(let t=0;t<s;++t)a[l+t]="left"===i?Tz(n,e[t+l]):Mz(n,e[t+l])}return a}(n.data.get(s.dataId).values,n.data.get(i.dataId).values,s.shape[0],s.shape[1],i.shape[1],a);return n.makeTensorInfo(i.shape,"int32",o)}},kz={kernelName:Gx,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:i}=e;_L([r,s,i],"select");const a=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values,c=Ev(s.dtype,i.dtype),h=fm(Hf(s.shape),c);let d=0;const p=0===a||a>1||1===s.shape.length?1:Hf(s.shape.slice(1));for(let t=0;t<o.length;t++)for(let e=0;e<p;e++)1===o[t]?h[d++]=l[t]:h[d++]=u[t];return n.makeTensorInfo(s.shape,c,h)}},Iz=nM,Cz=rM,Az=EL(Hx,(t=>t>=0?Cz*t:Iz*(Math.exp(t)-1))),Rz={kernelName:Hx,backendName:"cpu",kernelFunc:Az},Nz=EL(Kx,(t=>t<0?-1:t>0?1:0)),Dz={kernelName:Kx,backendName:"cpu",kernelFunc:Nz},Lz=EL(qx,(t=>Math.sin(t))),Fz={kernelName:qx,backendName:"cpu",kernelFunc:Lz},Pz=EL(Xx,(t=>Math.sinh(t))),$z={kernelName:Xx,backendName:"cpu",kernelFunc:Pz},Oz=Math.log(1.1920928955078125e-7)+2,zz=EL(Jx,(t=>{const e=t>-Oz,n=t<Oz,r=Math.exp(t);let s;return s=n?r:e?t:Math.log(1+r),s})),Bz={kernelName:Jx,backendName:"cpu",kernelFunc:zz},Uz={kernelName:ty,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:i,paddings:a}=r;_L([s],"spaceToBatchND");const o=Hf(i),l=[[0,0]];l.push(...a);for(let t=1+i.length;t<s.shape.length;++t)l.push([0,0]);const u=ez.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=qT(u.shape,i,o,!1),h=XT(c.length,i.length,!1),d=KT(u.shape,i,o,!1),p=aF({inputs:{x:u},backend:n,attrs:{shape:c}}),f=vF({inputs:{x:p},backend:n,attrs:{perm:h}}),m=aF({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function Wz(t,e,n,r,s,i,a){const o=e[0],l=i[0],u=new Array(l),c=new Array(o),h=e[1];if(0===l){if(0!==o)throw new Error(EM(o));return[em(n,0),[0,h],em(s,0),u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let e=0;e<o;++e){const n=t[e*h];if(n<0)throw new Error(kM(e,n));if(n>=l)throw new Error(IM(e,n,l));++f[n],d=d&&n>=p,p=n}let m=!0;for(let t=0;t<l;++t){const e=0===f[t];u[t]=e,m=m&&!e,f[t]=Math.max(f[t],1),t>0&&(f[t]+=f[t-1])}if(m&&d){const e=t,n=r;for(let t=0;t<o;++t)c[t]=t;return[e,[o,h],n,u,c]}{const e=f[l-1],i=em(n,e*h),d=em(s,e),p=new Array(l).fill(0);for(let e=0;e<o;++e){const n=t[e*h],s=p[n],a=(0===n?0:f[n-1])+s;p[n]++;for(let n=0;n<h;++n)i[a*h+n]=t[e*h+n];d[a]=r[e],c[e]=a}for(let t=0;t<l;++t)if(0===p[t]){const e=0===t?0:f[t-1];i[e*h+0]=t;for(let t=1;t<h;++t)i[e*h+t]=0;d[e]=a}return[i,[e,h],d,u,c]}}const Vz={kernelName:ry,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:i,defaultValue:a}=e;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values[0],[h,d,p,f,m]=Wz(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function Gz(t,e,n,r,s){const i=Hf(r),a=e[0],o=s.length,l=[];let u=1,c=-1;for(let t=0;t<o;++t){const e=s[t];if(-1===e){if(-1!==c)throw new Error(CM(c,t));c=t,l.push(1)}else{if(e<0)throw new Error(AM(t,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const t=Math.trunc(i/u);if(u*t!==i)throw new Error(NM(r,l));l[c]=t}if(Hf(l)!==i)throw new Error(DM(r,l));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let t=h-2;t>=0;--t)d[t]=d[t+1]*r[t+1]}const p=[];if(o>0){p[o-1]=1;for(let t=o-2;t>=0;--t)p[t]=p[t+1]*l[t+1]}const f=em(n,a*o);for(let e=0;e<a;++e){let n=0;for(let r=0;r<h;++r)n+=t[e*h+r]*d[r];for(let t=0;t<o;++t)f[e*o+t]=Math.trunc(n/p[t]),n%=p[t]}return[f,[a,o],l]}const Hz={kernelName:sy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:i}=e;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(i.dataId).values),[u,c,h]=Gz(o,r.shape,r.dtype,a,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}};function jz(t,e,n,r,s,i=!1,a=0){const o=r.length,l=[e[0],t.length/e[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=e.slice();h[0]=c;const d=em(n,h.reduce(((t,e)=>t*e),1));if(0===o)return c>0&&d.fill(a),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let e=0;if(f<o){if(e=s[f],g===e){++f;continue}if(g>=e)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(PM(g,c));g>m&&d.fill(a,m*u,g*u);for(let e=p;e<f;++e){const n=r[e];if(n<0||n>=l[0])throw new Error($M(e,r[e],l[0]));for(let e=0;e<u;e++)d[g*u+e]+=t[n*u+e]}if(i)for(let t=0;t<u;t++)d[g*u+t]/=f-p;if(p=f,++f,m=g+1,g=e,f>o)break}return m<c&&d.fill(a,m*u,c*u),[d,h]}const qz={kernelName:iy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,[u,c]=jz(a,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},Xz={kernelName:ay,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values,[u,c]=jz(a,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},Kz={kernelName:oy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:i,defaultValue:a}=e,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=eM(0,s,o),p=!1,f=n.bufferSync(s);let m;switch(i.dtype){case"bool":m=Sz(f,n.bufferSync(i),o,d,c,u,l,h,Boolean(n.data.get(a.dataId).values[0]),p);break;case"float32":case"int32":m=Sz(f,n.bufferSync(i),o,d,c,u,l,h,n.data.get(a.dataId).values[0],p);break;case"string":m=Sz(f,n.bufferSync(i),o,d,c,u,l,h,sv(n.data.get(a.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}},Yz={kernelName:ey,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:i,axis:a}=r,o=Zf(a,s.shape)[0],l=MM(s,i,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map((t=>{const e=[...c];e[o]=t;const r=HF({inputs:{x:s},backend:n,attrs:{begin:u,size:e}});return u[o]+=t,r}))}},Jz=WL((t=>Math.sqrt(t))),Zz=EL(Zx,(t=>Math.sqrt(t))),Qz={kernelName:Zx,backendName:"cpu",kernelFunc:Zz},tB={kernelName:uy,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e;_L(n,"square");const s=r.data.get(n.dataId).values,i=new Float32Array(s.length);for(let t=0;t<s.length;++t){const e=s[t];i[t]=e*e}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},eB=LL(((t,e)=>{const n=t-e;return n*n})),nB=tF(ly,eB),rB={kernelName:ly,backendName:"cpu",kernelFunc:nB},sB=EL(My,((t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha})),iB={kernelName:My,backendName:"cpu",kernelFunc:sB};function aB(t,e,n,r){const s=Ib(t,e.dtype);for(let t=0;t<s.size;t++){const i=s.indexToLoc(t),a=new Array(i.length);for(let t=0;t<a.length;t++)a[t]=i[t]*n[t]+r[t];s.set(e.get(...a),...i)}return s}const oB={kernelName:cy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:i,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;_L(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:x,begin:y,end:v,strides:b}=nw(s.shape,i,a,o,l,u,c,h,d);let w;if(m)w=aF({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||x){Uf(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const t=Vb(y,v,b),e=HF({inputs:{x:s},backend:n,attrs:{begin:y,size:t}});w=aF({inputs:{x:e},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(e)}else{const t=aB(p,n.bufferSync(s),b,y);w=n.makeTensorInfo(f,t.dtype,t.values)}return w}};class lB{constructor(t,e,n,r,s,i){this.separator=rv(t),this.nGramWidths=e,this.leftPad=rv(n),this.rightPad=rv(r),this.padWidth=s,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,r,s,i){for(let a=0;a<s;++a){const o=this.getPadWidth(i),l=Math.max(0,o-a),u=Math.max(0,o-(s-(a+1))),c=i-(l+u),h=e+(l>0?0:a-o);let d=0;d+=l*this.leftPad.length;for(let e=0;e<c;++e)d+=t[h+e].length;d+=u*this.rightPad.length,d+=(l+u+c-1)*this.separator.length,n[r+a]=new Uint8Array(d);const p=n[r+a];let f=0;const m=t=>t.forEach((t=>p[f++]=t));for(let t=0;t<l;++t)m(this.leftPad),m(this.separator);for(let e=0;e<c-1;++e)m(t[h+e]),m(this.separator);if(c>0){m(t[h+c-1]);for(let t=0;t<u;++t)m(this.separator),m(this.rightPad)}else{for(let t=0;t<u-1;++t)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(t,e){const n=t.length,r=e.length;if(r>0){let t=e[0];if(0!==t)throw new Error(`First split value must be 0, got ${t}`);for(let s=1;s<r;++s){let r=e[s]>=t;if(r=r&&e[s]<=n,!r)throw new Error(`Invalid split value ${e[s]}, must be in [${t}, ${n}]`);t=e[s]}if(t!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${t}`)}const s=r-1,i=em("int32",r);if(0===n||0===r){const t=new Array(n);for(let t=0;t<=s;++t)i[t]=0;return[t,i]}i[0]=0;for(let t=1;t<=s;++t){const n=e[t]-e[t-1];let r=0;this.nGramWidths.forEach((t=>{r+=this.getNumNGrams(n,t)})),this.preserveShort&&n>0&&0===r&&(r=1),i[t]=i[t-1]+r}const a=new Array(i[s]);for(let n=0;n<s;++n){const r=e[n];let s=i[n];if(this.nGramWidths.forEach((i=>{const o=e[n+1]-e[n],l=this.getNumNGrams(o,i);this.createNGrams(t,r,a,s,l,i),s+=l})),this.preserveShort&&s===i[n]){const i=e[n+1]-e[n];if(0===i)continue;const o=i+2*this.padWidth,l=1;this.createNGrams(t,r,a,s,l,o)}}return[a,i]}}function uB(t,e,n,r,s,i,a,o){return new lB(n,r,s,i,a,o).compute(t,e)}const cB={kernelName:hy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=e,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,m]=uB(d,p,s,i,a,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function hB(t,e,n,r){if(!t.length)return;if(0===e.length){for(let e=0;e<t.length;++e)r.push(t.subarray(e,e+1));return}if(1===e.length){const s=e[0];let i=t.indexOf(s);for(;-1!==i;){const e=t.subarray(0,i);n&&0===e.length||r.push(e),i=(t=t.subarray(i+1)).indexOf(s)}return void(n&&0===t.length||r.push(t))}let s=0;for(let i=0;i<t.length+1;i++)if(i===t.length||-1!==e.indexOf(t[i])){const e=t.subarray(s,i);n&&0===e.length||r.push(e),s=i+1}}function dB(t,e,n){const r=t.length,s=[];let i=0,a=0;const o=new Array(r);for(let l=0;l<r;++l){const r=s.length;hB(t[l],e,n,s);const u=s.length-r;o[l]=u,i+=u,a=Math.max(a,u)}const l=em("int32",2*i),u=new Array(i),c=[r,a];let h=0;for(let t=0;t<r;++t)for(let e=0;e<o[t];++e)l[2*h]=t,l[2*h+1]=e,u[h]=s[h],++h;return[l,u,c]}const pB={kernelName:dy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:i,delimiter:a}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values[0],[u,c,h]=dB(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function fB(t,e){const n=em("int32",t.length);for(let r=0;r<t.length;++r)n[r]=Qy(t[r]).modulo(e).getLowBitsUnsigned();return n}const mB={kernelName:py,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:i}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=fB(n.data.get(i.dataId).values,s);return n.makeTensorInfo(i.shape,"int32",a)}},gB=EL(my,(t=>Math.tan(t))),xB={kernelName:my,backendName:"cpu",kernelFunc:gB},yB=EL(gy,(t=>Math.tanh(t)));function vB(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const r=Ib(n,t.dtype);for(let e=0;e<r.values.length;++e){const n=r.indexToLoc(e),s=new Array(t.rank);for(let e=0;e<s.length;e++)s[e]=n[e]%t.shape[e];const i=t.locToIndex(s);r.values[e]=t.values[i]}return r}const bB=(t,e)=>{const n=e.value-t.value;return 0===n?t.index-e.index:n};function wB(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const s=r-n+1,i=e-n+1,a=Math.log(s),o=.5*Math.exp(2*a/3),l=.5*Math.sqrt(a*o*(s-o)/s)*Math.sign(i-s/2);wB(t,e,Math.max(n,Math.floor(e-i*o/s+l)),Math.min(r,Math.floor(e+(s-i)*o/s+l)))}const s=t[e];let i=n,a=r;for(Bf(t,n,e),bB(t[r],s)>0&&Bf(t,n,r);i<a;){for(Bf(t,i,a),i++,a--;bB(t[i],s)<0;)i+=1;for(;bB(t[a],s)>0;)a-=1}0===bB(t[n],s)?Bf(t,n,a):(a+=1,Bf(t,a,r)),a<=e&&(n=a+1),e<=a&&(r=a-1)}}function SB(t,e,n,r,s){const i=e[e.length-1],[a,o]=[t.length/i,i],l=tm(n,a*r),u=tm("int32",a*r);for(let e=0;e<a;e++){const n=e*o,i=t.subarray(n,n+o);let a=new Array(i.length);i.forEach(((t,e)=>a[e]={value:t,index:e})),r<a.length&&(wB(a,r),a=a.slice(0,r)),s&&a.sort(bB);const c=e*r,h=l.subarray(c,c+r),d=u.subarray(c,c+r);for(let t=0;t<r;t++)h[t]=a[t].value,d[t]=a[t].index}const c=e.slice();return c[c.length-1]=r,[Ib(c,n,l),Ib(c,"int32",u)]}const _B={kernelName:vy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{image:s,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,d,p]=s.shape,[f,m]=null!=u?u:[h,d],g=[c,f,m,p],x=cm(s.shape),y=x[0],v=x[1],b=x[2],w=tm(s.dtype,Hf(g));w.fill(l);const S=r.data.get(s.dataId).values,_=r.data.get(i.dataId).values;for(let t=0;t<c;++t){const e=1===i.shape[0]?_:_.subarray(8*t,8*t+8);for(let n=0;n<f;++n)for(let r=0;r<m;++r)for(let s=0;s<p;++s){let i;const u=e[6]*r+e[7]*n+1;if(0===u)continue;const c=(e[0]*r+e[1]*n+e[2])/u,p=(e[3]*r+e[4]*n+e[5])/u,f=TB(c,d,o),m=TB(p,h,o);switch(a){case"nearest":i=EB(S,h,d,y,v,b,t,m,f,s,l);break;case"bilinear":i=kB(S,h,d,y,v,b,t,m,f,s,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}w[t*y+n*v+r*b+s]=i}return r.makeTensorInfo(g,s.dtype,w)}return{dataId:r.write(w,g,s.dtype),shape:s.shape,dtype:s.dtype}}};function TB(t,e,n){switch(n){case"reflect":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=2*e;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-e?n+t:-n-1}else if(n>e-1)if(e<=1)n=0;else{const t=2*e;n-=t*Math.trunc(n/t),n>=e&&(n=t-n-1)}return Of(0,n,e-1)}(t,e);case"wrap":return function(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const t=e-1;n+=e*(Math.trunc(-n/t)+1)}else if(n>e-1)if(e<=1)n=0;else{const t=e-1;n-=e*Math.trunc(n/t)}return Of(0,n,e-1)}(t,e);case"nearest":return function(t,e){return Of(0,t,e-1)}(t,e);default:return function(t,e){return t}(t)}}function MB(t,e,n,r,s,i,a,o,l,u,c){return 0<=o&&o<e&&0<=l&&l<n?t[a*r+o*s+l*i+u]:c}function EB(t,e,n,r,s,i,a,o,l,u,c){return MB(t,e,n,r,s,i,a,Math.round(o),Math.round(l),u,c)}function kB(t,e,n,r,s,i,a,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*MB(t,e,n,r,s,i,a,h,d,u,c)+(l-d)*MB(t,e,n,r,s,i,a,h,f,u,c))+(o-h)*((f-l)*MB(t,e,n,r,s,i,a,p,d,u,c)+(l-d)*MB(t,e,n,r,s,i,a,p,f,u,c))}function IB(t,e,n,r){const s=Zf(e,n)[0],i=[1,n[0],1];for(let t=0;t<s;t++)i[0]*=n[t];i[1]=n[s];for(let t=s+1;t<n.length;t++)i[2]*=n[t];const a={},o=new Int32Array(n[s]),l=new pv(i,r,t),u=[],c=1===i[0]&&1===i[2];for(let e=0;e<n[s];e++){let n;if(c)n=t[e].toString();else{const t=[];for(let n=0;n<i[0];n++)for(let r=0;r<i[2];r++)t.push(l.get(n,e,r));n=t.join(",")}if(void 0!==a[n])o[e]=a[n];else{const t=Object.keys(a).length;a[n]=t,o[e]=t,u.push(e)}}const h=i.slice();h[1]=Object.keys(a).length;const d=new pv(h,r);u.forEach(((t,e)=>{for(let n=0;n<i[0];n++)for(let r=0;r<i[2];r++)d.set(l.get(n,t,r),n,e,r)}));const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const CB={kernelName:_y,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:i}=e,{numSegments:a}=r;_L(s,"unsortedSegmentSum");const o=[],l=[],u=s.shape.length-i.shape.length;let c=i;for(let t=0;t<u;++t){const e=e$({inputs:{input:c},backend:n,attrs:{dim:t+1}});c=e,l.push(e)}for(let t=0;t<a;++t){const e=tv(t,"int32"),r=n.makeTensorInfo([],"int32",e),i=WP({inputs:{a:r,b:c},backend:n}),a=ZL({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),u=FP({inputs:{a,b:s},backend:n}),h=$P({inputs:{x:u},backend:n,attrs:{axis:0,keepDims:!1}});o.push(h),l.push(r),l.push(i),l.push(a),l.push(u),l.push(h)}const h=QO({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),h}},AB=[cF,dF,fF,gF,iF,xF,wF,SF,_F,TF,EF,IF,AF,DF,FF,zF,BF,UF,WF,uF,VF,qF,YF,JF,QL,tP,nP,XL,rP,lP,cP,hP,dP,pP,fP,mP,xP,vP,bP,wP,SP,_P,TP,EP,kP,IP,CP,AP,RP,NP,zP,CL,BP,VP,JP,t$,n$,i$,g$,y$,v$,S$,M$,E$,k$,C$,R$,L$,$$,RL,O$,aP,B$,W$,G$,DL,q$,Y$,Z$,eO,rO,aO,lO,hO,dO,pO,gO,vO,bO,wO,SO,_O,TO,MO,EO,CO,AO,DO,$O,PP,zO,UO,VO,HO,XO,KO,ZO,tz,ez,sz,$L,az,lz,JL,l$,cz,zL,UL,oF,hz,dz,pz,fz,mz,gz,yz,wz,_z,Ez,kz,Rz,HL,Dz,Fz,$z,jF,PO,Bz,Uz,Vz,Hz,qz,Xz,Kz,Yz,Qz,tB,rB,iB,oB,cB,pB,mB,d$,OP,xB,{kernelName:gy,backendName:"cpu",kernelFunc:yB},{kernelName:xy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:i}=r;_L(s,"tile");const a=vB(n.bufferSync(s),i);return n.makeTensorInfo(a.shape,a.dtype,a.values)}},{kernelName:yy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:i,sorted:a}=r;_L(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=SB(o,s.shape,s.dtype,i,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}},_B,bF,{kernelName:wy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:i}=e;_L(i,"unique");const a=r.data.get(i.dataId).values,{outputValues:o,outputShape:l,indices:u}=IB(a,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:Sy,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const a=s.shape.length,o=s.shape[i],l=new Array(a-1);let u=0;for(let t=0;t<a;t++)t!==i&&(l[u++]=s.shape[t]);const c=new Array(a).fill(0),h=s.shape.slice();h[i]=1;const d=new Array(o);for(let t=0;t<d.length;t++){c[i]=t;const e=HF({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});d[t]=aF({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}},CB,JO];for(const t of AB)$y(t);const RB={},NB={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function DB(t,e){if(!(t in RB)||null!=e){const n=function(t,e){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==e?function(t){if("undefined"!=typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t):e;return n.addEventListener("webglcontextlost",(e=>{e.preventDefault(),delete RB[t]}),!1),1===t?n.getContext("webgl",NB)||n.getContext("experimental-webgl",NB):n.getContext("webgl2",NB)}(t,e);if(null===n)return console.log("Could not get context for WebGL version",t),null;RB[t]=n}const n=RB[t];return null==n||n.isContextLost()?(delete RB[t],DB(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),RB[t])}var LB,FB,PB;function $B(t,e){return[e,t]}function OB(t){const e=Hf(t);return Xf(Math.ceil(e/4))}function zB(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function BB(t,e){const n=t;let r,s,i,a,o,l,u,c,h,d;return 2===Sm().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,i=n.RGBA16F,a=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=t.RGBA,s=t.RGBA,i=t.RGBA,a=n.RGBA,o=t.RGBA,u=4,c=4,h=null!=e?e.HALF_FLOAT_OES:null,d=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function UB(t,e){const n=e();return Sm().getBool("DEBUG")&&function(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+function(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(t,e))}(t),n}function WB(t){return!!(Sm().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===t||5.96e-8<Math.abs(t)&&Math.abs(t)<65504)}function VB(t,e){return ZB(t,(()=>t.getExtension(e)),'Extension "'+e+'" not supported on this browser.')}!function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"}(LB||(LB={})),function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"}(FB||(FB={})),function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(PB||(PB={}));const GB=/ERROR: [0-9]+:([0-9]+):/g;function HB(t,e){const n=GB.exec(e);if(null==n)return console.log(`Couldn't parse line number in error: ${e}`),void console.log(t);const r=+n[1],s=t.split("\n"),i=s.length.toString().length+2,a=s.map(((t,e)=>Kf((e+1).toString(),i)+t));let o=0;for(let t=0;t<a.length;t++)o=Math.max(a[t].length,o);const l=a.slice(0,r-1),u=a.slice(r-1,r),c=a.slice(r);console.log(l.join("\n")),console.log(e.split("\n")[0]),console.log(`%c ${Kf(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function jB(t,e){if(UB(t,(()=>t.validateProgram(e))),!1===t.getProgramParameter(e,t.VALIDATE_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function qB(t,e,n,r,s,i,a){const o=t.getAttribLocation(e,n);return-1!==o&&(UB(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,r))),UB(t,(()=>t.vertexAttribPointer(o,s,t.FLOAT,!1,i,a))),UB(t,(()=>t.enableVertexAttribArray(o))),!0)}function XB(t,e,n,r){UB(t,(()=>function(t,e,n){(function(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(t,n),UB(t,(()=>t.activeTexture(t.TEXTURE0+n))),UB(t,(()=>t.bindTexture(t.TEXTURE_2D,e)))}(t,e,r))),UB(t,(()=>t.uniform1i(n,r)))}function KB(t,e,n){UB(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,n))),UB(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0)))}function YB(t,e){UB(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,e))),UB(t,(()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)))}function JB(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(t,e))}function ZB(t,e,n){const r=UB(t,(()=>e()));if(null==r)throw new Error(n);return r}function QB(t,e=2){return Hf(t.slice(0,t.length-e))}function tU(t){if(0===t.length)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function eU(t){let e=[1,1,1];return 0===t.length||1===t.length&&1===t[0]||(e=[QB(t),...tU(t)]),e}function nU(t){return t%2==0}function rU(t,e){if(jf(t=t.slice(-2),e=e.slice(-2)))return!0;if(!t.length||!e.length)return!0;if(0===t[0]||0===t[1]||0===e[0]||0===e[1])return!0;if(t.length!==e.length){const n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r)return!0;if(nU(n)&&nU(r)&&(1===t[0]||1===e[0]))return!0}return t[1]===e[1]&&nU(t[0])&&nU(e[0])}let sU,iU;function aU(t,e){return null!=t.getExtension(e)}function oU(t){try{if(null!=DB(t))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function lU(t){const e=BB(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const s=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(r),s}function uU(t,e){Array.isArray(t)||(t=[t]),t.forEach((t=>{null!=t&&Uf("complex64"!==t.dtype,(()=>`${e} does not support complex64 tensors in the WebGL backend.`))}))}const cU=Sm();function hU(){let t,e,n,r,s,i,a,o,l,u;return 2===Sm().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",r="in",s="texture",i="outputColor",a="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",r="varying",s="texture2D",i="gl_FragColor",a="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:s,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function dU(t,e,n="index"){const r=cm(e);return r.map(((e,s)=>`int ${t[s]} = ${n} / ${e}; ${s===r.length-1?`int ${t[s+1]} = ${n} - ${t[s]} * ${e}`:`index -= ${t[s]} * ${e}`};`)).join("")}function pU(t,e,n="index"){const r=cm(e);return r.map(((e,s)=>`int ${t[s]} = ${n} / outShapeStrides[${s}]; ${s===r.length-1?`int ${t[s+1]} = ${n} - ${t[s]} * outShapeStrides[${s}]`:`index -= ${t[s]} * outShapeStrides[${s}]`};`)).join("")}function fU(t){const e=cm(t).map((t=>t.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}cU.registerFlag("HAS_WEBGL",(()=>cU.getNumber("WEBGL_VERSION")>0)),cU.registerFlag("WEBGL_VERSION",(()=>oU(2)?2:oU(1)?1:0)),cU.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),cU.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===cU.get("WEBGL_VERSION"))),cU.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),cU.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),cU.registerFlag("WEBGL_PACK",(()=>cU.getBool("HAS_WEBGL"))),cU.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>cU.getBool("WEBGL_PACK"))),cU.registerFlag("WEBGL_PACK_CLIP",(()=>cU.getBool("WEBGL_PACK"))),cU.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>cU.getBool("WEBGL_PACK"))),cU.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>cU.getBool("WEBGL_PACK"))),cU.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>cU.getBool("WEBGL_PACK"))),cU.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>cU.getBool("WEBGL_PACK"))),cU.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>cU.getBool("WEBGL_PACK"))),cU.registerFlag("WEBGL_PACK_REDUCE",(()=>cU.getBool("WEBGL_PACK"))),cU.registerFlag("WEBGL_LAZILY_UNPACK",(()=>cU.getBool("WEBGL_PACK"))),cU.registerFlag("WEBGL_CONV_IM2COL",(()=>cU.getBool("WEBGL_PACK"))),cU.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(t){if(null==sU){const e=DB(t);sU=e.getParameter(e.MAX_TEXTURE_SIZE)}return sU}(cU.getNumber("WEBGL_VERSION")))),cU.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(t){if(null==iU){const e=DB(t);iU=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,iU)}(cU.getNumber("WEBGL_VERSION")))),cU.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=cU.getNumber("WEBGL_VERSION");return 0===t?0:function(t){if(0===t)return 0;let e;const n=DB(t);return e=aU(n,"EXT_disjoint_timer_query_webgl2")&&2===t?2:aU(n,"EXT_disjoint_timer_query")?1:0,e}(t)})),cU.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>cU.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ov())),cU.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(t){if(0===t)return!1;const e=DB(t);if(1===t){if(!aU(e,"OES_texture_float"))return!1}else if(!aU(e,"EXT_color_buffer_float"))return!1;return lU(e)}(cU.getNumber("WEBGL_VERSION")))),cU.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!cU.getBool("WEBGL_FORCE_F16_TEXTURES")&&cU.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),cU.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>function(t){if(0===t)return!1;const e=DB(t);if(1!==t){if(aU(e,"EXT_color_buffer_float"))return lU(e);const t="EXT_color_buffer_half_float";if(aU(e,t)){const n=e.getExtension(t);return function(t,e){const n=BB(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(s),i}(e,n)}return!1}return!!aU(e,"OES_texture_float")&&!!aU(e,"WEBGL_color_buffer_float")&&lU(e)}(cU.getNumber("WEBGL_VERSION")))),cU.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(t=cU.getNumber("WEBGL_VERSION"))&&null!=DB(t).fenceSync;var t})),cU.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>cU.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),cU.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)})),cU.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Ov()?1:-1),(t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)})),cU.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),cU.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),cU.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),cU.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));const mU="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:gU}=s;function xU(t,e,n){const r=[];if(t.forEach((t=>{const e=Hf(t.shapeInfo.logicalShape);if(t.shapeInfo.isUniform?r.push(`uniform float ${t.name}${e>1?`[${e}]`:""};`):(r.push(`uniform sampler2D ${t.name};`),r.push(`uniform int offset${t.name};`)),n.enableShapeUniforms){const{uniformShape:e}=kU(n.packedInputs,t.shapeInfo.logicalShape,t.shapeInfo.texShape);switch(e.length){case 1:r.push(`uniform int ${t.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${t.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${t.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${t.name}Shape;`)}r.push(`uniform ivec2 ${t.name}TexShape;`)}})),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((t=>{r.push(`uniform ${t.type} ${t.name}${t.arrayIndex?`[${t.arrayIndex}]`:""};`)}));const s=r.join("\n"),i=t.map((t=>function(t,e,n=!1,r){let s="";s+=n?vU(t,r):yU(t,r);const i=t.shapeInfo.logicalShape,a=e.logicalShape;return i.length<=a.length&&(s+=n?function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",i=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=gU(t.shapeInfo.logicalShape,e.logicalShape),l=EU(a),u=a-i;let c;const h=["x","y","z","w","u","v"];c=0===i?"":a<2&&o.length>=1?"coords = 0;":o.map((t=>`coords.${h[t+u]} = 0;`)).join("\n");let d="";d=a<2&&i>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>`coords.${h[e+u]}`)).join(", ");let p="return outputValue;";const f=1===Hf(t.shapeInfo.logicalShape),m=1===Hf(e.logicalShape);if(1!==i||f||m){if(f&&!m)p=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const t=i-2,e=i-1;o.indexOf(t)>-1&&o.indexOf(e)>-1?p="return vec4(outputValue.x);":o.indexOf(t)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(e)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(t,e):function(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",i=e.texShape,a=t.shapeInfo.texShape,o=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&o===l&&null==t.shapeInfo.flatOffset&&jf(a,i))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=EU(l),c=gU(t.shapeInfo.logicalShape,e.logicalShape),h=l-o;let d;const p=["x","y","z","w","u","v"];d=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((t=>`coords.${p[t+h]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":t.shapeInfo.logicalShape.map(((t,e)=>`coords.${p[e+h]}`)).join(", "),`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(t,e)),s}(t,e,n.packedInputs,n.enableShapeUniforms))).join("\n"),a=e.texShape,o=hU(),l=function(t){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${t.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,h=function(t){return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFs} vec2 resultUV;\n    ${t.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${t.defineSpecialNaN}\n    ${t.defineSpecialInf}\n    ${t.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${bU}\n    ${wU}\n    ${SU}\n  `}(o);return e.isPacked?(u=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,e,n);case 2:return function(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(jf(t,e))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(t[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(t,e,n);case 3:return function(t,e,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[2]/2),i=s*Math.ceil(t[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(t,e,n);default:return function(t,e,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(t[t.length-1]/2),i=s*Math.ceil(t[t.length-2]/2);let a=i,o="",l="b, r, c";for(let e=2;e<t.length-1;e++)a*=t[t.length-e-1],o=`\n      int b${e} = index / ${a};\n      index -= b${e} * ${a};\n    `+o,l=`b${e}, `+l;return`\n    ivec${t.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${t.length}(${l});\n    }\n  `}(t,e,n)}}(e.logicalShape,a,n.enableShapeUniforms),c=function(t){return`\n    void setOutput(vec4 val) {\n      ${t.output} = val;\n    }\n  `}(o)):(u=function(t,e,n){switch(t.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(t,e,n){return 1===e[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${e[1]}.0);\n      }\n    `:1===e[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${e[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return resTexRC.x * ${e[1]} + resTexRC.y;\n    }\n  `}(0,e,n);case 2:return function(t,e,n){return jf(t,e)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===t[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===t[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t[1]};\n      int c = index - r * ${t[1]};\n      return ivec2(r, c);\n    }\n  `}(t,e,n);case 3:return function(t,e,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${pU(["r","c","d"],t)}\n    return ivec3(r, c, d);\n  }\n`;const r=dU(["r","c","d"],t);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(t,e,n);case 4:return function(t,e,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${pU(["r","c","d","d2"],t)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=dU(["r","c","d","d2"],t);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(t,e,n);case 5:return function(t,e){const n=dU(["r","c","d","d2","d3"],t);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\n                             ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(t,e);case 6:return function(t,e){const n=dU(["r","c","d","d2","d3","d4"],t);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}(e.logicalShape,a,n.enableShapeUniforms),c=function(t){return`\n    void setOutput(float val) {\n      ${t.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(h+=_U),[h,l,c,s,u,i,n.userCode].join("\n")}function yU(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,i]=t.shapeInfo.texShape;if(1===s&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const a=TU(n);if(e)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=t.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t,e);case 1:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${MU(t)}\n      }\n    `;const s=t.shapeInfo.texShape,i=s[0],a=s[1];if(1===a&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=TU(n);return 1===a?e?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===i?e?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:e?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${a}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape;if(null!=i&&jf(n,i)){if(e)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const t=i[0];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${t}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:a,keptDims:o}=Qf(n),l=a;if(l.length<n.length){const n=["row","col"];return`\n      ${yU(IU(t,l),e)}\n      float ${s}(int row, int col) {\n        return ${s}(${CU(n,o)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${MU(t)}\n      }\n    `;const u=i[0],c=i[1],h=TU(r);return 1===c?e?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?e?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:e?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[1]*n[2],a=n[2],{newShape:o,keptDims:l}=Qf(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${yU(IU(t,u),e)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${CU(n,l)});\n        }\n      `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${a}, 1)));\n        ${MU(t)}\n      }\n    `;const c=t.shapeInfo.texShape,h=c[0],d=c[1],p=t.shapeInfo.flatOffset;if(d===i&&null==p)return e?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===a&&null==p)return e?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=TU(r);return e?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${i} + col * ${a} + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${a} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(t,e);case 4:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[3],a=n[2]*i,o=n[1]*a,{newShape:l,keptDims:u}=Qf(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${yU(IU(t,l),e)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${CU(n,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${a}, ${i}, 1)));\n        ${MU(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return e?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===i&&null==c)return e?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const x=TU(r);return e?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${x});\n      return sampleTexture(${r}, uv);\n    }\n  `}(t,e);case 5:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[4],i=e[3]*s,a=e[2]*i,o=e[1]*a,{newShape:l,keptDims:u}=Qf(e);if(l.length<e.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${yU(IU(t,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${CU(e,u)});\n      }\n    `}if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${a}, ${i}, ${s})) +\n          depth3;\n        ${MU(t)}\n      }\n    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]},\n               ${e[2]*e[3]}, ${e[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} + depth * ${i} +\n          depth2 * ${s} + depth3 + ${TU(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);case 6:return function(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:i}=Qf(e);if(s.length<e.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${yU(IU(t,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${CU(e,i)});\n      }\n    `}const a=e[5],o=e[4]*a,l=e[3]*o,u=e[2]*l,c=e[1]*u;if(t.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${MU(t)}\n      }\n    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===a&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${e[1]*e[2]*e[3]*e[4]},\n               ${e[2]*e[3]*e[4]},\n               ${e[3]*e[4]},\n               ${e[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${a} + depth4 + ${TU(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function vU(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return function(t){const e=t.name;return`\n    vec4 ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return ${hU().texture2D}(${e}, halfCR);\n    }\n  `}(t);case 1:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t.shapeInfo.texShape,i=hU();if(e)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `;const a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${a[0]}, ${a[1]}, index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(t,e);case 2:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape,a=i[0],o=i[1],l=hU();if(null!=i&&jf(n,i))return e?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(e)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(t,e);case 3:return function(t,e){const n=t.shapeInfo.logicalShape,r=t.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===n[0]){const r=[1,2],i=["b","row","col"];return`\n        ${vU(IU(t,n.slice(1)),e)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${CU(i,r)});\n        }\n      `}const o=hU();if(e)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=a[0],u=a[1],c=Math.ceil(n[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(n[1]/2)}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(t,e);default:return function(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=hU();if(e)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const i=t.shapeInfo.logicalShape,a=i.length,o=t.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],h=Math.ceil(i[a-1]/2);let d=h*Math.ceil(i[a-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let t=2;t<a-1;t++)p=`int b${t}, `+p,d*=i[a-t-1],f=`b${t} * ${d} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(t,e)}}const bU="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",wU="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SU="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",_U="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function TU(t){return`offset${t}`}function MU(t){const e=t.name,n=Hf(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${e}[i];\n      }\n    }\n  `}function EU(t){if(t<=1)return"int";if(2===t)return"ivec2";if(3===t)return"ivec3";if(4===t)return"ivec4";if(5===t)return"ivec5";if(6===t)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function kU(t,e,n){const{newShape:r,keptDims:s}=Qf(e),i=e.length,a=t&&3===i&&1===e[0],o=a?e.slice(1):r,l=!t&&i>1&&!jf(e,n)&&r.length<i||a;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:s}}function IU(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function CU(t,e){return e.map((e=>t[e])).join(", ")}function AU(t,e,n){const r={},s={},i={},a=[];let o,l,u,c=null,h=null;h=t.getUniformLocation(n,"NAN",!1),1===Sm().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(n,"INFINITY",!1));const d=!1;for(let a=0;a<e.variableNames.length;a++){const o=e.variableNames[a];r[o]=t.getUniformLocation(n,o,d),r[`offset${o}`]=t.getUniformLocation(n,`offset${o}`,d),e.enableShapeUniforms&&(s[`${o}Shape`]=t.getUniformLocation(n,`${o}Shape`,d),i[`${o}TexShape`]=t.getUniformLocation(n,`${o}TexShape`,d))}return e.enableShapeUniforms&&(o=t.getUniformLocation(n,"outShape",d),u=t.getUniformLocation(n,"outShapeStrides",d),l=t.getUniformLocation(n,"outTexShape",d)),e.customUniforms&&e.customUniforms.forEach(((e,r)=>{a[r]=t.getUniformLocation(n,e.name,d)})),{uniformLocations:r,customUniformLocations:a,infLoc:c,nanLoc:h,inShapesLocations:s,inTexShapesLocations:i,outShapeLocation:o,outShapeStridesLocation:u,outTexShapeLocation:l}}function RU(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach(((t,n)=>{const r=t.logicalShape,s=e[n],i=s.shape;if(!jf(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(t.isUniform&&s.isUniform)return;const a=t.texShape,o=s.isUniform?null:s.texData.texShape;if(!jf(a,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${o} must match`)}))}function NU(t){return Sm().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}class DU{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=LB.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=hU();this.outputShape=t,this.enableShapeUniforms=NU(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?pU(["r","c","d"],t):dU(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class LU{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=LB.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=hU();this.outputShape=t,this.enableShapeUniforms=NU(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?pU(["r","c","d"],t):dU(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class FU{constructor(t){this.variableNames=["A"],this.outTexUsage=FB.DOWNLOAD;const e=hU();this.outputShape=t,this.userCode=`\n      ${mU}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class PU{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=FB.DOWNLOAD;const e=hU();this.outputShape=t,this.userCode=`\n      ${mU}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class $U{constructor(t,e=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=hU();this.outputShape=t,this.enableShapeUniforms=NU(this.outputShape.length);let r="result";e&&(r="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":fU(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}}class OU{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=hU();this.outputShape=t,this.enableShapeUniforms=NU(this.outputShape.length);let r="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let e=0;e<=1;e++)for(let s=0;s<=1;s++){const i=2*e+s;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${s} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${s};\n          if (localCoords[1] + ${e} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${e};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${i}] = values[0];\n            } else if (offset == 1) {\n              result[${i}] = values[1];\n            } else if (offset == 2) {\n              result[${i}] = values[2];\n            } else {\n              result[${i}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":fU(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}function zU(t,e,n,r,s,i){!function(t,e){const n=Sm().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0)throw new Error(`Requested texture size [${t}x${e}] is invalid.`);if(t>n||e>n)throw new Error(`Requested texture size [${t}x${e}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(e,n);const a=function(t){return ZB(t,(()=>t.createTexture()),"Unable to create WebGLTexture.")}(t),o=t.TEXTURE_2D;return UB(t,(()=>t.bindTexture(o,a))),UB(t,(()=>t.texParameteri(o,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE))),UB(t,(()=>t.texParameteri(o,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE))),UB(t,(()=>t.texParameteri(o,t.TEXTURE_MIN_FILTER,t.NEAREST))),UB(t,(()=>t.texParameteri(o,t.TEXTURE_MAG_FILTER,t.NEAREST))),1===Sm().getNumber("WEBGL_VERSION")?UB(t,(()=>t.texImage2D(o,0,r,e,n,0,s,i,null))):UB(t,(()=>t.texStorage2D(o,1,r,e,n))),UB(t,(()=>t.bindTexture(t.TEXTURE_2D,null))),{texture:a,texShape:[n,e]}}function BU(t){return t.internalFormatFloat}function UU(t){return t.internalFormatHalfFloat}function WU(t){return t.downloadTextureFormat}function VU(t){return t.internalFormatPackedFloat}function GU(t){return t.internalFormatPackedHalfFloat}class HU{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=Sm().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,function(t,e){RB[t]=e}(e,t)):this.gl=DB(e);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Sm().getNumber("WEBGL_VERSION")){const t="OES_texture_float",e="OES_texture_half_float";if(this.textureFloatExtension=VB(this.gl,t),aU(this.gl,e))this.textureHalfFloatExtension=VB(this.gl,e);else if(Sm().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),aU(this.gl,r))this.colorBufferHalfFloatExtension=VB(this.gl,r);else if(Sm().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",aU(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!aU(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(t){return function(t,e){const n=ZB(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return UB(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),UB(t,(()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(t){return function(t,e){const n=ZB(t,(()=>t.createBuffer()),"Unable to create WebGLBuffer");return UB(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n))),UB(t,(()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW))),n}(t,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(t){return ZB(t,(()=>t.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=BB(this.gl,this.textureHalfFloatExtension)}get debug(){return Sm().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;UB(t,(()=>t.finish())),UB(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null))),UB(t,(()=>t.deleteFramebuffer(this.framebuffer))),UB(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null))),UB(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null))),UB(t,(()=>t.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,i]=$B(e,n);return zU(t,s,i,BU(r),r.textureFormatFloat,t.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,i]=$B(e,n);return zU(t,s,i,UU(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,i]=$B(e,n);return zU(t,s,i,WU(r),t.RGBA,t.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function(t,e,n){UB(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),n.data instanceof Uint8Array?2===Sm().getNumber("WEBGL_VERSION")?UB(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data))):UB(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data))):2===Sm().getNumber("WEBGL_VERSION")?UB(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n))):UB(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n))),UB(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,r){this.throwIfDisposed(),function(t,e,n,r,s,i){let a,o,l;UB(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),s instanceof Uint8Array?(a=new Uint8Array(n*r*4),o=t.UNSIGNED_BYTE,l=t.RGBA):(a=new Float32Array(n*r*4),o=t.FLOAT,l=i.internalFormatPackedFloat),a.set(s),2===Sm().getNumber("WEBGL_VERSION")?UB(t,(()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,o,a))):UB(t,(()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,o,a))),UB(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}(this.gl,t,e,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,i]=zB(e,n);return zU(t,s,i,GU(r),t.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function(t,e,n,r){const[s,i]=zB(e,n);return zU(t,s,i,VU(r),t.RGBA,t.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(YB(this.gl,this.framebuffer),this.outputTexture=null),UB(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n,r){const[s,i]=$B(e,n),a=new Uint8Array(e*n*4);return UB(t,(()=>t.readPixels(0,0,s,i,r.downloadTextureFormat,t.UNSIGNED_BYTE,a))),new Float32Array(a.buffer)}(this.gl,e,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,e,n,r,s,i){return function(t,e,n,r,s,i,a,o){const l=t,u=new Float32Array(function(t,e){const[n,r]=zB(t,e);return n*r*4}(i,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return function(t,e,n){const r=t,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const r=function(t,e,n,r){const s=t.createBuffer();UB(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,s)));const i=16*e*n;return UB(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,i,t.STREAM_READ))),UB(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0))),UB(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null))),s}(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(Sm().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=r.clientWaitSync(s,0,0);return t===r.ALREADY_SIGNALED||t===r.CONDITION_SATISFIED},e=s}else Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>function(t,e,n){const r=new Float32Array(e*n*4);return UB(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r))),r}(this.gl,e,n)))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function(t){const e=hU();return function(t,e){const n=ZB(t,(()=>t.createShader(t.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(UB(t,(()=>t.shaderSource(n,e))),UB(t,(()=>t.compileShader(n))),!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(t,`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const n=function(t){return ZB(t,(()=>t.createProgram()),"Unable to create WebGLProgram.")}(e);return UB(e,(()=>e.attachShader(n,this.vertexShader))),UB(e,(()=>e.attachShader(n,t))),function(t,e){if(UB(t,(()=>t.linkProgram(e))),!Sm().get("ENGINE_COMPILE_ONLY")&&!1===t.getProgramParameter(e,t.LINK_STATUS))throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}(e,n),this.debug&&jB(e,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=function(t,e,n){return UB(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n))),qB(t,e,"clipSpacePos",n,3,20,0)&&qB(t,e,"uv",n,2,20,12)}(e,this.program,this.vertexBuffer)),n}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&UB(this.gl,(()=>this.gl.deleteProgram(t)))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&jB(this.gl,this.program),UB(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?function(t,e,n){return ZB(t,(()=>t.getUniformLocation(e,n)),'uniform "'+n+'" not present in program.')}(this.gl,t,e):function(t,e,n){return t.getUniformLocation(e,n)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),UB(this.gl,(()=>this.gl.getAttribLocation(t,e)))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),XB(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[r,s]=zB(e,n);this.setOutputMatrixTextureDriver(t,r,s)}setOutputMatrixWriteRegion(t,e,n,r){this.setOutputMatrixWriteRegionDriver(n,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&jB(this.gl,this.program),JB(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),UB(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),UB(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=VB(this.gl,2===Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await Yf((()=>this.disposed||this.isQueryAvailable(t,Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(t,Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=function(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||Yf((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),KB(this.gl,t,this.framebuffer),this.debug&&JB(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(KB(this.gl,this.outputTexture,this.framebuffer),this.debug&&JB(this.gl)):YB(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const r=this.gl;KB(r,t,this.framebuffer),this.debug&&JB(r),this.outputTexture=t,UB(r,(()=>r.viewport(0,0,e,n))),UB(r,(()=>r.scissor(0,0,e,n)))}setOutputMatrixWriteRegionDriver(t,e,n,r){this.throwIfDisposed(),UB(this.gl,(()=>this.gl.scissor(t,e,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:jU,bincountImpl:qU,bincountReduceImpl:XU,ceilImpl:KU,concatImpl:YU,equalImpl:JU,expImpl:ZU,expm1Impl:QU,floorImpl:tW,gatherNdImpl:eW,gatherV2Impl:nW,greaterImpl:rW,greaterEqualImpl:sW,lessImpl:iW,lessEqualImpl:aW,linSpaceImpl:oW,logImpl:lW,maxImpl:uW,maximumImpl:cW,minimumImpl:hW,multiplyImpl:dW,negImpl:pW,notEqualImpl:fW,prodImpl:mW,rangeImpl:gW,rsqrtImpl:xW,scatterImpl:yW,sigmoidImpl:vW,simpleAbsImpl:bW,sliceImpl:wW,sparseFillEmptyRowsImpl:SW,sparseReshapeImpl:_W,sparseSegmentReductionImpl:TW,sqrtImpl:MW,stridedSliceImpl:EW,stringNGramsImpl:kW,stringSplitImpl:IW,stringToHashBucketFastImpl:CW,subImpl:AW,tileImpl:RW,topKImpl:NW,transposeImpl:DW,uniqueImpl:LW}=i;function FW(t,e){return["x","y","z","w","u","v"].slice(0,e).map((e=>`${t}.${e}`))}function PW(t,e){return 1===e?[t]:FW(t,e)}class $W{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=NU(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const t=PW("rc",this.rank),e=EU(this.rank),n=this.getOutOfBoundsCondition(t),r=this.getSetup(t),s=this.getOutput(t);this.userCode=`\n        void main() {\n          ${e} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let e=2;e<this.rank;e++)s=`${t[t.length-1-e]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class OW{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=NU(this.outputShape.length);let n="";for(let t=0;t<4;t++){let e="thisRC = rc;";t%2==1&&(e+="thisRC.z += 1;"),t>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${t>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${t}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${t>0?"}":""}\n      `}var r,s;this.userCode=`\n      ${r=e,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?function(t,e,n="index"){const r=function(t,e){const n=t.length,r=t.map((t=>`${e}[${t}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let t=n-3;t>=0;--t)s[t]=`(${s[t+1]} * ${r[t+1]})`;return s}(t.map(((t,e)=>e)),e);return r.map(((e,s)=>`int ${t[s]} = ${n} / ${r[s]}; ${s===r.length-1?`int ${t[s+1]} = ${n} - ${t[s]} * ${r[s]}`:`index -= ${t[s]} * ${r[s]}`};`)).join("")}(["r","c","d"],"inputShape"):dU(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":fU(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class zW{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){const r=UW(e,n),s=WW(t,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const i=BW(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const t=this.freeTextures[s].shift();return this.usedTextures[s].push(t),t}let a;return r===PB.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===PB.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===PB.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===PB.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===PB.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,n,r){if(null==this.freeTextures)return;const s=UW(n,r),i=WW(e,s,r);i in this.freeTextures||(this.freeTextures[i]=[]);const a=BW(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=Sm().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[i],u=l.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));for(const t in this.usedTextures)this.usedTextures[t].forEach((t=>{this.gpgpu.deleteMatrixTexture(t.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function BW(t,e,n,r,s){const i=function(t,e){switch(t){case PB.PACKED_2X2_FLOAT32:return VU(e);case PB.PACKED_2X2_FLOAT16:return GU(e);case PB.UNPACKED_FLOAT32:return BU(e);case PB.UNPACKED_FLOAT16:return UU(e);case PB.PACKED_4X1_UNSIGNED_BYTE:return WU(e);default:throw new Error(`Unknown physical texture type ${t}`)}}(e,r);let a;if(s){const[e,n]=zB(t[0],t[1]);a=e*n}else{const[e,n]=$B(t[0],t[1]);a=e*n}const o=function(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}(n,i);return a*o}function UW(t,e){if(t===FB.UPLOAD)return PB.PACKED_2X2_FLOAT32;if(t===FB.RENDER||null==t)return function(t){return Sm().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?PB.PACKED_2X2_FLOAT32:PB.UNPACKED_FLOAT32:t?PB.PACKED_2X2_FLOAT16:PB.UNPACKED_FLOAT16}(e);if(t===FB.DOWNLOAD||t===FB.PIXELS)return PB.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function WW(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}class VW{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=NU(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const GW="return abs(x);",HW="return x;";class jW{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=NU(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class qW{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=NU(this.outputShape.length);const e=t.length,n=PW("rc",e),r=EU(e),s=function(t,e){if(1===t)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}(e,n),i=n.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const XW=VM,KW={},YW=Sm().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class JW extends Ff{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Sm().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(null!=t){if(t instanceof HU)e=t;else{const n=DB(Sm().getNumber("WEBGL_VERSION"),t);e=new HU(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const t=DB(Sm().getNumber("WEBGL_VERSION"));e=new HU(t),this.binaryCache=((n=Sm().getNumber("WEBGL_VERSION"))in KW||(KW[n]={}),KW[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new zW(this.gpgpu),this.numMBBeforeWarning=null==Sm().global.screen?1024:Sm().global.screen.height*Sm().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Lf(this,ow())}nextDataId(){return JW.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,n){if((Sm().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Sm().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:e,dtype:n,values:t,usage:FB.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){this.texData.get(t).refCount++}decRef(t){this.texData.has(t)&&this.texData.get(t).refCount--}move(t,e,n,r,s){if(Sm().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:e,usage:FB.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:s,slice:i,shape:a,isPacked:o}=e;if(null!=i){let e;e=o?new jW(a,HW):new VW(a,HW);const n=this.runWebGLProgram(e,[{dataId:t,shape:a,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;return l&&(u=nv()),c="complex64"===r?cM(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.getValuesFromTexture(t),l&&(this.downloadWaitMs+=nv()-u),this.convertAndCacheOnCPU(t,c)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise((t=>e.push(t)))}const e=this.texData.get(t),{values:n,shape:r,slice:s,dtype:i,complexTensorInfos:a,isPacked:o}=e;if(null!=s){let e;e=o?new jW(r,HW):new VW(r,HW);const n=this.runWebGLProgram(e,[{dataId:t,shape:r,dtype:i}],i),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(t);if(Sm().getBool("DEBUG")&&!Sm().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Sm().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==i&&Sm().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(t);const e=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(e.texture.texture,...OB(r))}if(this.pendingRead.set(t,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){const t=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]);u=cM(t[0],t[1])}else if(null==c)u=this.getValuesFromTexture(t);else{const t=Hf(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,t)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const t=this.gpgpu.gl;UB(t,(()=>t.deleteBuffer(c)))}const h=this.convertAndCacheOnCPU(t,u),d=this.pendingRead.get(t);return this.pendingRead.delete(t),d.forEach((t=>t(h))),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&ow().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t,e={}){const n=this.texData.get(t),{values:r,shape:s,slice:i,dtype:a,isPacked:o,texture:l}=n;if("complex64"===a)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=i){let n;n=o?new jW(s,HW):new VW(s,HW);const r=this.runWebGLProgram(n,[{dataId:t,shape:s,dtype:a}],a),i=this.readToGPU(r,e);return this.disposeIntermediateTensorInfo(r),i}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(t,e.customTexShape),c=ow().makeTensorFromTensorInfo(u),h=this.texData.get(u.dataId);return Object.assign({tensorRef:c},h.texture)}bufferSync(t){const e=this.readSync(t.dataId);if("string"===t.dtype)try{const n=e.map((t=>sv(t)));return Ib(t.shape,t.dtype,n)}catch(t){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ib(t.shape,t.dtype,e)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!WB(n)){if(Sm().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),s=Hf(e);if(Sm().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),r=this.texData.get(n.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...OB(e)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),i}const i=Sm().getBool("WEBGL_PACK")&&!0===r,a=i?eU(e):e,o=i?new PU(a):new FU(a),l=this.runWebGLProgram(o,[{shape:a,dtype:n,dataId:t}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();const s=Gf(this.activeTimers.map((t=>t.query))).filter((t=>null!=t)),i=Gf(this.activeTimers.map((t=>t.name))).filter((t=>null!=t));this.activeTimers=e,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(s);a.kernelMs=function(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}(t),a.getExtraProfileInfo=()=>t.map(((t,e)=>({name:i[e],ms:t}))).map((t=>`${t.name}: ${t.ms}`)).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:nv(),endMs:null}}endTimer(t){return Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=nv(),t)}async getQueryTime(t){if(Sm().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:r,usage:s,isPacked:i,slice:a}=this.texData.get(t),o=a&&a.origDataId||t,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=e&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(e,r,s,i)));const u=this.texData.get(t);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=YW){return Sm().getBool("WEBGL_CPU_FORWARD")&&t.every((t=>null==this.texData.get(t.dataId).texture&&Hf(t.shape)<e))}getGPGPUContext(){return this.gpgpu}where(t){Ay("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return XW(t.shape,e)}packedUnaryOp(t,e,n){const r=new jW(t.shape,e),s=this.compileAndRun(r,[t],n);return ow().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=bW(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if(Sm().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,GW,t.dtype);const e=new VW(t.shape,GW),n=this.compileAndRun(e,[t]);return ow().makeTensorFromTensorInfo(n)}makeTensorInfo(t,e,n){let r;if("string"===e&&null!=n&&n.length>0&&im(n[0])){const s=n.map((t=>rv(t)));r=this.write(s,t,e)}else r=this.write(n,t,e);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:e}}makeOutput(t,e,n){return ow().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,n),this)}unpackTensor(t){const e=new qW(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new $W(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[QB(t.shape),...tU(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},s=[QB(e),...tU(e)],i=new OW(s,n),a=[n],o=this.runWebGLProgram(i,[r],t.dtype,a,!0);return{dataId:o.dataId,shape:e,dtype:o.dtype}}decode(t,e){const n=this.texData.get(t),{isPacked:r,shape:s,dtype:i}=n;null!=e&&Uf(Hf(s)<=e[0]*e[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."));const a=eU(s);let o;o=r?new LU(a):new DU(a);const l=[null!=e?e:OB(a)];return{dtype:i,shape:s,dataId:this.runWebGLProgram(o,[{shape:a,dtype:i,dataId:t}],i,l,!0,e).dataId}}runWebGLProgram(t,e,n,r,s=!1,i){const a=this.makeTensorInfo(t.outputShape,n),o=this.texData.get(a.dataId);if(t.packedOutput&&(o.isPacked=!0),t.outPackingScheme===LB.DENSE){const e=null!=i?i:OB(t.outputShape);o.texShape=e.map((t=>2*t))}if(null!=t.outTexUsage&&(o.usage=t.outTexUsage),0===Hf(a.shape))return o.values=tm(a.dtype,0),a;const l=[],u=e.map((e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&Hf(e.shape)<=Sm().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}if(this.uploadToGPU(e.dataId),!!n.isPacked!=!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),l.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!rU(n.shape,e.shape)){const t=e,r=e.shape;e.shape=n.shape,e=this.packedReshape(e,r),l.push(e),n=this.texData.get(e.dataId),t.shape=r}return{shape:e.shape,texData:n,isUniform:!1}}));this.uploadToGPU(a.dataId);const c={shape:a.shape,texData:o,isUniform:!1},h=function(t,e,n){let r="";e.concat(n).forEach((e=>{const s=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!e.isUniform){const i=e.texData.texShape,{useSqueezeShape:a,uniformShape:o,keptDims:l}=kU(t.packedInputs,e.shape,i);let u="",c="",h="";if(1===o.length&&t.packedInputs){const t=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];u=`${t[0]>1}_${t[1]>1}`}else if(2!==o.length||t.packedInputs){if(o.length>2&&!t.packedInputs){const t=cm(o);h=`${t[0]===i[1]}_${t[t.length-1]===i[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const d=e.shape.length,p=2===o.length&&jf(e.shape,i),f=1===Hf(e.shape),m=Ob(e.shape,n.shape),g=!t.packedInputs&&d===n.shape.length&&jf(i,n.texData.texShape),x=t.packedInputs||o.length>2?"":`${i[0]>1}_${i[1]>1}`;r+=`${d}_${g}_${a?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${h}_${x}_${s}`}else{const t=e.isUniform?"uniform":e.texData.texShape;r+=`${e.shape}_${t}_${s}`}}));const s=t.userCode;let i=t.constructor.name;return i+="_"+r+"_"+s+`${Sm().getNumber("WEBGL_VERSION")}`,i}(t,u,c),d=this.getAndSaveBinary(h,(()=>function(t,e,n,r){const s=n.map(((t,n)=>{const r={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(r.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:r}})),i=s.map((t=>t.shapeInfo)),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=xU(s,a,e),l=function(t,e){const n=ZB(t,(()=>t.createShader(t.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(UB(t,(()=>t.shaderSource(n,e))),UB(t,(()=>t.compileShader(n))),Sm().get("ENGINE_COMPILE_ONLY"))return n;if(!1===t.getShaderParameter(n,t.COMPILE_STATUS))throw HB(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t.gl,o),u=t.createProgram(l);return Sm().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:i,outShapeInfo:a,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:i,outShapeInfo:a},AU(t,e,u))}(this.gpgpu,t,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),Sm().get("ENGINE_COMPILE_ONLY")||function(t,e,n,r,s){e.program.enableShapeUniforms||(RU(e.inShapeInfos,n),RU([e.outShapeInfo],[r]));const i=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(i.texture,a[0],a[1]):t.setOutputMatrixTexture(i.texture,a[0],a[1]),t.setProgram(e.webGLProgram),1===Sm().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach(((n,r)=>{const s=e.program.variableNames[r],i=e.uniformLocations[s],a=e.uniformLocations[`offset${s}`],o=e.inShapesLocations[`${s}Shape`],l=e.inTexShapesLocations[`${s}TexShape`];if(o){const{uniformShape:r}=kU(e.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:t.gl.uniform1iv(o,new Int32Array(r));break;case 2:t.gl.uniform2iv(o,new Int32Array(r));break;case 3:t.gl.uniform3iv(o,new Int32Array(r));break;case 4:t.gl.uniform4iv(o,new Int32Array(r))}}if(l&&t.gl.uniform2i(l,n.texData.texShape[0],n.texData.texShape[1]),null!=i)if(n.isUniform)if(Hf(n.shape)<2)t.gl.uniform1f(i,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(i,e)}else null!=n.texData.slice&&null!=a&&t.gl.uniform1i(a,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture.texture,i,r)}));const o=e.outShapeLocation;if(o)switch(r.shape.length){case 1:t.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(o,new Int32Array(r.shape))}if(e.outShapeStridesLocation){const n=cm(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(n));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(n));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(n))}}e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s&&e.program.customUniforms.forEach(((n,r)=>{const i=e.customUniformLocations[r],a=s[r];if("float"===n.type)t.gl.uniform1fv(i,a);else if("vec2"===n.type)t.gl.uniform2fv(i,a);else if("vec3"===n.type)t.gl.uniform3fv(i,a);else if("vec4"===n.type)t.gl.uniform4fv(i,a);else if("int"===n.type)t.gl.uniform1iv(i,a);else if("ivec2"===n.type)t.gl.uniform2iv(i,a);else if("ivec3"===n.type)t.gl.uniform3iv(i,a);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);t.gl.uniform4iv(i,a)}})),t.executeProgram()}(this.gpgpu,d,u,c,r),l.forEach((t=>this.disposeIntermediateTensorInfo(t))),p&&(f=this.endTimer(f),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(f)}));const m=Sm().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const t=nv();t-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!Sm().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const t=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),t}return a}compileAndRun(t,e,n,r,s=!1){return n=n||e[0].dtype,this.runWebGLProgram(t,e,n,r,s)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Sm().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=uw((()=>{if(!Sm().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=Sm().getBool("DEBUG");Sm().set("DEBUG",!1);const e=this.abs(mw(1e-8)).dataSync()[0];if(Sm().set("DEBUG",t),e>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:s,texture:i,usage:a,isPacked:o}=e;if(null!=i)return;const l=null!=this.activeTimers;let u;l&&(u=nv());let c=e.texShape;if(null==c&&(c=function(t,e=!1){let n=Sm().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e&&(n*=2,1===(t=t.map(((e,n)=>n>=t.length-2?zf(t[n]):t[n]))).length&&(t=[2,t[0]])),2!==t.length){const e=Qf(t);t=e.newShape}let r=Hf(t);if(t.length<=1&&r<=n)return[1,r];if(2===t.length&&t[0]<=n&&t[1]<=n)return t;if(3===t.length&&t[0]*t[1]<=n&&t[2]<=n)return[t[0]*t[1],t[2]];if(3===t.length&&t[0]<=n&&t[1]*t[2]<=n)return[t[0],t[1]*t[2]];if(4===t.length&&t[0]*t[1]*t[2]<=n&&t[3]<=n)return[t[0]*t[1]*t[2],t[3]];if(4===t.length&&t[0]<=n&&t[1]*t[2]*t[3]<=n)return[t[0],t[1]*t[2]*t[3]];if(e){const e=QB(t);let n=2,s=2;return t.length&&([n,s]=tU(t)),r=e*(n/2)*(s/2),Xf(r).map((t=>2*t))}return Xf(r)}(n,o),e.texShape=c),null!=s){const t=eU(n);let i,a=c[1],h=c[0];const d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&d||([a,h]=zB(c[0],c[1])),i=o?new OU(t,d):new $U(t,d);const p=d?[h,a]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=d?FB.PIXELS:FB.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),a,h,s);const g=[[h,a]],x=!0,y=this.runWebGLProgram(i,[f],r,g,x),v=this.texData.get(y.dataId);e.texShape=v.texShape,e.isPacked=v.isPacked,e.usage=v.usage,Sm().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(e.texture=v.texture,e.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=nv()-u)}else{const t=this.acquireTexture(c,a,r,o);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:r}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}(e,r)),n.values}acquireTexture(t,e,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const t=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${t} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,r)}computeBytes(t,e){return t[0]*t[1]*sm(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}for(const[,e]of Object.entries(this.binaryCache)){const n=new Promise((t=>{try{this.checkCompletion_(e),t(!0)}catch(t){throw t}}));t.push(n)}return Promise.all(t)}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await UT(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(!1===this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw HB(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,t]of Object.entries(this.binaryCache)){const{uniformLocations:e,customUniformLocations:n,infLoc:r,nanLoc:s,inShapesLocations:i,inTexShapesLocations:a,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:u}=AU(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=e,t.customUniformLocations=n,t.infLoc=r,t.nanLoc=s,t.inShapesLocations=i,t.inTexShapesLocations=a,t.outShapeLocation=o,t.outShapeStridesLocation=l,t.outTexShapeLocation=u}}}JW.nextDataId=0,zv()&&dw("webgl",(()=>new JW),2);class ZW{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=Bb(e,n),this.enableShapeUniforms=NU(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class QW{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Bb(e,n);const s=this.outputShape.length;this.enableShapeUniforms=NU(s);let i="";if(r)if(0===s||1===Hf(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${EU(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?i+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=PW("coords",s);this.enableShapeUniforms?i+=`\n            bool nextRowOutOfBounds =\n              (${t[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${t[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:i+=`\n            bool nextRowOutOfBounds =\n              (${t[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${t[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function tV(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const eV={kernelName:Bg,backendName:"webgl",kernelFunc:tV};function nV(t){const{inputs:e,backend:n}=t,{real:r,imag:s}=e,i=n.makeTensorInfo(r.shape,"complex64"),a=n.texData.get(i.dataId),o=tV({inputs:{x:r},backend:n}),l=tV({inputs:{x:s},backend:n});return a.complexTensorInfos={real:o,imag:l},i}const rV={kernelName:Zm,backendName:"webgl",kernelFunc:nV},sV="return (a < 0.) ? b * a : a;",iV="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",aV={kernelName:jg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{alpha:i}=r,a=n.makeTensorInfo([],"float32",tv(i,"float32")),o=Sm().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new QW(iV,s.shape,a.shape):new ZW(sV,s.shape,a.shape),l=n.runWebGLProgram(o,[s,a],"float32");return n.disposeIntermediateTensorInfo(a),l}},oV="return (a < 0.) ? b * a : a;",lV="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",uV={kernelName:kx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r,alpha:s}=e,i=Sm().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new QW(lV,r.shape,s.shape):new ZW(oV,r.shape,s.shape);return n.runWebGLProgram(i,[r,s],"float32")}};function cV({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:i})=>{const{x:a}=s,o=i,l=r||a.dtype;if(o.shouldExecuteOnCPU([a])&&null!=n){const t=o.texData.get(a.dataId),e=n(t.values,l);return o.makeTensorInfo(a.shape,l,e)}let u;return u=Sm().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=e?new jW(a.shape,e):new VW(a.shape,t),o.runWebGLProgram(u,[a],l)}}function hV({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:a,backend:o})=>{const{a:l,b:u}=a,c=o;if(r&&"complex64"===l.dtype){const e=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[r,s]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,s={dataId:n.dataId,dtype:n.dtype,shape:l.shape},i={dataId:r.dataId,dtype:r.dtype,shape:u.shape},a=new ZW(t,l.shape,u.shape);return c.runWebGLProgram(a,[s,i],Ev(n.dtype,r.dtype))})),i=nV({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),i}const h=i||Ev(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=s){const t=c.texData.get(l.dataId).values,e=c.texData.get(u.dataId).values,n="string"===l.dtype?UM(t):t,r="string"===l.dtype?UM(e):e,[i,a]=s(l.shape,u.shape,n,r,h),o=c.makeTensorInfo(a,h);return c.texData.get(o.dataId).values=i,o}let d;return d=Sm().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=e?new QW(e,l.shape,u.shape,n):new ZW(t,l.shape,u.shape),c.runWebGLProgram(d,[l,u],h)}}function dV(t,e=!1){if("linear"===t)return"return x;";if("relu"===t)return e?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===t)return e?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===t)return e?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===t)return e?lV:oV;if("leakyrelu"===t)return e?iV:sV;if("sigmoid"===t)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}class pV{constructor(t,e,n,r=!1,s=!1,i=!1,a=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=NU(this.outputShape.length);const u=r?t[1]:t[2],c=Math.ceil(u/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";a&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,g="result = activation(result);");const x=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";t[0]<e[0]?y=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(v=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${y};\n          int batchB = ${v};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${x}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}class fV{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Bb(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const mV="return a * b;";function gV(t){const{inputs:e,backend:n}=t,{a:r,b:s}=e,i=Ev(r.dtype,s.dtype);if("complex64"===r.dtype){const t=n.texData.get(r.dataId),e=n.texData.get(s.dataId),i=new fV("return areal * breal - aimag * bimag;",r.shape,s.shape),a=new fV("return areal * bimag + aimag * breal;",r.shape,s.shape),o=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:s.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:s.shape}],l=n.runWebGLProgram(i,o,"float32"),u=n.runWebGLProgram(a,o,"float32"),c=nV({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,s])){const t=n.texData.get(r.dataId),e=n.texData.get(s.dataId),[a,o]=dW(r.shape,s.shape,t.values,e.values,i),l=n.makeTensorInfo(o,i);return n.texData.get(l.dataId).values=a,l}let a;return a=Sm().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new QW(mV,r.shape,s.shape):new ZW(mV,r.shape,s.shape),n.runWebGLProgram(a,[r,s],i)}const xV={kernelName:gx,backendName:"webgl",kernelFunc:gV};function yV(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{shape:i}=r,a=n,o=Hf(s.shape),l=Jf(i,o),u=Hf(l);Uf(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=a.texData.get(s.dataId);return!c.isPacked||rU(s.shape,l)||null!==c.texture&&rU(c.shape,l)?(a.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function(t,e,n){const r=[QB(t.shape),...tU(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},i=[QB(e),...tU(e)],a=new OW(i,r),o=[r],l=n.runWebGLProgram(a,[s],t.dtype,o,!0);return{dataId:l.dataId,shape:e,dtype:l.dtype}}(s,l,a)}const vV={kernelName:Dx,backendName:"webgl",kernelFunc:yV};class bV{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:i}=t;this.outputShape=[r,i];const a=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=e){const t=1/e;l=`sumValue += dot(values * ${qf(t)?t.toPrecision(2):t}, ones);`}let u="";s%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class wV{constructor(t,e){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:i}=t;this.outputShape=[r,i];let a="0.0",o="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",o="min"):"max"===e&&(a="-1.0 / 1e-20",o="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?l="sumValue":"prod"===e?l="prodValue":"all"===e?l="allValue":"any"===e&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function SV(t,e,n,r){const s=function(t){const e=[];for(;0===e.length||1!==e[e.length-1].outSize;){const n=e.length?e[e.length-1].outSize:t[1],r=HT(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}(t.shape);let i=t;for(let a=0;a<s.length;a++){const{inSize:o,windowSize:l,outSize:u}=s[a];let c,h;c="mean"===n?0===a?new bV({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},o):new bV({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u}):new wV({windowSize:l,inSize:o,batchSize:t.shape[0],outSize:u},n),h=i,i=r.runWebGLProgram(c,[i],e),h.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(h)}return i}class _V{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[e[r]];this.outputShape=n,this.rank=n.length;const r=EU(this.rank),s=function(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let e=0;e<t.length;e++)r[t[e]]=n[e];return r.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class TV{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[e[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=EU(this.rank),s=FW("rc",this.rank),i=new Array(this.rank);for(let t=0;t<e.length;t++)i[e[t]]=s[t];const a=`vec2(${i.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function MV(t,e,n){const r=Sm().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TV(t.shape,e):new _V(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}function EV(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r;return function(t,e,n,r){const s=e,i=t.shape.length,a=Zf(s,t.shape);let o=a;const l=PS(o,i),u=null!=l;let c=t;u&&(c=MV(t,l,r),o=OS(o.length,i)),FS("sum",o,i);const[h,d]=DS(c.shape,o);let p=h;n&&(p=LS(h,a));const f=Hf(d),m=yV({inputs:{x:c},attrs:{shape:[Hf(t.shape)/f,f]},backend:r}),g=SV(m,kv(t.dtype),"sum",r),x=yV({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),x}(s,i,a,n)}const kV={kernelName:Qx,backendName:"webgl",kernelFunc:EV};function IV(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{perm:i}=r,a=n,o=s.shape.length,l=new Array(o);for(let t=0;t<l.length;t++)l[t]=s.shape[i[t]];let u;if(a.shouldExecuteOnCPU([s])){const t=a.texData.get(s.dataId).values,e=DW(t,s.shape,s.dtype,i,l);u=a.makeTensorInfo(l,s.dtype),a.texData.get(u.dataId).values=e}else u=MV(s,i,a);return u}const CV={kernelName:by,backendName:"webgl",kernelFunc:IV};function AV({a:t,b:e,transposeA:n,transposeB:r,backend:s,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const u=t.shape.length,c=e.shape.length,h=n?t.shape[u-2]:t.shape[u-1],d=r?e.shape[c-1]:e.shape[c-2],p=n?t.shape[u-1]:t.shape[u-2],f=r?e.shape[c-2]:e.shape[c-1],m=t.shape.slice(0,-2),g=e.shape.slice(0,-2),x=Hf(m),y=Hf(g),v=Bb(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);Uf(h===d,(()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`));const b=n?[x,h,p]:[x,p,h],w=r?[y,f,d]:[y,d,f],S=yV({inputs:{x:t},backend:s,attrs:{shape:b}}),_=yV({inputs:{x:e},backend:s,attrs:{shape:w}}),T=[S,_],M=Math.max(x,y),E=n?S.shape[1]:S.shape[2],k=null!=i,I=null!=a,C="leakyrelu"===l,A=null!=l?dV(l,!0):null;let R;if((1===p||1===f)&&E>1e3&&!1===(k||I||C||null!=A)){let t=S,e=_;n&&(t=IV({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),T.push(t)),r&&(e=IV({inputs:{x:_},backend:s,attrs:{perm:[0,2,1]}}),T.push(e));const i=1===f;let a=t;1!==f&&(a=yV({inputs:{x:t},backend:s,attrs:{shape:[M,E,1]}}),T.push(a));const o=1===f?2:1;let l=e;i&&(l=yV({inputs:{x:e},backend:s,attrs:{shape:[M,1,E]}}),T.push(l));const u=gV({inputs:{a,b:l},backend:s});R=EV({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),T.push(u)}else{const l=Ev(t.dtype,e.dtype),u=new pV(b,w,[M,p,f],n,r,k,A,I,C),c=[S,_];if(null!=i&&c.push(i),I&&c.push(a),C){const t=s.makeTensorInfo([],"float32",tv(o,"float32"));c.push(t),T.push(t)}R=s.runWebGLProgram(u,c,l)}const N=yV({inputs:{x:R},backend:s,attrs:{shape:v}});T.push(R);for(const t of T)s.disposeIntermediateTensorInfo(t);return N}const RV={kernelName:ky,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:i,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;return AV({a:s,b:i,transposeA:l,transposeB:u,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},NV="return abs(x);",DV={kernelName:km,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const t=n.texData.get(r.dataId),e=bW(t.values);return n.makeTensorInfo(r.shape,r.dtype,e)}let s;return s=Sm().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new jW(r.shape,NV):new VW(r.shape,NV),n.runWebGLProgram(s,[r],r.dtype)}},LV=cV({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),FV={kernelName:Im,backendName:"webgl",kernelFunc:LV},PV=cV({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),$V={kernelName:Cm,backendName:"webgl",kernelFunc:PV},OV="return a + b;",zV=hV({opSnippet:OV,packedOpSnippet:OV,supportsComplex:!0,cpuKernelImpl:jU}),BV={kernelName:Am,backendName:"webgl",kernelFunc:zV};class UV{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(((t,e)=>`T${e}`));const n=[];this.variableNames.forEach((t=>{n.push(`float v${t} = get${t}AtOutCoords();`)}));const r=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class WV{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map(((t,e)=>`T${e}`));const n=[];this.variableNames.forEach((t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)}));const r=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const VV={kernelName:Rm,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r}=e,s=n;if(1===s.length)return tV({inputs:{x:s[0]},backend:r});if(s.length>Sm().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(s.length/2),n=t({inputs:s.slice(0,e),backend:r}),i=t({inputs:s.slice(e),backend:r});return t({inputs:[n,i],backend:r})}const i=s.map((t=>t.dtype)).reduce(((t,e)=>Ev(t,e))),a=s.map((t=>t.shape)),o=Sm().getBool("WEBGL_PACK")?new WV(s[0].shape,a):new UV(s[0].shape,a);return r.runWebGLProgram(o,s,i)}},GV={kernelName:Nm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r,o=s.shape.length,l=Zf(i,s.shape);let u=l;const c=PS(u,o);let h=s;null!=c&&(h=IV({inputs:{x:s},backend:n,attrs:{perm:c}}),u=OS(u.length,o)),FS("all",u,o);const[d,p]=DS(h.shape,u),f=yV({inputs:{x:h},backend:n,attrs:{shape:[-1,Hf(p)]}}),m=SV(f,f.dtype,"all",n);let g;return g=yV(a?{inputs:{x:m},backend:n,attrs:{shape:LS(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},HV={kernelName:Dm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r,o=s.shape.length,l=Zf(i,s.shape);let u=l;const c=PS(u,o);let h=s;null!=c&&(h=IV({inputs:{x:s},backend:n,attrs:{perm:c}}),u=OS(u.length,o)),FS("any",u,o);const[d,p]=DS(h.shape,u),f=yV({inputs:{x:h},backend:n,attrs:{shape:[-1,Hf(p)]}}),m=SV(f,f.dtype,"any",n);let g;return g=yV(a?{inputs:{x:m},backend:n,attrs:{shape:LS(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class jV{constructor(t,e,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];const a="max"===e?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${a} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class qV{constructor(t,e,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Uf(t.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=t[t.length-1],i=Math.ceil(s/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,o=a.length,l=EU(o),u=PW("coords",o);let c,h;if(1===i){h=o+1;const t=EU(h);c=`\n        ${t} sourceLocR = ${t}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${t} sourceLocG = ${t}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${t} sourceLocA = ${t}(${u.join()}, 0);\n        --${u[o-1]};\n        ${t} sourceLocB = ${t}(${u.join()}, 0);\n        --${u[o-2]};`}else h=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((t=>"int "+t)),m=PW("sourceLocR",h-1).concat("inIdx.r"),g=PW("sourceLocG",h-1).concat("inIdx.g"),x=PW("sourceLocB",h-1).concat("inIdx.b"),y=PW("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",b=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${x.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,S=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${S}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${a[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${a[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${b}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function XV(t,e,n,r=null){let s=e.shape[0],i=e.shape[1];null!=r&&(s=r.shape[0],i=r.shape[1]);const a=HT(i),o={windowSize:a,inSize:i,batchSize:s,outSize:Math.ceil(i/a)},l=new jV(o,n,null==r),u=[e];null!=r&&u.push(r);const c=t.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=XV(t,e,n,c);return t.disposeIntermediateTensorInfo(c),h}function KV(t,e,n,r=null){const s=null!=r?r.shape:e.shape,i=HT(s[s.length-1]),a=new qV(s,i,n,null==r),o=null==r?[e]:[e,r],l=t.runWebGLProgram(a,o,"int32");if(l.shape.length===e.shape.length){const r=KV(t,e,n,l);return t.disposeIntermediateTensorInfo(l),r}return l}function YV(t,e,n,r){const s=[n];if(FS("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!Sm().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const n=[],i=t.texData.get(e.dataId);let a=e;null!==i&&i.isPacked&&(a=t.unpackTensor(e),n.push(a));const[o,l]=DS(a.shape,s),u=Hf(l),c=yV({inputs:{x:a},backend:t,attrs:{shape:[-1,u]}});n.push(c);const h=XV(t,c,r);n.push(h);const d=yV({inputs:{x:h},backend:t,attrs:{shape:o}});return n.forEach((e=>t.disposeIntermediateTensorInfo(e))),d}return KV(t,e,r)}const JV={kernelName:Lm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i}=r;let a=Zf(i,s.shape);const o=PS(a,s.shape.length);let l=s;const u=[];null!=o&&(l=IV({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),a=OS(a.length,l.shape.length)),FS("argMax",[a[0]],l.shape.length);const c=YV(n,l,a[0],"max");return u.forEach((t=>n.disposeIntermediateTensorInfo(t))),c}},ZV={kernelName:Fm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i}=r;let a=Zf(i,s.shape);const o=PS(a,s.shape.length);let l=s;const u=[];null!=o&&(l=IV({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),a=OS(a.length,l.shape.length)),FS("argMin",[a[0]],l.shape.length);const c=YV(n,l,a[0],"min");return u.forEach((t=>n.disposeIntermediateTensorInfo(t))),c}},QV=cV({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),tG={kernelName:Pm,backendName:"webgl",kernelFunc:QV},eG=cV({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),nG={kernelName:$m,backendName:"webgl",kernelFunc:eG},rG=cV({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),sG={kernelName:Om,backendName:"webgl",kernelFunc:rG},iG=hV({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),aG={kernelName:Bm,backendName:"webgl",kernelFunc:iG},oG=cV({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),lG={kernelName:zm,backendName:"webgl",kernelFunc:oG};class uG{constructor(t,e,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideHeight,o=t.strideWidth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const f="avg"===e,m=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,g=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let x="0.0";if(f||(x="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${e} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(y="avgValue / count");const v=4*Math.floor(i/4),b=i%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===b}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${y});\n      }\n    `}}class cG{constructor(t,e,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===e&&n)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,a=t.strideDepth,o=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,x=t.padInfo.left;this.outputShape=t.outShape;const y="avg"===e;let v="0.0";if(y||(v="-1.0 / 1e-20"),n){const e=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${x});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${e} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(b="avgValue / count");const w=4*Math.floor(i/4),S=i%4,_=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${x});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${_}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${2===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${3===S}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${_}\n            }\n          }\n          setOutput(${b});\n        }\n      }\n    `}}const hG={kernelName:Um,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;uU(s,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=r;Uf(Dw(a,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=_w(s.shape,i,a,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&jf(u.inShape,u.outShape))return tV({inputs:{x:s},backend:n});const c=new uG(u,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}},dG={kernelName:Vm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=Tw(s.shape,i,a,[1,1,1],o,l,u),h=new cG(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class pG{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,a=t.dilationWidth,o=t.effectiveFilterHeight,l=t.effectiveFilterWidth,u=o-1-t.padInfo.top,c=l-1-t.padInfo.left,h=1/(e*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${i}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${a}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class fG{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,p=c-1-t.padInfo.front,f=h-1-t.padInfo.top,m=d-1-t.padInfo.left,g=1/(e*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const mG={kernelName:Gm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,a=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=Tw(a.shape,o,l,[1,1,1],u,c),d=new fG(h);return n.runWebGLProgram(d,[s],a.dtype)}},gG={kernelName:Wm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,a=i;uU([s,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=_w(a.shape,o,l,1,u),h=new pG(c);return n.runWebGLProgram(h,[s],a.dtype)}},xG={kernelName:Hm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{a:s,b:i}=e,{transposeA:a,transposeB:o}=r;return AV({a:s,b:i,transposeA:a,transposeB:o,backend:n})}};class yG{constructor(t,e,n,r,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Bb(t,e),Bb(t,n);let a="0.0";null!=r&&(Bb(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="1.0";null!=s&&(Bb(t,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class vG{constructor(t,e,n,r,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Bb(t,e),Bb(t,n);let a="vec4(0.0)";null!=r&&(Bb(t,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(Bb(t,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const bG={kernelName:Fg,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:s,variance:i,offset:a,scale:o}=t;Uf(s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Uf(null==a||s.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Uf(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[r,s,i];let c=null;null!=a&&(c=a.shape,u.push(a));let h=null;null!=o&&(h=o.shape,u.push(o));const d=Sm().getBool("WEBGL_PACK_NORMALIZATION")?new vG(r.shape,s.shape,i.shape,c,h,l):new yG(r.shape,s.shape,i.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)}};class wG{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=EU(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(t){if(1===t)return"sourceLoc";if(t<=6)return SG.slice(0,t).map((t=>"sourceLoc."+t)).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}(this.rank);let r;r=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map(((t,e)=>`sourceLoc.${SG[e]} = start[${e}] + coords.${SG[e]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const SG=["x","y","z","w","u","v"];class _G{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=EU(this.rank),n=PW("coords",this.rank),r=PW("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${s})`,a=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${i};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map(((t,e)=>`start[${e}]`)).join()});`:t.map(((t,e)=>`${r[e]} = ${n[e]} + start[${e}];`)).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${a}\n        ${o}\n        setOutput(result);\n      }\n    `}}function TG(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:i,size:a}=r,[o,l]=ew(s,i,a);if(Ub(s,o,l),0===Hf(l))return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const t=n.texData.get(s.dataId),e=wW(t.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,e)}const{isPacked:u}=n.texData.get(s.dataId),c=Qb(s.shape,o,l);if(u||!c){const t=Sm().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _G(l):new wG(l),e=[o];return n.runWebGLProgram(t,[s],s.dtype,e)}return n.uploadToGPU(s.dataId),function(t,e,n,r){const s=r.texData.get(t.dataId),i=r.makeTensorInfo(n,t.dtype),a=r.texData.get(i.dataId);Object.assign(a,s),a.refCount=1,a.shape=n,a.dtype=t.dtype;let o=tw(e,cm(t.shape));s.slice&&(o+=s.slice.flatOffset),a.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||t.dataId};const l=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,l+1),i}(s,o,l,n)}const MG={kernelName:jx,backendName:"webgl",kernelFunc:TG},EG={kernelName:jm,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:i,crops:a}=r;Uf(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=i.reduce(((t,e)=>t*e)),l=qT(s.shape,i,o),u=XT(l.length,i.length),c=KT(s.shape,i,o),h=YT(a,i.length),d=JT(c,a,i.length),p=[],f=yV({inputs:{x:s},backend:n,attrs:{shape:l}}),m=IV({inputs:{x:f},backend:n,attrs:{perm:u}}),g=yV({inputs:{x:m},backend:n,attrs:{shape:c}}),x=TG({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach((t=>n.disposeIntermediateTensorInfo(t))),x}},kG={kernelName:qm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:i}=e,{size:a}=r,o=n.readSync(s.dataId),l=n.readSync(i.dataId),u=qU(o,l,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,u)}},IG={kernelName:Xm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{s0:r,s1:s}=e,i=n.readSync(r.dataId),a=n.readSync(s.dataId),o=Bb(Array.from(i),Array.from(a));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},CG=hV({opSnippet:"return float(a != b);",cpuKernelImpl:fW,dtype:"bool"}),AG={kernelName:yx,backendName:"webgl",kernelFunc:CG};function RG(t){const{inputs:e,backend:n}=t,{input:r}=e;return tV({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const NG={kernelName:Ax,backendName:"webgl",kernelFunc:RG},DG={kernelName:Km,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r,attrs:s}=e,{x:i}=n,{dtype:a}=s;if("complex64"===a){if("complex64"===i.dtype)return tV({inputs:{x:i},backend:r});const e=GS(i.shape),n=t({inputs:{x:i},backend:r,attrs:{dtype:"float32"}}),s=nV({inputs:{real:n,imag:e},backend:r});return e.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===i.dtype){const e=RG({inputs:{input:i},backend:r}),n=t({inputs:{x:e},backend:r,attrs:{dtype:a}});return r.disposeIntermediateTensorInfo(e),n}if(!nm(i.dtype,a)){const t=tV({inputs:{x:i},backend:r});return{dataId:t.dataId,shape:t.shape,dtype:a}}if("int32"===a)return function(t,e){const n=new VW(t.shape,"return float(int(x));"),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(i,r);if("bool"===a){const t=r.makeTensorInfo([],"bool",tm("bool",1)),e=CG({inputs:{a:i,b:t},backend:r});return r.disposeIntermediateTensorInfo(t),e}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`)}},LG="return ceil(x);",FG=cV({opSnippet:LG,packedOpSnippet:LG,cpuKernelImpl:KU}),PG={kernelName:Ym,backendName:"webgl",kernelFunc:FG};class $G{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class OG{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const zG={kernelName:Jm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{clipValueMin:i,clipValueMax:a}=r;let o;o=Sm().getBool("WEBGL_PACK_CLIP")?new OG(s.shape):new $G(s.shape);const l=[[i],[a]];return n.runWebGLProgram(o,[s],s.dtype,l)}};class BG{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function UG(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}const WG={kernelName:Qm,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,s=n.texData.get(r.dataId),i=new BG(r.shape),a=[UG(r,s.complexTensorInfos.real),UG(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(i,a,a[0].dtype)}};class VG{constructor(t){this.outputShape=[],this.outputShape=VT(t,1),this.variableNames=t.map(((t,e)=>`T${e}`));const e=new Array(t.length-1);e[0]=t[0][1];for(let n=1;n<e.length;n++)e[n]=e[n-1]+t[n][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let t=1;t<e.length;t++){const r=e[t-1];n.push(`else if (yC < ${e[t]}) setOutput(getT${t}(yR, yC-${r}));`)}const r=e.length,s=e[e.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class GG{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=VT(t,e);const n=this.outputShape,r=n.length,s=EU(r),i=PW("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map(((t,e)=>`T${e}`));const o=new Array(t.length-1);o[0]=t[0][e];for(let n=1;n<o.length;n++)o[n]=o[n-1]+t[n][e];const l=a[e],u=a.slice(-2),c=a.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let t=1;t<o.length;t++){const e=o[t-1];h+=`\n        if (${l} < ${o[t]}  && ${l} >= ${o[t-1]}) {\n          return getChannel(\n            getT${t}(${HG(a,l,e)}),\n            vec2(${HG(u,l,e)}));\n        }`}const d=o.length,p=o[o.length-1];h+=`\n        return getChannel(\n          getT${d}(${HG(a,l,p)}),\n          vec2(${HG(u,l,p)}));`,this.userCode=`\n      float getValue(${a.map((t=>"int "+t))}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[r-1]} = ${i[r-1]} + 1;\n        if (${i[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[r-2]} = ${i[r-2]} + 1;\n        if (${i[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[r-1]} = ${i[r-1]} - 1;\n        if (${i[r-2]} < ${n[r-2]} &&\n            ${i[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function HG(t,e,n){const r=t.indexOf(e);return t.map(((t,e)=>e===r?`${t} - ${n}`:t)).join()}function jG(t){const{inputs:e,backend:n}=t,{input:r}=e;return tV({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const qG={kernelName:Wg,backendName:"webgl",kernelFunc:jG};function XG(t,e,n){const r=t[0].dtype;if("complex64"===r){const r=t.map((t=>RG({inputs:{input:t},backend:n}))),s=t.map((t=>jG({inputs:{input:t},backend:n}))),i=XG(r,e,n),a=XG(s,e,n),o=nV({inputs:{real:i,imag:a},backend:n});return r.forEach((t=>n.disposeIntermediateTensorInfo(t))),s.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),o}let s=n.shouldExecuteOnCPU(t);if("string"===r&&(s=!0),s){const s=t.map((t=>{const r=Hf(t.shape.slice(e));return yV({inputs:{x:t},backend:n,attrs:{shape:[-1,r]}})})),i=s.map((t=>({vals:n.readSync(t.dataId),shape:t.shape}))),a=VT(s.map((t=>t.shape)),1),o=1===s[0].shape[0],l=YU(i,a,r,o),u=VT(t.map((t=>t.shape)),e),c=n.makeTensorInfo(u,r,l);return s.forEach((t=>n.disposeIntermediateTensorInfo(t))),c}if(t.length>Sm().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const r=Math.floor(t.length/2),s=XG(t.slice(0,r),e,n),i=XG(t.slice(r),e,n),a=XG([s,i],e,n);return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),a}if(Sm().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const s=new GG(t.map((t=>t.shape)),e);return n.runWebGLProgram(s,t,r)}const{tensors2D:i,outShape:a}=function(t,e,n){const r=VT(t.map((t=>t.shape)),e);return{tensors2D:t.map((t=>yV({inputs:{x:t},attrs:{shape:[-1,Hf(t.shape.slice(e))]},backend:n}))),outShape:r}}(t,e,n),o=new VG(i.map((t=>t.shape))),l=n.runWebGLProgram(o,i,r);i.forEach((t=>n.disposeIntermediateTensorInfo(t)));const u=yV({inputs:{x:l},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(l),u}function KG(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r,i=Zf(s,e[0].shape)[0],a=VT(e.map((t=>t.shape)),i);if(0===Hf(a))return n.makeTensorInfo(a,e[0].dtype,[]);const o=e.filter((t=>Hf(t.shape)>0));return 1===o.length?tV({inputs:{x:o[0]},backend:n}):(WT(o.map((t=>t.shape)),i),XG(o,i,n))}const YG={kernelName:tg,backendName:"webgl",kernelFunc:KG};class JG{constructor(t,e=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,a=t.padInfo.left,o=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4,m="channelsLast"===t.dataFormat,g=m?1:2,x=m?2:3,y=m?3:1;let v="",b="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,b="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${x}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${b}\n        setOutput(result);\n      }\n    `}}class ZG{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,r=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,c=t.filterDepth,h=t.filterHeight,d=t.filterWidth,p=4*Math.floor(t.inChannels/4),f=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${i}, ${a});\n      const ivec3 pads = ivec3(${e}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class QG{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=NU(this.outputShape.length);const{dataFormat:n}=e,r=hU(),s="channelsLast"===n,i=s?0:1,a=s?1:2,o=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${t[1]} && pos < ${t[0]}) {`;let l="";for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.y + ${e};\n          pos = rc.x + ${t};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*t+e}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*t+e}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function tH({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const l=t.shape,u=r.texData.get(t.dataId),c=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,p="channelsLast"===n.dataFormat;let f;const m=[];if(null!=i&&!p&&3===i.shape.length){const t=IV({inputs:{x:i},backend:r,attrs:{perm:[1,2,0]}});m.push(t),i=t}if((1!==h&&1!==d||!(c>1e3))&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&jf(u.shape.slice(-3),l.slice(-3))){const c=l[0]*l[1]*(l[2]+1),h={dataId:t.dataId,shape:[1,c,n.inChannels],dtype:t.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Uf(rU(u.shape,h.shape),(()=>`packed reshape ${u.shape} to ${h.shape} isn't free`));const p=yV({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(p);const g=AV({a:h,b:p,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),x=r.texData.get(g.dataId);Uf(x.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=d,x.shape=n.outShape,f=tV({inputs:{x:g},backend:r}),f.shape=n.outShape,m.push(g)}else{const l=p?t:IV({inputs:{x:t},backend:r,attrs:{perm:[0,2,3,1]}}),u=l.shape,c=yV({inputs:{x:l},backend:r,attrs:{shape:[1,u[0]*u[1]*u[2],n.inChannels]}}),h=yV({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=AV({a:c,b:h,transposeA:!1,transposeB:!1,backend:r,bias:s,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),g=yV({inputs:{x:d},backend:r,attrs:{shape:[n.batchSize,n.outHeight,n.outWidth,n.outChannels]}});f=p?g:IV({inputs:{x:g},backend:r,attrs:{perm:[0,3,1,2]}}),p||(m.push(l),m.push(g)),m.push(c),m.push(h),m.push(d)}for(const t of m)r.disposeIntermediateTensorInfo(t);return f}function eH({x:t,filter:e,convInfo:n,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=l*u*c,g=d*h,x=[m,g],y=[];if(null!=i&&!f&&3===i.shape.length){const t=IV({inputs:{x:i},backend:r,attrs:{perm:[1,2,0]}});y.push(t),i=t}const v=yV({inputs:{x:t},backend:r,attrs:{shape:t.shape.slice(1)}}),b=yV({inputs:{x:e},backend:r,attrs:{shape:[1,m,Hf(e.shape)/m]}});y.push(v),y.push(b);const w=new QG(x,n),S=[v.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],_=r.runWebGLProgram(w,[v],"float32",S),T=yV({inputs:{x:_},backend:r,attrs:{shape:[1,x[0],x[1]]}});y.push(_),y.push(T);const M=null!=s,E=null!=i,k="leakyrelu"===o,I=o?dV(o,!0):null,C=new pV(T.shape,b.shape,[1,g,n.outChannels],!0,!1,M,I,E,k),A=[T,b];if(s&&A.push(s),E&&A.push(i),k){const t=r.makeTensorInfo([],"float32",tv(a,"float32"));A.push(t),y.push(t)}const R=r.runWebGLProgram(C,A,"float32"),N=yV({inputs:{x:R},backend:r,attrs:{shape:[1,d,h,n.outChannels]}}),D=f?N:IV({inputs:{x:N},backend:r,attrs:{perm:[0,3,1,2]}});f||y.push(N),y.push(R);for(const t of y)r.disposeIntermediateTensorInfo(t);return D}const nH={kernelName:eg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,h=Lw(l),d=Mw(s.shape,i.shape,a,u,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(Sm().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])p=eH({x:s,filter:i,convInfo:d,backend:n});else{const t=new JG(d);p=n.runWebGLProgram(t,[s,i],"float32")}else p=tH({x:s,filter:i,convInfo:d,backend:n});const f=yV({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class rH{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,s=t.padInfo.left,i="channelsLast"===t.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${i}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class sH{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,s=t.strideWidth,i="channelsLast"===t.dataFormat,a=e-1-t.padInfo.top,o=n-1-t.padInfo.left,l=i?1:2,u=i?2:3,c=i?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class iH{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,s=t.padInfo.front,i=t.padInfo.top,a=t.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${e} - ${s};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${i};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${a};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class aH{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,r=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,o=e-1-t.padInfo.front,l=n-1-t.padInfo.top,u=r-1-t.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const oH={kernelName:ng,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,h=Lw(l),d=Mw(s.shape,c,a,1,o,u,!1,h),p=new rH(d);return n.runWebGLProgram(p,[s,i],"float32")}},lH={kernelName:rg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,h=Lw(u),d=Mw(a,i.shape,o,1,l,c,!1,h),p=new sH(d);return n.runWebGLProgram(p,[s,i],"float32")}},uH={kernelName:sg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:a,pad:o,dilations:l}=r,u=Ew(s.shape,i.shape,a,l,o),c=new ZG(u);return n.runWebGLProgram(c,[s,i],"float32")}},cH={kernelName:ig,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:a,pad:o,filterShape:l}=r,u=Ew(s.shape,l,a,1,o),c=new iH(u);return n.runWebGLProgram(c,[s,i],"float32")}},hH={kernelName:ag,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{pad:a,strides:o,inputShape:l}=r,u=Ew(l,i.shape,o,1,a),c=new aH(u);return n.runWebGLProgram(c,[s,i],"float32")}},dH=cV({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),pH={kernelName:og,backendName:"webgl",kernelFunc:dH},fH=cV({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),mH={kernelName:lg,backendName:"webgl",kernelFunc:fH};class gH{constructor(t,e,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,o,l]=t,[u]=e,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===r?1:0,[p,f]=[a-1+".0",o-1+".0"],[m,g,x]=c>1?[""+(a-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[y,v,b]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${b};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const xH={kernelName:hg,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{image:s,boxes:i,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:u}=r,c=new gH(s.shape,i.shape,o,l,u);return n.runWebGLProgram(c,[s,i,a],"float32")}};var yH;!function(t){t.Prod="*",t.Sum="+"}(yH||(yH={}));class vH{constructor(t,e,n,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,i=this.op===yH.Prod?"1.0":"0.0",a=n?i:`getX(${bH(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${EU(s)} coords = getOutputCoords();\n        int end = ${wH(s,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${wH(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${bH(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function bH(t,e,n){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function wH(t,e,n){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function SH(t,e,n,r,s,i){const a=e.shape.length,o=PS([r],a);let l=e;null!=o&&(l=IV({inputs:{x:e},backend:n,attrs:{perm:o}}));const u=OS(1,a)[0];if(u!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const c=l.shape[u];let h=tV({inputs:{x:l},backend:n});for(let e=0;e<=Math.ceil(Math.log2(c))-1;e++){const r=new vH(t,l.shape,!1,i),s=[[e]],a=h;h=n.runWebGLProgram(r,[h],h.dtype,s),n.disposeIntermediateTensorInfo(a)}if(s){const e=new vH(t,l.shape,s,i),r=h;h=n.runWebGLProgram(e,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const t=IV({inputs:{x:h},backend:n,attrs:{perm:$S(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),t}return h}const _H={kernelName:ug,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,exclusive:a,reverse:o}=r;return SH(yH.Prod,s,n,i,a,o)}},TH={kernelName:cg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,exclusive:a,reverse:o}=r;return SH(yH.Sum,s,n,i,a,o)}},MH={kernelName:dg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,weights:i}=e,{size:a,binaryOutput:o}=r;if(1===s.shape.length){const t=n.readSync(s.dataId),e=n.readSync(i.dataId),r=qU(t,e,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,r)}if(2===s.shape.length){const t=n.bufferSync(s),e=n.bufferSync(i),r=XU(t,e,a,o);return n.makeTensorInfo(r.shape,i.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class EH{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const kH={kernelName:pg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockSize:i,dataFormat:a}=r,o=s.shape[0],l=("NHWC"===a?s.shape[1]:s.shape[2])*i,u=("NHWC"===a?s.shape[2]:s.shape[3])*i,c=("NHWC"===a?s.shape[3]:s.shape[1])/(i*i),h=new EH("NHWC"===a?[o,l,u,c]:[o,c,l,u],i,a);return n.runWebGLProgram(h,[s],s.dtype)}};class IH{constructor(t,e=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=NU(this.outputShape.length);const i=t.filterHeight,a=t.filterWidth,o=t.outChannels/t.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class CH{constructor(t,e=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=NU(this.outputShape.length);const i=t.outChannels/t.inChannels,a=t.padInfo.left,o=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,h=c;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let t=0;t<c;t++)d+=`\n          vec4 xTexelC${2*t};\n          int xTexelC${2*t}Ready;\n          vec4 xTexelC${2*t+1};\n          int xTexelC${2*t+1}Ready;\n          vec4 xC${t};`;d+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let t=0;t<c;t++)d+=`\n          xTexelC${2*t} = vec4(0.0);\n          xTexelC${2*t}Ready = 0;\n          xTexelC${2*t+1} = vec4(0.0);\n          xTexelC${2*t+1}Ready = 0;\n          xC${t} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let t=0;t<(h+1)/2;t++){const e=2*t;if(d+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(a%2==1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,d+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=a%2==0?zf(l):l;l%2==0&&a%2==1||l%2!=0&&a%2!=1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,l>1&&(d+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                      xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${e}Ready = 1;\n                    }\n                    `),d+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                  `):d+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(a%2==1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(d+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(d+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(d+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const AH={kernelName:fg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),Uf(Dw(a,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`));const h=Mw(s.shape,i.shape,a,c,o,u,!0);let d;d=Sm().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new CH(h):new IH(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[s,i],"float32",p)}};class RH{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,r=t.padInfo.top,s=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${i} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${r};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class NH{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,r=t.strideHeight,s=t.strideWidth,i=e-1-t.padInfo.top,a=n-1-t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const DH={kernelName:mg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,dy:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,h=Mw(s.shape,c,a,o,l,u,!0),d=new RH(h);return n.runWebGLProgram(d,[s,i],"float32")}},LH={kernelName:gg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,filter:i}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,h=Mw(c,i.shape,a,o,l,u,!0),d=new NH(h);return n.runWebGLProgram(d,[s,i],"float32")}};class FH{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const PH={kernelName:xg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e,s=[...r.shape,...r.shape],i=Hf(r.shape),a=yV({inputs:{x:r},backend:n,attrs:{shape:[i]}}),o=new FH(i),l=n.runWebGLProgram(o,[a],a.dtype),u=yV({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}};class $H{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:r,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:o,dilationHeight:l,dilationWidth:u}=t,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${i});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const OH={kernelName:yg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i}=e,{strides:a,pad:o,dilations:l}=r,u=Sw(s.shape,i.shape,a,o,"NHWC",l);let c;const h=new $H(u);c=n.runWebGLProgram(h,[s,i],"float32");const d=yV({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}},zH={kernelName:Sg,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{equation:s}=r,i=e,{allDims:a,summedDims:o,idDims:l}=vM(s,i.length);wM(a.length,l,i);const{path:u,steps:c}=SM(o,l),h=c.length;let d=null,p=a.length;const f=[];for(let t=0;t<h;++t){for(const e of c[t]){const{permutationIndices:t,expandDims:r}=bM(p,l[e]);let s;_M(t)?s=i[e]:(s=IV({inputs:{x:i[e]},backend:n,attrs:{perm:t}}),f.push(s));const a=s.shape.slice();for(let t=0;t<r.length;++t)a.splice(r[t],0,1);jf(s.shape,a)||(s=yV({inputs:{x:s},backend:n,attrs:{shape:a}}),f.push(s)),null===d?d=s:(d=gV({inputs:{a:s,b:d},backend:n}),f.push(d))}t<h-1&&(u[t]>=0&&(d=EV({inputs:{x:d},backend:n,attrs:{axis:u[t]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const t of f)t!==d&&n.disposeIntermediateTensorInfo(t);return d}},BH=cV({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),UH={kernelName:_g,backendName:"webgl",kernelFunc:BH},WH={kernelName:Tg,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n}=t,{dy:r,y:s}=e,i=Sm().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new QW("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new ZW("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(i,[r,s],r.dtype)}},VH=hV({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:JU}),GH={kernelName:Eg,backendName:"webgl",kernelFunc:VH},HH=cV({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${sM};\n  float a1 = ${iM};\n  float a2 = ${aM};\n  float a3 = ${oM};\n  float a4 = ${lM};\n  float a5 = ${uM};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),jH={kernelName:Mg,backendName:"webgl",kernelFunc:HH},qH=cV({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:ZU,dtype:"float32"}),XH={kernelName:kg,backendName:"webgl",kernelFunc:qH};function KH(t){const{inputs:e,attrs:n,backend:r}=t,{dim:s}=n,{input:i}=e,a=i.shape.length,o=i.shape.slice();let l=s;return s<0&&(Uf(-(a+1)<=s,(()=>`Axis must be in the interval [${-(a+1)}, ${a}]`)),l=a+s+1),o.splice(l,0,1),yV({inputs:{x:i},backend:r,attrs:{shape:o}})}const YH={kernelName:Ig,backendName:"webgl",kernelFunc:KH},JH="return exp(x) - 1.0;",ZH=cV({opSnippet:JH,packedOpSnippet:JH,cpuKernelImpl:QU}),QH={kernelName:Cg,backendName:"webgl",kernelFunc:ZH};class tj{constructor(t,e,n){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${r}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function ej(t,e,n){const r=n.texData.get(t.dataId),s=Hf(t.shape),i=t.shape[t.shape.length-1],a=yV({inputs:{x:t},backend:n,attrs:{shape:[s/i,i]}}),o=a.shape,l=new tj("real",o,e),u=new tj("imag",o,e),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(l,c,"float32"),d=n.runWebGLProgram(u,c,"float32"),p=nV({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=yV({inputs:{x:p},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(p),f}const nj={kernelName:Ag,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return ej(r,!1,n)}};class rj{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function sj(t){const{backend:e,attrs:n}=t,{shape:r,value:s}=n;let{dtype:i}=n;if(i=i||om(s),"string"===i){const t=em(i,Hf(r));return t.fill(s),e.makeTensorInfo(r,i,t)}{const t=new rj(r,s),n=[[s]];return e.runWebGLProgram(t,[],i,n)}}const ij={kernelName:Rg,backendName:"webgl",kernelFunc:sj};class aj{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const oj={kernelName:Ng,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,s=new aj(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},lj="return floor(x);",uj=cV({opSnippet:lj,packedOpSnippet:lj,cpuKernelImpl:tW}),cj={kernelName:Dg,backendName:"webgl",kernelFunc:uj},hj=hV({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),dj={kernelName:Lg,backendName:"webgl",kernelFunc:hj};class pj{constructor(t){this.variableNames=["A"];const e=hU(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class fj{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=hU(),[n,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const mj={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:s}=e;const{numChannels:i}=r,a="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=a?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],h=[u,l,i];(o||a)&&(null==gj&&(gj=document.createElement("canvas").getContext("2d")),gj.canvas.width=l,gj.canvas.height=u,gj.drawImage(s,0,0,l,u),s=gj.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=FB.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=Sm().getBool("WEBGL_PACK")?new fj(h):new pj(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let gj;const xj={kernelName:Iy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=Lw(c),g=Mw(s.shape,i.shape,l,h,u,d,!1,m);let x;const y=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(Sm().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])x=eH({x:s,filter:i,convInfo:g,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const t=null!=a,e=null!=o,r="leakyrelu"===p,l=p?dV(p,!1):null,u=new JG(g,t,l,e,r),h=[s,i],d=(t,e)=>{if("NCHW"===e&&1===t.shape.length&&1!==t.shape[0]){const e=yV({inputs:{x:t},backend:n,attrs:{shape:[t.shape[0],1,1]}});return y.push(e),e}return t};if(t&&h.push(d(a,c)),e&&h.push(d(o,c)),r){const t=n.makeTensorInfo([],"float32",tv(f,"float32"));h.push(t),y.push(t)}x=n.runWebGLProgram(u,h,"float32")}else x=tH({x:s,filter:i,convInfo:g,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const v=yV({inputs:{x},backend:n,attrs:{shape:g.outShape}});return y.push(x),y.forEach((t=>n.disposeIntermediateTensorInfo(t))),v}},yj={kernelName:Cy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,filter:i,bias:a,preluActivationWeights:o}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Uf(Dw(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=Mw(s.shape,i.shape,l,m,u,h,!0),x=Sm().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=d?dV(d,x):null,v=[s,i],b=null!=a,w=null!=o,S="leakyrelu"===d;if(b&&v.push(a),w&&v.push(o),S){const t=n.makeTensorInfo([],"float32",tv(p,"float32"));v.push(t),f.push(t)}let _;_=x?new CH(g,b,y,w,S):new IH(g,b,y,w,S);const T=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],M=n.runWebGLProgram(_,v,"float32",T);return f.forEach((t=>n.disposeIntermediateTensorInfo(t))),M}};class vj{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const r=EU(e.length),s=EU(n.length),i=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${i};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const bj={kernelName:$g,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{params:r,indices:s}=e,i=s.shape,a=i[i.length-1],o=Hf(r.shape),[l,u,c,h]=ZT(r,s),d=yV({inputs:{x:s},backend:n,attrs:{shape:[u,a]}}),p=yV({inputs:{x:r},backend:n,attrs:{shape:[Hf(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const t=n.readSync(s.dataId),e=n.bufferSync(r),i=eW(t,e,r.dtype,u,a,c,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,i.values)}const f=new vj(a,h,[u,c]),m=n.runWebGLProgram(f,[p,d],p.dtype),g=yV({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class wj{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=EU(this.rank),r=function(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let e=0;e<t.length;e++)2===e?r.push("index"):r.push(`${n[e]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function Sj(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,indices:i}=e,{axis:a,batchDims:o}=r,l=Zf(a,s.shape)[0];if(Sm().get("DEBUG")){const t=n.readSync(i.dataId),e=s.shape[l];for(let n=0;n<t.length;++n){const r=t[n];Uf(r<=e-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${e-1}]`))}}const u=BM(s,i,l,o),c=Hf(i.shape),h=[],d=yV({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=yV({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,i])||"string"===s.dtype){const t=n.bufferSync(p),e=n.bufferSync(d),r=nW(e,t,f);return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new wj(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const x=yV({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),x}const _j={kernelName:Pg,backendName:"webgl",kernelFunc:Sj},Tj=hV({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:rW,dtype:"bool"}),Mj={kernelName:Og,backendName:"webgl",kernelFunc:Tj},Ej=hV({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:sW}),kj={kernelName:zg,backendName:"webgl",kernelFunc:Ej},Ij={kernelName:Ug,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{input:r}=e;return ej(r,!0,n)}},Cj=cV({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Aj={kernelName:Vg,backendName:"webgl",kernelFunc:Cj},Rj=cV({opSnippet:"return float(isinf(x));",dtype:"bool"}),Nj={kernelName:Gg,backendName:"webgl",kernelFunc:Rj},Dj=cV({opSnippet:"return float(isnan(x));",dtype:"bool"}),Lj={kernelName:Hg,backendName:"webgl",kernelFunc:Dj},Fj=hV({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:iW,dtype:"bool"}),Pj={kernelName:qg,backendName:"webgl",kernelFunc:Fj},$j=hV({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:aW,dtype:"bool"}),Oj={kernelName:Xg,backendName:"webgl",kernelFunc:$j},zj={kernelName:Kg,backendName:"webgl",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:s,num:i}=n,a=oW(r,s,i);return e.makeTensorInfo([a.length],"float32",a)}},Bj=cV({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:lW}),Uj={kernelName:Yg,backendName:"webgl",kernelFunc:Bj},Wj=cV({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),Vj={kernelName:Jg,backendName:"webgl",kernelFunc:Wj},Gj=hV({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Hj={kernelName:Zg,backendName:"webgl",kernelFunc:Gj},jj=cV({opSnippet:"return float(!(x >= 1.0));"}),qj={kernelName:Qg,backendName:"webgl",kernelFunc:jj},Xj=hV({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Kj={kernelName:tx,backendName:"webgl",kernelFunc:Xj};class Yj{constructor(t,e,n,r,s){this.variableNames=["x"],this.outputShape=[];const i=e,a=t[3]-1;let o;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class Jj{constructor(t,e,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,a=t[3]-1;let o;this.outputShape=t;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const Zj={kernelName:ex,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{depthRadius:i,bias:a,alpha:o,beta:l}=r,u=Sm().getBool("WEBGL_PACK_NORMALIZATION")?new Jj(s.shape,i,a,o,l):new Yj(s.shape,i,a,o,l);return n.runWebGLProgram(u,[s],s.dtype)}};class Qj{constructor(t,e,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const tq={kernelName:nx,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s,y:i,dy:a}=e,{depthRadius:o,bias:l,alpha:u,beta:c}=r,h=new Qj(s.shape,o,l,u,c);return n.runWebGLProgram(h,[s,i,a],s.dtype)}};function eq(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reductionIndices:i,keepDims:a}=r,o=s.shape.length,l=Zf(i,s.shape);let u=l;const c=PS(u,o),h=null!=c,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const t=n.texData.get(p.dataId).values,e=new Array(o);for(let t=0;t<e.length;t++)e[t]=s.shape[c[t]];const r=DW(t,s.shape,s.dtype,c,e);p=n.makeTensorInfo(e,s.dtype),n.texData.get(p.dataId).values=r}else p=MV(s,c,n);u=OS(u.length,o)}FS("max",u,o);const[f,m]=DS(p.shape,u);let g,x=f;if(a&&(x=LS(f,l)),d){const t=n.texData.get(p.dataId).values,e=uW(t,Hf(m),x,s.dtype);g=n.makeTensorInfo(x,s.dtype),n.texData.get(g.dataId).values=e}else g=function(t,e,n,r){const s=Hf(e),i=yV({inputs:{x:t},attrs:{shape:[Hf(t.shape)/s,s]},backend:r}),a=SV(i,t.dtype,"max",r),o=yV({inputs:{x:a},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),o}(p,m,x,n);return h&&n.disposeIntermediateTensorInfo(p),g}const nq={kernelName:rx,backendName:"webgl",kernelFunc:eq},rq=hV({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:cW}),sq={kernelName:sx,backendName:"webgl",kernelFunc:rq},iq={kernelName:ix,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e;uU(s,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=r;Uf(Dw(a,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=_w(s.shape,i,a,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&jf(u.inShape,u.outShape))return tV({inputs:{x:s},backend:n});const c=new uG(u,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}},aq={kernelName:ox,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{filterSize:i,strides:a,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=Tw(s.shape,i,a,[1,1,1],o,u,l),h=new cG(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class oq{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,n=t.strideWidth,r=t.dilationHeight,s=t.effectiveFilterHeight,i=t.effectiveFilterWidth,a=s-1-t.padInfo.top,o=i-1-t.padInfo.left,l=s*i-1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class lq{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,n=t.strideHeight,r=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,a=t.dilationWidth,o=t.effectiveFilterDepth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=o-1-t.padInfo.front,h=l-1-t.padInfo.top,d=u-1-t.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${h}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${e}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${i}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${a}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const uq={kernelName:lx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i}=e,a=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=Tw(a.shape,o,l,[1,1,1],u,c),d=new cG(h,"max",!0),p=n.runWebGLProgram(d,[a],a.dtype),f=new lq(h),m=n.runWebGLProgram(f,[s,p],a.dtype);return n.disposeIntermediateTensorInfo(p),m}},cq={kernelName:ax,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{dy:s,input:i,output:a}=e,o=i;uU([i,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=_w(o.shape,l,u,1,c,h),p=new uG(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new oq(d),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},hq={kernelName:ux,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:s,strides:i,pad:a,includeBatchInIndex:o}=e,l=n;Uf(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const u=[1,1];Uf(Dw(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));const c=_w(r.shape,s,i,u,a),[h,d]=function(t,e,n,r){let s=new uG(n,"max",!1);const i=r.runWebGLProgram(s,[t],"float32");return s=new uG(n,"max",!0,!0,e),[i,r.runWebGLProgram(s,[t],"float32")]}(r,o,c,l);return[h,d]}},dq={kernelName:cx,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:s,axis:i}=e,a=n,o=r.shape.length,l=Zf(i,r.shape);let u=l;const c=PS(u,o),h=null!=c,d=a.shouldExecuteOnCPU([r]),p=[];let f=r;if(h){if(d){const t=a.texData.get(f.dataId).values,e=new Array(o);for(let t=0;t<e.length;t++)e[t]=r.shape[c[t]];const n=DW(t,r.shape,r.dtype,c,e);f=a.makeTensorInfo(e,r.dtype),a.texData.get(f.dataId).values=n}else f=MV(r,c,a);p.push(f),u=OS(u.length,o)}FS("sum",u,o);const[m,g]=DS(f.shape,u);let x=m;s&&(x=LS(m,l));const y=function(t,e,n,r){const s=Hf(e),i=yV({inputs:{x:t},attrs:{shape:[Hf(t.shape)/s,s]},backend:r}),a=SV(i,"float32","mean",r),o=yV({inputs:{x:a},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),o}(f,g,x,a);for(const t of p)a.disposeIntermediateTensorInfo(t);return y}},pq={kernelName:hx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r,o=s.shape.length,l=Zf(i,s.shape);let u=l;const c=PS(u,o);let h=s;null!=c&&(h=IV({inputs:{x:s},backend:n,attrs:{perm:c}}),u=OS(u.length,s.shape.length)),FS("min",u,o);const[d,p]=DS(h.shape,u),f=yV({inputs:{x:h},backend:n,attrs:{shape:[-1,Hf(p)]}}),m=SV(f,f.dtype,"min",n);let g;return g=yV(a?{inputs:{x:m},backend:n,attrs:{shape:LS(d,l)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},fq=hV({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:hW}),mq={kernelName:dx,backendName:"webgl",kernelFunc:fq};class gq{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,s=EU(r),i=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${i});\n      ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class xq{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,s=EU(r),i=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),o=PW("rc",r),l=PW("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const t=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const t=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${t}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${t}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${t}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${t}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${i});\n      const ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const yq={kernelName:px,backendName:"webgl",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:s,mode:i}=n,a=Sm().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xq(r.shape,s,i):new gq(r.shape,s,i);return e.runWebGLProgram(a,[r],r.dtype)}},vq=hV({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),bq={kernelName:fx,backendName:"webgl",kernelFunc:vq};class wq{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const Sq=hV({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),_q={kernelName:wg,backendName:"webgl",kernelFunc:Sq},Tq="return a - b;",Mq=hV({opSnippet:Tq,packedOpSnippet:Tq,supportsComplex:!0,cpuKernelImpl:AW}),Eq={kernelName:fy,backendName:"webgl",kernelFunc:Mq};function kq(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{dim:i}=r,a=Zf([i],s.shape),o=eq({inputs:{x:s},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=LS(o.shape,a),u=yV({inputs:{x:o},backend:n,attrs:{shape:l}}),c=Mq({inputs:{a:s,b:u},backend:n}),h=qH({inputs:{x:c},backend:n}),d=EV({inputs:{x:h},backend:n,attrs:{axis:a,keepDims:!1}}),p=yV({inputs:{x:d},backend:n,attrs:{shape:l}}),f=Sq({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const Iq={kernelName:ny,backendName:"webgl",kernelFunc:kq},Cq={kernelName:mx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{logits:s}=e,{numSamples:i,seed:a,normalized:o}=r,l=o?s:kq({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new wq(u,c,i),d=[[a]],p=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),p}},Aq={kernelName:xx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const t=n.texData.get(r.dataId),[e,s]=pW(t.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,e)}let s;return s=Sm().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new jW(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new VW(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),n.runWebGLProgram(s,[r],r.dtype)}},Rq=tT,Nq={kernelName:vx,backendName:"webgl",kernelFunc:function(t){Ay("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=Rq(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},Dq=eT,Lq={kernelName:bx,backendName:"webgl",kernelFunc:function(t){Ay("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),h=n.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=Dq(c,h,a,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},Fq=nT,Pq={kernelName:wx,backendName:"webgl",kernelFunc:function(t){Ay("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:s,scores:i}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),h=n.readSync(i.dataId),d=a,p=o,f=l,m=u,{selectedIndices:g,selectedScores:x}=Fq(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}};class $q{constructor(t,e,n,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const Oq={kernelName:_x,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:s}=e,{depth:i,onValue:a,offValue:o}=r,l=Hf(s.shape),u=new $q(l,i,a,o),c=yV({inputs:{x:s},backend:n,attrs:{shape:[l]}}),h=n.runWebGLProgram(u,[c],s.dtype);n.disposeIntermediateTensorInfo(c);const d=yV({inputs:{x:h},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(h),d}};function zq(t){const{inputs:e,backend:n}=t,{x:r}=e;if("complex64"===r.dtype){const t=RG({inputs:{input:r},backend:n}),e=zq({inputs:{x:t},backend:n}),s=jG({inputs:{input:r},backend:n}),i=zq({inputs:{x:s},backend:n}),a=nV({inputs:{real:e,imag:i},backend:n});return n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),a}return sj({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const Bq={kernelName:Ty,backendName:"webgl",kernelFunc:zq},Uq={kernelName:Sx,backendName:"webgl",kernelFunc:function t(e){const{inputs:n,backend:r}=e,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const e=RG({inputs:{input:s},backend:r}),n=t({inputs:{x:e},backend:r}),i=jG({inputs:{input:s},backend:r}),a=zq({inputs:{x:i},backend:r}),o=nV({inputs:{real:n,imag:a},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(a),o}return sj({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}},Wq={kernelName:Tx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{axis:s}=r;if(1===e.length)return KH({inputs:{input:e[0]},backend:n,attrs:{dim:s}});const i=e[0].shape,a=e[0].dtype;e.forEach((t=>{Wf(i,t.shape,"All tensors passed to stack must have matching shapes"),Uf(a===t.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=KG({inputs:e.map((t=>{const e=KH({inputs:{input:t},backend:n,attrs:{dim:s}});return o.push(e),e})),backend:n,attrs:{axis:s}});return o.forEach((t=>n.disposeIntermediateTensorInfo(t))),l}};class Vq{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,s=EU(r),i=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${i});\n      ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class Gq{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map(((e,n)=>e[0]+t[n]+e[1]));const r=t.length,s=EU(r),i=e.map((t=>t[0])).join(","),a=e.map(((e,n)=>e[0]+t[n])).join(","),o=PW("rc",r),l=PW("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let t=0,e=1===r?2:4;t<e;t++)p+=`\n        ${h[t]}\n        if (${d}) {\n          result[${t}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${t}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${i});\n      const ${s} end = ${s}(${a});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const Hq=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{paddings:i,constantValue:a}=r;if(0===Hf(s.shape)){const t=i.map(((t,e)=>t[0]+s.shape[e]+t[1]));return sj({backend:n,attrs:{shape:t,value:a,dtype:s.dtype}})}const o=Sm().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Gq(s.shape,i,a):new Vq(s.shape,i,a),l=[[a]];return n.runWebGLProgram(o,[s],s.dtype,l)},jq={kernelName:Mx,backendName:"webgl",kernelFunc:Hq},qq=hV({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Xq={kernelName:Ex,backendName:"webgl",kernelFunc:qq},Kq={kernelName:Ix,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{axis:i,keepDims:a}=r,o=s.shape.length,l=[],u=Zf(i,s.shape);let c=u;const h=PS(c,o);let d,p=s;if(null!=h&&(p=IV({inputs:{x:s},backend:n,attrs:{perm:h}}),c=OS(c.length,o),l.push(p)),FS("prod",c,o),n.shouldExecuteOnCPU([p])){const t=n.texData.get(p.dataId).values,{outVals:e,outShape:r,outDtype:s}=mW(p.shape,p.dtype,t,c);d=n.makeTensorInfo(r,s,e)}else{const[t,e]=DS(p.shape,c),r=Hf(e),i=yV({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),a=SV(i,kv(s.dtype),"prod",n);d=yV({inputs:{x:a},backend:n,attrs:{shape:t}}),l.push(i),l.push(a)}if(a){l.push(d);const t=LS(d.shape,u);d=yV({inputs:{x:d},backend:n,attrs:{shape:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),d}},Yq=t=>{const{backend:e,attrs:n}=t,{start:r,stop:s,step:i,dtype:a}=n,o=gW(r,s,i,a);return e.makeTensorInfo([o.length],a,o)},Jq={kernelName:Cx,backendName:"webgl",kernelFunc:Yq},Zq=cV({opSnippet:"return 1.0 / x;"}),Qq={kernelName:Rx,backendName:"webgl",kernelFunc:Zq},tX=cV({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),eX={kernelName:Nx,backendName:"webgl",kernelFunc:tX},nX=cV({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),rX={kernelName:Ox,backendName:"webgl",kernelFunc:nX};class sX{constructor(t,e,n,r,s){this.variableNames=["A"],this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class iX{constructor(t,e,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const aX={kernelName:Px,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:i,halfPixelCenters:a,size:o}=r,[l,u]=o,c=Sm().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new iX(s.shape,l,u,i,a):new sX(s.shape,l,u,i,a);return n.runWebGLProgram(c,[s],"float32")}};class oX{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,s]=e,[,i,a]=t,o=[n&&i>1?r-1:r,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const lX={kernelName:$x,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:i}=e,{alignCorners:a}=r,o=new oX(i.shape,s.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class uX{constructor(t,e,n,r,s){this.variableNames=["A"],this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class cX{constructor(t,e,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,o,l]=t;this.outputShape=[i,e,n,l];const u=[r&&e>1?a-1:a,r&&n>1?o-1:o],c=[r&&e>1?e-1:e,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const hX={kernelName:Lx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s}=e,{alignCorners:i,halfPixelCenters:a,size:o}=r,[l,u]=o,c=Sm().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new cX(s.shape,l,u,i,a):new uX(s.shape,l,u,i,a);return n.runWebGLProgram(c,[s],s.dtype)}};class dX{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,s]=e,[,i,a]=t,o=[n&&i>1?r-1:r,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const pX={kernelName:Fx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{images:s,dy:i}=e,{alignCorners:a}=r,o=new dX(i.shape,s.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class fX{constructor(t,e){this.variableNames=["x"];const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const r=t.map(((n,r)=>(n=>-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),s=EU(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class mX{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;const r=PW("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,a=EU(n);function o(n){const r=t.map(((r,s)=>function(n,r){return-1!==e.indexOf(n)&&1!==t[n]?`${t[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(t){return o(t)}(r.slice())};\n          if(${s}){\n            result.g = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",o(t)}(r.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(t){return t[n-2]="("+t[n-2]+" + 1)",o(t)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(t){return t[n-1]="("+t[n-1]+" + 1)",t[n-2]="("+t[n-2]+" + 1)",o(t)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const gX={kernelName:zx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{dims:i}=r,a=s.shape.length,o=Zf(i,s.shape);if(0===a)return tV({inputs:{x:s},backend:n});const l=Sm().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mX(s.shape,o):new fX(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}};class xX{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=t[1],r=t[2];this.outputShape=t;let s="";s="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const yX={kernelName:Ey,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:s,fillValue:i,center:a}=e,o=n,l=new xX(r.shape,i),[u,c]=jT(a,r.shape[1],r.shape[2]),h=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,h)}},vX=cV({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),bX={kernelName:Bx,backendName:"webgl",kernelFunc:vX},wX=cV({opSnippet:"return inversesqrt(x);",cpuKernelImpl:xW}),SX={kernelName:Ux,backendName:"webgl",kernelFunc:wX};class _X{constructor(t,e,n,r,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const o=EU(s.length),l=EU(i.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const d=`getUpdates(${h})`,p=e>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${p};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const TX={kernelName:Wx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{indices:s,updates:i}=e,{shape:a}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=eM(0,s,a),d=[h/u,u];if(0===h)return n.makeTensorInfo(a,s.dtype);const p=yV({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=yV({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new _X(l,o,p.shape.length,f.shape.length,c,d),x=n.runWebGLProgram(g,[f,p,m],f.dtype),y=yV({inputs:{x},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(m),y}};class MX{constructor(t,e,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,i=2===Sm().getNumber("WEBGL_VERSION")?"while (left < right) {":s,a="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${a} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const EX={kernelName:Vx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:s,values:i}=e,{side:a}=r,o=new MX(s.shape[0],s.shape[1],i.shape[1],a),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,i],"int32",l)}};class kX{constructor(t,e,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=e,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let r=0;r<e.length;r++)a.push(`${n[r]}`),r<t&&i.push(`${n[r]}`);r=i.join(),s=a.join()}const i=EU(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const IX={kernelName:Gx,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{condition:r,t:s,e:i}=e,a=new kX(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(a,[r,s,i],Ev(s.dtype,i.dtype))}},CX=cV({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${nM};\n  float scale = ${rM};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),AX={kernelName:Hx,backendName:"webgl",kernelFunc:CX},RX=cV({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:vW}),NX={kernelName:Yx,backendName:"webgl",kernelFunc:RX},DX=cV({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),LX={kernelName:Kx,backendName:"webgl",kernelFunc:DX},FX=cV({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),PX={kernelName:qx,backendName:"webgl",kernelFunc:FX},$X=cV({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),OX={kernelName:Xx,backendName:"webgl",kernelFunc:$X},zX=cV({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),BX={kernelName:Jx,backendName:"webgl",kernelFunc:zX},UX={kernelName:ty,backendName:"webgl",kernelFunc:t=>{const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{blockShape:i,paddings:a}=r;Uf(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=i.reduce(((t,e)=>t*e)),l=[[0,0]];l.push(...a);for(let t=1+i.length;t<s.shape.length;++t)l.push([0,0]);const u=[],c=Hq({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),h=qT(c.shape,i,o,!1),d=XT(h.length,i.length,!1),p=KT(c.shape,i,o,!1),f=yV({inputs:{x:c},backend:n,attrs:{shape:h}}),m=IV({inputs:{x:f},backend:n,attrs:{perm:d}}),g=yV({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((t=>n.disposeIntermediateTensorInfo(t))),g}},WX={kernelName:ry,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{indices:r,values:s,denseShape:i,defaultValue:a}=e;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(i.dataId),c=n.readSync(a.dataId)[0],[h,d,p,f,m]=SW(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((t=>Number(t))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},VX={kernelName:sy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:s,newShape:i}=e;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(i.dataId)),[u,c,h]=_W(o,r.shape,r.dtype,a,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}},GX={kernelName:iy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const a=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(i.dataId),[u,c]=TW(a,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},HX={kernelName:ay,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n}=t,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const a=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(i.dataId),[u,c]=TW(a,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},jX={kernelName:oy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:s,sparseValues:i,defaultValue:a}=e,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=eM(0,s,o);if("string"===i.dtype){const t=n.bufferSync(s),e=n.bufferSync(i),r=sv(n.readSync(a.dataId)[0]),p=yW(t,e,o,d,c,u,l,h,r,!1);return n.makeTensorInfo(o,p.dtype,p.values)}const p=new _X(u,l,s.shape.length,i.shape.length,h,[d,1],!1),f=n.runWebGLProgram(p,[i,s,a],i.dtype),m=yV({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),m}},qX={kernelName:ey,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{numOrSizeSplits:i,axis:a}=r,o=Zf(a,s.shape)[0],l=MM(s,i,o),u=s.shape.length,c=new Array(u).fill(0),h=s.shape.slice();return l.map((t=>{const e=[...h];e[o]=t;const r=TG({inputs:{x:s},backend:n,attrs:{begin:c,size:e}});return c[o]+=t,r}))}},XX="return sqrt(x);",KX=cV({opSnippet:XX,packedOpSnippet:XX,cpuKernelImpl:MW}),YX={kernelName:Zx,backendName:"webgl",kernelFunc:KX},JX={kernelName:uy,backendName:"webgl",kernelFunc:cV({opSnippet:"return x * x;"})},ZX="return (a - b) * (a - b);",QX=hV({opSnippet:ZX,packedOpSnippet:ZX}),tK={kernelName:ly,backendName:"webgl",kernelFunc:QX},eK={kernelName:My,backendName:"webgl",kernelFunc:function({inputs:t,attrs:e,backend:n}){const{x:r}=t,s=`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${e.alpha});\n  `,i=new VW(r.shape,s);return n.runWebGLProgram(i,[r],r.dtype)}};class nK{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=EU(n.length),i=EU(n.length);let a="";if(1===r)a="coords * strides + begin";else{let t=0;a=n.map(((e,r)=>(t++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${t-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${t});\n      ${s} strides = ${s}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const rK={kernelName:cy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{begin:i,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:x,begin:y,end:v,strides:b}=nw(s.shape,i,a,o,l,u,c,h,d);let w;if(m)w=yV({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||x){Uf(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const t=Vb(y,v,b),e=TG({inputs:{x:s},backend:n,attrs:{begin:y,size:t}});w=yV({inputs:{x:e},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(e)}else if(n.shouldExecuteOnCPU([s])){const t=n.readSync(s.dataId),e=Ib(s.shape,s.dtype,t),r=EW(p,e,b,y);w=n.makeTensorInfo(f,s.dtype,r.values)}else{const t=new nK(y,b,p);w=n.runWebGLProgram(t,[s],s.dtype)}const S=yV({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),S}},sK={kernelName:hy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{separator:s,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=e,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=kW(d,p,s,i,a,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},iK={kernelName:dy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:s}=r,{input:i,delimiter:a}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=n.readSync(i.dataId),l=n.readSync(a.dataId)[0],[u,c,h]=IW(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},aK={kernelName:py,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:s}=r,{input:i}=e;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=n.readSync(i.dataId),o=CW(a,s);return n.makeTensorInfo(i.shape,"int32",o)}},oK=cV({opSnippet:"return tan(x);"}),lK={kernelName:my,backendName:"webgl",kernelFunc:oK},uK=cV({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),cK={kernelName:gy,backendName:"webgl",kernelFunc:uK};class hK{constructor(t,e){this.variableNames=["A"];const n=new Array(t.length);for(let r=0;r<n.length;r++)n[r]=t[r]*e[r];this.outputShape=n,this.rank=n.length;const r=EU(this.rank),s=function(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let e=0;e<t.length;e++)r.push(`imod(${n[e]}, ${t[e]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function dK(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{reps:i}=r;if("string"===s.dtype||s.shape.length>5){const t=n.readSync(s.dataId),e="string"===s.dtype?t.map((t=>sv(t))):t,r=Ib(s.shape,s.dtype,e),a=RW(r,i);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const a=new hK(s.shape,i);return n.runWebGLProgram(a,[s],s.dtype)}const pK={kernelName:xy,backendName:"webgl",kernelFunc:dK};class fK{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class mK{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function gK(t,e){null!==e&&t.disposeIntermediateTensorInfo(e)}function xK(t){let e=1;for(;e<t;)e*=2;return e}const yK={kernelName:yy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s}=e,{k:i,sorted:a}=r,o=Sm().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Sm().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||i>l){const t=n.readSync(s.dataId),[e,r]=NW(t,u,s.dtype,i,a);return[n.makeTensorInfo(e.shape,e.dtype,e.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===i)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[s,sj({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(s):s,f=Hf(u)/c,m=yV({inputs:{x:p},attrs:{shape:[f,c]},backend:n});d&&gK(n,p);const g=xK(i),x=xK(c);let y=null;const v=()=>null===y?[m,m]:[m,y],b=(t,e,r)=>{const s=v(),i=new fK(r),a=[[c],[null===y?1:0],[Number.NEGATIVE_INFINITY],[t],[e]],o=y;y=n.runWebGLProgram(i,s,"int32",a),gK(n,o)};for(let t=1;t<g;t*=2){const e=2*t;for(let n=t;n>=1;n/=2)b(e,n,[f,x])}for(let t=x;t>g;t/=2){const e=v(),r=new mK([f,t/2]),s=[[c],[null===y?1:0],[g]],i=y;y=n.runWebGLProgram(r,e,"int32",s),gK(n,i);const a=g/2,o=2*a;for(let t=a;t>=1;t/=2)b(o,t,y.shape)}let w=y;y=TG({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,i]}}),gK(n,w);let S=Sj({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});gK(n,m);const _=u.slice(0,-1);_.push(i),w=y,y=yV({inputs:{x:y},attrs:{shape:_},backend:n}),gK(n,w);const T=S;return S=yV({inputs:{x:S},attrs:{shape:_},backend:n}),gK(n,T),[S,y]}};class vK{constructor(t,e,n,r,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const bK={kernelName:vy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{image:s,transforms:i}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=r,[c,h,d,p]=s.shape,[f,m]=null!=u?u:[h,d],g=new vK(h,d,a,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[s,i],"float32")}},wK={kernelName:wy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,attrs:n,backend:r}=t,{axis:s}=n,{x:i}=e;uU(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(i.dataId),{outputValues:o,outputShape:l,indices:u}=LW(a,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},SK={kernelName:Sy,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const a=s,o=a.shape.length,l=s.shape[i],u=new Array(o-1);let c=0;for(let t=0;t<o;t++)t!==i&&(u[c++]=a.shape[t]);const h=[],d=new Array(o).fill(0),p=a.shape.slice();p[i]=1;const f=new Array(l);for(let t=0;t<f.length;t++){d[i]=t;const e=TG({inputs:{x:a},backend:n,attrs:{begin:d,size:p}}),r=yV({inputs:{x:e},backend:n,attrs:{shape:u}});f[t]=r,h.push(e)}return h.forEach((t=>n.disposeIntermediateTensorInfo(t))),f}};class _K{constructor(t,e){this.variableNames=["x","segmentIds"];const n=t.windowSize,r=t.batchSize,s=t.inSize,i=t.numSegments,a=i*Math.ceil(s/n);this.outputShape=[r,a];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const TK=[RV,DV,FV,$V,BV,VV,GV,HV,JV,ZV,tG,nG,sG,aG,lG,hG,dG,mG,gG,xG,bG,EG,kG,IG,DG,PG,zG,rV,WG,YG,nH,oH,lH,uH,cH,hH,pH,mH,xH,_H,TH,MH,kH,AH,DH,LH,PH,OH,zH,UH,WH,GH,jH,XH,YH,QH,nj,ij,oj,cj,dj,mj,xj,yj,bj,_j,Mj,kj,eV,Ij,qG,Aj,Nj,Lj,aV,Pj,Oj,zj,Uj,Vj,Hj,qj,Kj,Zj,tq,nq,sq,iq,aq,uq,cq,hq,dq,pq,mq,yq,bq,Cq,xV,Aq,Nq,Lq,Pq,AG,Oq,Uq,Wq,jq,Xq,uV,Kq,Jq,NG,_q,Qq,eX,rX,vV,aX,lX,hX,pX,gX,yX,bX,SX,TX,EX,IX,AX,NX,LX,PX,OX,MG,Iq,BX,UX,WX,VX,GX,HX,jX,qX,YX,JX,tK,eK,rK,sK,iK,aK,Eq,kV,lK,cK,pK,yK,bK,CV,wK,SK,{kernelName:_y,backendName:"webgl",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{x:s,segmentIds:i}=e,{numSegments:a}=r,o=s.shape.length,l=[];let u=0;const c=PS([u],o);let h=s;null!=c&&(h=IV({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(h),u=OS(1,o)[0]);const d=zM(h.shape,u,a),p=Hf([h.shape[u]]),f=yV({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=kv(s.dtype),g=(t,e,r,s,i)=>{const a=t.shape[0],o=t.shape[1],u=OM(o,i),c=new _K({windowSize:u,inSize:o,batchSize:a,numSegments:i},e),h=n.compileAndRun(c,[t,r],s);if(l.push(h),h.shape[1]===i)return h;const d=Yq({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),p=dK({inputs:{x:d},backend:n,attrs:{reps:[o/u]}});return l.push(d),l.push(p),g(h,e,p,s,i)},x=yV({inputs:{x:g(f,"unsortedSegmentSum",i,m,a)},backend:n,attrs:{shape:d}});let y=x;if(null!=c){l.push(x);const t=$S(c);y=IV({inputs:{x:y},backend:n,attrs:{perm:t}})}return l.forEach((t=>n.disposeIntermediateTensorInfo(t))),y}},Bq];for(const t of TK)$y(t);const MK=(t,e,n,r=0)=>{const s=((t,e,n,r=0)=>({x:t[0][0]*e+t[0][1]*n+t[0][3],y:t[1][0]*e+t[1][1]*n+t[1][3],z:t[2][0]*e+t[2][1]*n+t[2][3]}))(t,e,n,r),{x:i,y:a,z:o}=s;return{x:i/o,y:a/o}},EK=(t,e,n,r,s,i,a,o)=>({variableNames:["features","markerPixels","markerProperties","targetPixels"],outputShape:[o,s*s],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int featureIndex = coords[0];\n\t    int searchOffsetIndex = coords[1];\n\n\t    int markerWidth = int(getMarkerProperties(0));\n\t    int markerHeight = int(getMarkerProperties(1));\n\t    float markerScale = getMarkerProperties(2);\n\n\t    int searchOffsetX = imod(searchOffsetIndex, ${s}) * ${r};\n\t    int searchOffsetY = searchOffsetIndex / ${s} * ${r};\n\n\t    int sCenterX = int(getFeatures(featureIndex, 0) * markerScale);\n\t    int sCenterY = int(getFeatures(featureIndex, 1) * markerScale);\n\n\t    int sx = sCenterX + searchOffsetX - ${n};\n\t    int sy = sCenterY + searchOffsetY - ${n};\n\n\t    if (sx < ${t} || sx >= (${a} - ${t}) || sy < ${t} || sy >= (${i} - ${t})) {\n\t      setOutput(-2.);\n\t    } \n\t    else {\n\t      float sumPoint = 0.;\n\t      float sumPointSquare = 0.;\n\t      float sumTemplate = 0.;\n\t      float sumTemplateSquare = 0.;\n\t      float sumPointTemplate = 0.;\n\n\t      for (int templateOffsetY = 0; templateOffsetY < ${e}; templateOffsetY++) {\n\t\tfor (int templateOffsetX = 0; templateOffsetX < ${e}; templateOffsetX++) {\n\t\t  int fx2 = sCenterX + templateOffsetX - ${t};\n\t\t  int fy2 = sCenterY + templateOffsetY - ${t};\n\n\t\t  int sx2 = sx + templateOffsetX - ${t};\n\t\t  int sy2 = sy + templateOffsetY - ${t};\n\n\t\t  int markerPixelIndex = fy2 * markerWidth + fx2;\n\t\t  float markerPixel = getMarkerPixels(markerPixelIndex);\n\t\t  float targetPixel = getTargetPixels(sy2, sx2);\n\n\t\t  sumTemplate += markerPixel;\n\t\t  sumTemplateSquare += markerPixel * markerPixel;\n\t\t  sumPoint += targetPixel;\n\t\t  sumPointSquare += targetPixel * targetPixel;\n\t\t  sumPointTemplate += targetPixel * markerPixel;\n\t\t}\n\t      }\n\n\t      // Normalized cross-correlation\n\t      // !important divide first avoid overflow (e.g. sumPoint / count * sumPoint)\n\t      float count = float(${e} * ${e});\n\t      float pointVariance = sqrt(sumPointSquare - sumPoint / count * sumPoint);\n\t      float templateVariance = sqrt(sumTemplateSquare - sumTemplate / count * sumTemplate);\n\n\t      if (pointVariance < 0.0000001) {\n\t\tsetOutput(-3.);\n\t      } else if (templateVariance < 0.0000001) {\n\t\t//setOutput(sumTemplate);\n\t\tsetOutput(-4.);\n\t      } else {\n\t\tsumPointTemplate -= sumPoint / count * sumTemplate;\n\t\tfloat sim = sumPointTemplate / pointVariance / templateVariance;  \n\t\tsetOutput(sim);\n\t      }\n\t    }\n\t  }\n\t`}),kK=(t,e,n,r)=>({variableNames:["featurePoints","markerProperties","maxIndex"],outputShape:[r,2],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float markerScale = getMarkerProperties(2);\n\n\t    int featureIndex = coords[0];\n\n\t    int maxIndex = int(getMaxIndex(featureIndex));\n\t    int searchLocationIndex = maxIndex / ${n*n};\n\t    int searchOffsetIndex = imod(maxIndex, ${n*n});\n\n\t    if (coords[1] == 0) {\n\t      int searchOffsetX = imod(searchOffsetIndex, ${n}) * ${e};\n\t      setOutput(getFeaturePoints(featureIndex, 0) + float(searchOffsetX - ${t}) / markerScale);\n\t    }\n\t    else if (coords[1] == 1) {\n\t      int searchOffsetY = searchOffsetIndex / ${n} * ${e};\n\t      setOutput(getFeaturePoints(featureIndex, 1) + float(searchOffsetY - ${t}) / markerScale);\n\t    }\n\t  }\n\t`}),IK=t=>({variableNames:["sims","maxIndex"],outputShape:[t],userCode:"\n\t  void main() {\n\t    int featureIndex = getOutputCoords();\n\t    int maxIndex = int(getMaxIndex(featureIndex));\n\t    setOutput(getSims(featureIndex, maxIndex));\n\t  }\n\t"}),CK=(t,e)=>({variableNames:["p"],outputShape:[t,e],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float sum = getP(coords[0], coords[1]-2);\n\t    sum += getP(coords[0], coords[1]-1) * 4.;\n\t    sum += getP(coords[0], coords[1]) * 6.;\n\t    sum += getP(coords[0], coords[1]+1) * 4.;\n\t    sum += getP(coords[0], coords[1]+2);\n\t    setOutput(sum);\n\t  }\n\t"}),AK=(t,e)=>({variableNames:["p"],outputShape:[t,e],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    float sum = getP(coords[0]-2, coords[1]);\n\t    sum += getP(coords[0]-1, coords[1]) * 4.;\n\t    sum += getP(coords[0], coords[1]) * 6.;\n\t    sum += getP(coords[0]+1, coords[1]) * 4.;\n\t    sum += getP(coords[0]+2, coords[1]);\n\t    sum /= 256.;\n\t    setOutput(sum);\n\t  }\n\t"}),RK=[{sigma:.55,points:[[-1,0],[-.5,-.866025],[.5,-.866025],[1,-0],[.5,.866025],[-.5,.866025]]},{sigma:.475,points:[[0,.930969],[-.806243,.465485],[-.806243,-.465485],[-0,-.930969],[.806243,-.465485],[.806243,.465485]]},{sigma:.4,points:[[.847306,-0],[.423653,.733789],[-.423653,.733789],[-.847306,0],[-.423653,-.733789],[.423653,-.733789]]},{sigma:.325,points:[[-0,-.741094],[.641806,-.370547],[.641806,.370547],[0,.741094],[-.641806,.370547],[-.641806,-.370547]]},{sigma:.25,points:[[-.595502,0],[-.297751,-.51572],[.297751,-.51572],[.595502,-0],[.297751,.51572],[-.297751,.51572]]},{sigma:.175,points:[[0,.362783],[-.314179,.181391],[-.314179,-.181391],[-0,-.362783],[.314179,-.181391],[.314179,.181391]]},{sigma:.1,points:[[0,0]]}],NK=[];for(let t=0;t<RK.length;t++){const e=RK[t].sigma;for(let n=0;n<RK[t].points.length;n++){const r=RK[t].points[n];NK.push([e,r[0],r[1]])}}const DK=NK,LK=(DK.length-1)*DK.length/2,FK=1/(2*Math.PI),PK=t=>{const e=[];for(let n=1;n<t.length;n++)e.push("image"+n);return e},$K=t=>{let e="float getPixel(int octave, int y, int x) {";for(let n=1;n<t.length;n++)e+=`\n\t  if (octave == ${n}) {\n\t    return getImage${n}(y, x);\n\t  }\n\t`;return e+="}",e},OK=(t,e,n,r)=>{const s=PK(t),i=$K(t);return{variableNames:[...s,"extrema","radial"],outputShape:[e.shape[0],n.shape[0],2],userCode:`\n\t  ${i}\n\n\t  void main() {\n\t    ivec3 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int radialIndex = coords[1];\n\t    int propertyIndex = coords[2];\n\n\t    int radialY = int(getRadial(radialIndex, 0));\n\t    int radialX = int(getRadial(radialIndex, 1));\n\t    float radialW = getRadial(radialIndex, 2);\n\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    int y = int(getExtrema(featureIndex, 2));\n\t    int x = int(getExtrema(featureIndex, 3));\n\n\t    int xp = x + radialX;\n\t    int yp = y + radialY;\n\n\t    float dy = getPixel(octave, yp+1, xp) - getPixel(octave, yp-1, xp);\n\t    float dx = getPixel(octave, yp, xp+1) - getPixel(octave, yp, xp-1);\n\n\t    if (propertyIndex == 0) {\n\t      // be careful that atan(0, 0) gives 1.57 instead of 0 (different from js), but doesn't matter here, coz magnitude is 0\n\t      \n\t      float angle = atan(dy, dx) + ${Math.PI};\n\t      float fbin = angle * 36. * ${r};\n\t      setOutput(fbin);\n\t      return;\n\t    }\n\n\t    if (propertyIndex == 1) {\n\t      float mag = sqrt(dx * dx + dy * dy);\n\t      float magnitude = radialW * mag;\n\t      setOutput(magnitude);\n\t      return;\n\t    }\n\t  }\n\n\t`}},zK=(t,e)=>({variableNames:["fbinMag"],outputShape:[t.shape[0],36],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int binIndex = coords[1];\n\n\t    float sum = 0.;\n\t    for (int i = 0; i < ${e.shape[0]}; i++) {\n\t      float fbin = getFbinMag(featureIndex, i, 0);\n\t      int bin = int(floor(fbin - 0.5));\n\t      int b1 = imod(bin + 36, 36);\n\t      int b2 = imod(bin + 1 + 36, 36);\n\n\t      if (b1 == binIndex || b2 == binIndex) {\n\t\tfloat magnitude = getFbinMag(featureIndex, i, 1);\n\t\tfloat w2 = fbin - float(bin) - 0.5;\n\t\tfloat w1 = w2 * -1. + 1.;\n\n\t\tif (b1 == binIndex) {\n\t\t  sum += w1 * magnitude;\n\t\t}\n\t\tif (b2 == binIndex) {\n\t\t  sum += w2 * magnitude;\n\t\t}\n\t      }\n\t    }\n\t    setOutput(sum);\n\t  }\n\t`}),BK=t=>null==t,UK=t=>{if("object"!=typeof t||null===t)return t;const e=Array.isArray(t)?[]:{};for(const n in t){const r=t[n];e[n]=UK(r)}return e},WK=class{debugMode;width;height;numOctaves;tensorCaches;kernelCaches;constructor(t,e,n=!1){this.width=t,this.height=e,this.debugMode=n;let r=0;for(;t>=8&&e>=8&&(t/=2,e/=2,r++,5!==r););this.numOctaves=r,this.tensorCaches={},this.kernelCaches={}}detectImageData(t){const e=new Uint8ClampedArray(4*t.length);for(const[n,r]of t.entries())e[4*n]=r,e[4*n+1]=r,e[4*n+2]=r,e[4*n+3]=255;const n=new ImageData(e,this.width,this.height);return this.detect(n)}_buildPyramidImage(t){const e=[];for(let n=0;n<this.numOctaves;n++){let r;r=0===n?this._applyFilter(t):this._downsampleBilinear(e[n-1][e[n-1].length-1]);const s=this._applyFilter(r);e.push([r,s])}return e}_buildDogPyramid(t){const e=[];for(let n=0;n<this.numOctaves;n++){const r=this._differenceImageBinomial(t[n][0],t[n][1]);e.push(r)}return e}_getExtremas(t){const e=[];for(let n=1;n<this.numOctaves-1;n++){const r=this._buildExtremas(t[n-1],t[n],t[n+1]);e.push(r)}return e}_getFeaturePoints(t,e,n){const r=[];for(const[s,i]of t.entries()){if(0==i[0])continue;const t=[];for(let n=0;n<e[s].length;n+=4){const r=e[s][n]*256**3+65536*e[s][n+1]+256*e[s][n+2]+e[s][n+3];t.push(r)}const a=i[1],o=i[2],l=i[3]*Math.pow(2,a)+Math.pow(2,a-1)-.5,u=o*Math.pow(2,a)+Math.pow(2,a-1)-.5,c=Math.pow(2,a);r.push({maxima:i[0]>0,x:l,y:u,scale:c,angle:n[s],descriptors:t})}return r}detect(t){let e={};const n=this._buildPyramidImage(t),r=this._buildDogPyramid(n),s=this._getExtremas(r),i=this._applyPrune(s),a=this._computeLocalization(i,r),o=this._computeOrientationHistograms(a,n),l=this._smoothHistograms(o),u=this._computeExtremaAngles(l),c=this._computeExtremaFreak(n,a,u),h=this._computeFreakDescriptors(c),d=a.arraySync(),p=u.arraySync(),f=h.arraySync();return this.debugMode&&(e={pyramidImages:n.map((t=>t.map((t=>t.arraySync())))),dogPyramidImages:r.map((t=>t?.arraySync()??null)),extremasResults:s.map((t=>t.arraySync())),extremaAngles:u.arraySync(),prunedExtremas:i,localizedExtremas:a.arraySync()}),n.forEach((t=>t.forEach((t=>t?.dispose())))),r.forEach((t=>t?.dispose())),s.forEach((t=>t.dispose())),a.dispose(),o.dispose(),l.dispose(),u.dispose(),c.dispose(),h.dispose(),{featurePoints:this._getFeaturePoints(d,f,p),debugExtra:e}}_compileAndRun(t,e){const n=pw().compileAndRun(t,e);return ow().makeTensorFromTensorInfo(n)}_applyPrune(t){if(!this.kernelCaches.applyPrune){const e=t.map((t=>{return e=t.shape[0],n=t.shape[1],{variableNames:["extrema"],outputShape:[Math.floor(e/2),Math.floor(n/2)],userCode:"\n\t    void main() {\n\t      ivec2 coords = getOutputCoords();\n\t      int y = coords[0] * 2;\n\t      int x = coords[1] * 2;\n\n\t      float location = 0.0;\n\t      float values = getExtrema(y, x);\n\n\t      if (getExtrema(y+1, x) != 0.0) {\n\t        location = 1.0;\n\t\tvalues = getExtrema(y+1, x);\n\t      }\n\t      else if (getExtrema(y, x+1) != 0.0) {\n\t        location = 2.0;\n\t\tvalues = getExtrema(y, x+1);\n\t      }\n\t      else if (getExtrema(y+1, x+1) != 0.0) {\n\t        location = 3.0;\n\t\tvalues = getExtrema(y+1, x+1);\n\t      }\n\n\t      if (values < 0.0) {\n\t        setOutput(location * -1000.0 + values);\n\t      } else {\n\t        setOutput(location * 1000.0 + values);\n\t      }\n\t    }\n\t  "};var e,n}));this.kernelCaches.applyPrune={reductionKernels:e}}const e=[],n=[];for(let t=0;t<100;t++){n.push([]),e.push([]);for(let r=0;r<5;r++)n[t].push([0,0,0,0]),e[t].push(0)}uw((()=>{const{reductionKernels:r}=this.kernelCaches.applyPrune;for(let s=0;s<t.length;s++){const i=r[s],a=this._compileAndRun(i,[t[s]]),o=s+1,l=a.arraySync(),u=a.shape[0],c=a.shape[1],h=2*c/10,d=2*u/10;for(let t=0;t<u;t++)for(let r=0;r<c;r++){const s=l[t][r];if(0===s)continue;const i=s%1e3,a=Math.floor(Math.abs(s)/1e3),u=2*r+(2===a||3===a?1:0),c=2*t+(1===a||3===a?1:0),p=Math.floor(u/h),f=10*Math.floor(c/d)+p,m=Math.abs(i);let g=5;for(;g>=1&&m>=e[f][g-1];)g--;if(!(g>=5)){for(let t=4;t>=g+1;t--)e[f][t]=e[f][t-1],n[f][t]=UK(n[f][t-1]);e[f][g]=m,n[f][g][0]=i,n[f][g][1]=o,n[f][g][2]=c,n[f][g][3]=u}}}}));const r=[];for(let t=0;t<100;t++)for(let e=0;e<5;e++)r.push(n[t][e]);return r}_applyFilter(t){const e=t.shape[0],n=t.shape[1],r="w"+n;return this.kernelCaches.applyFilter||(this.kernelCaches.applyFilter={}),this.kernelCaches.applyFilter[r]||(this.kernelCaches.applyFilter[r]=((t,e)=>[CK(t,e),AK(t,e)])(e,n)),uw((()=>{const[e,n]=this.kernelCaches.applyFilter[r],s=this._compileAndRun(e,[t]);return this._compileAndRun(n,[s])}))}_buildExtremas(t,e,n){const r=e.shape[0],s=e.shape[1],i="w"+s;return this.kernelCaches.buildExtremas||(this.kernelCaches.buildExtremas={}),this.kernelCaches.buildExtremas[i]||(this.kernelCaches.buildExtremas[i]=((t,e)=>({variableNames:["image0","image1","image2"],outputShape:[t,e],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int y = coords[0];\n\t    int x = coords[1];\n\n\t    float value = getImage1(y, x);\n\n\t    // Step 1: find local maxima/minima\n\t    if (value * value < 9.) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    if (y < 7 || y > ${t-1-7}) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    if (x < 7 || x > ${e-1-7}) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    bool isMax = true;\n\t    bool isMin = true;\n\t    for (int dy = -1; dy <= 1; dy++) {\n\t      for (int dx = -1; dx <= 1; dx++) {\n\t        float value0 = getImage0(y+dy, x+dx);\n\t        float value1 = getImage1(y+dy, x+dx);\n\t        float value2 = getImage2(y+dy, x+dx);\n\n\t\tif (value < value0 || value < value1 || value < value2) {\n\t\t  isMax = false;\n\t\t}\n\t\tif (value > value0 || value > value1 || value > value2) {\n\t\t  isMin = false;\n\t\t}\n\t      }\n\t    }\n\n\t    if (!isMax && !isMin) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    // compute edge score and reject based on threshold\n\t    float dxx = getImage1(y, x+1) + getImage1(y, x-1) - 2. * getImage1(y, x);\n\t    float dyy = getImage1(y+1, x) + getImage1(y-1, x) - 2. * getImage1(y, x);\n\t    float dxy = 0.25 * (getImage1(y-1,x-1) + getImage1(y+1,x+1) - getImage1(y-1,x+1) - getImage1(y+1,x-1));\n\n\t    float det = (dxx * dyy) - (dxy * dxy);\n\n\t    if (abs(det) < 0.0001) { // determinant undefined. no solution\n\t      setOutput(0.);\n\t      return;\n\t    }\n\n\t    float edgeScore = (dxx + dyy) * (dxx + dyy) / det;\n\n\t    if (abs(edgeScore) >= 6.25 ) {\n\t      setOutput(0.);\n\t      return;\n\t    }\n\t    setOutput(getImage1(y,x));\n\t  }\n\t`}))(r,s)),uw((()=>{const r=this.kernelCaches.buildExtremas[i];return t=this._downsampleBilinear(t),n=this._upsampleBilinear(n,e),this._compileAndRun(r,[t,e,n])}))}_computeLocalization(t,e){return this.kernelCaches.computeLocalization||(this.kernelCaches.computeLocalization=((t,e)=>{const n=PK(t),r=$K(t);return[{variableNames:[...n,"extrema"],outputShape:[e.length,3,3],userCode:`\n\t  ${r}\n\n\t  void main() {\n\t    ivec3 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    float score = getExtrema(featureIndex, 0);\n\t    if (score == 0.0) {\n\t      return;\n\t    }\n\n\t    int dy = coords[1]-1;\n\t    int dx = coords[2]-1;\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    int y = int(getExtrema(featureIndex, 2));\n\t    int x = int(getExtrema(featureIndex, 3));\n\t    setOutput(getPixel(octave, y+dy, x+dx));\n\t  }\n\t`}]})(e,t)),uw((()=>{const n=this.kernelCaches.computeLocalization[0],r=Kv(t,[t.length,t[0].length],"int32"),s=this._compileAndRun(n,[...e.slice(1),r]).arraySync(),i=[];for(let t=0;t<s.length;t++){i.push([]);for(let e=0;e<s[t].length;e++)i[t].push([])}const a=[];for(const e of t)a.push([e[0],e[1],e[2],e[3]]);for(const[t,e]of a.entries()){if(0===e[0])continue;const n=s[t],r=.5*(n[1][2]-n[1][0]),i=.5*(n[2][1]-n[0][1]),a=n[1][2]+n[1][0]-2*n[1][1],o=n[2][1]+n[0][1]-2*n[1][1],l=.25*(n[0][0]+n[2][2]-n[0][2]-n[2][0]),u=a*o-l**2,c=(o*-r+-l*-i)/u,h=(-l*-r+a*-i)/u,d=e[2]+h,p=e[3]+c;Math.abs(u)<1e-4||(e[2]=d,e[3]=p)}return Kv(a,[a.length,a[0].length],"float32")}))}_computeOrientationHistograms(t,e){const n=[];for(let t=1;t<e.length;t++)n.push(e[t][1]);this.tensorCaches.orientationHistograms||uw((()=>{const t=Math.ceil(4.5),e=[];for(let n=-t;n<=t;n++)for(let r=-t;r<=t;r++){const t=Math.sqrt(r**2+n**2);if(t>4.5)continue;const s=Math.exp(-.05555555555555555*t**2);e.push([r,n,s])}this.tensorCaches.orientationHistograms={radialPropertiesT:hw(Kv(e,[e.length,3]))}}));const{radialPropertiesT:r}=this.tensorCaches.orientationHistograms;return this.kernelCaches.computeOrientationHistograms||(this.kernelCaches.computeOrientationHistograms=((t,e,n,r)=>[OK(t,e,n,r),zK(e,n)])(e,t,r,FK)),uw((()=>{const[e,s]=this.kernelCaches.computeOrientationHistograms,i=this._compileAndRun(e,[...n,t,r]);return this._compileAndRun(s,[i])}))}_computeExtremaAngles(t){return this.kernelCaches.computeExtremaAngles||(this.kernelCaches.computeExtremaAngles=(t=>({variableNames:["histogram"],outputShape:[t.shape[0]],userCode:`\n\t  void main() {\n\t    int featureIndex = getOutputCoords();\n\n\t    int maxIndex = 0;\n\t    for (int i = 1; i < 36; i++) {\n\t      if (getHistogram(featureIndex, i) > getHistogram(featureIndex, maxIndex)) {\n\t\tmaxIndex = i;\n\t      }\n\t    }\n\n\t    int prev = imod(maxIndex - 1 + 36, 36);\n\t    int next = imod(maxIndex + 1, 36);\n\n\t    /**\n\t     * Fit a quatratic to 3 points. The system of equations is:\n\t     *\n\t     * y0 = A*x0^2 + B*x0 + C\n\t     * y1 = A*x1^2 + B*x1 + C\n\t     * y2 = A*x2^2 + B*x2 + C\n\t     *\n\t     * This system of equations is solved for A,B,C.\n\t     */\n\t    float p10 = float(maxIndex - 1);\n\t    float p11 = getHistogram(featureIndex, prev); \n\t    float p20 = float(maxIndex);\n\t    float p21 = getHistogram(featureIndex, maxIndex); \n\t    float p30 = float(maxIndex + 1);\n\t    float p31 = getHistogram(featureIndex, next); \n\n\t    float d1 = (p30-p20)*(p30-p10);\n\t    float d2 = (p10-p20)*(p30-p10);\n\t    float d3 = p10-p20;\n\n\t    // If any of the denominators are zero then, just use maxIndex.\n            float fbin = float(maxIndex);\n\t    if ( abs(d1) > 0.00001 && abs(d2) > 0.00001 && abs(d3) > 0.00001) {\n\t      float a = p10*p10;\n\t      float b = p20*p20;\n\n\t      // Solve for the coefficients A,B,C\n\t      float A = ((p31-p21)/d1)-((p11-p21)/d2);\n\t      float B = ((p11-p21)+(A*(b-a)))/d3;\n\t      float C = p11-(A*a)-(B*p10);\n\t      fbin = -B / (2. * A);\n\t    }\n\n\t    float an = 2.0 *${Math.PI} * (fbin + 0.5) / 36. - ${Math.PI};\n\t    setOutput(an);\n\t  }\n\t`}))(t)),uw((()=>{const e=this.kernelCaches.computeExtremaAngles;return this._compileAndRun(e,[t])}))}_computeExtremaFreak(t,e,n){this.tensorCaches._computeExtremaFreak||uw((()=>{const t=Kv(DK);this.tensorCaches._computeExtremaFreak={freakPointsT:hw(t)}}));const{freakPointsT:r}=this.tensorCaches._computeExtremaFreak,s=[];for(let e=1;e<t.length;e++)s.push(t[e][1]);return this.kernelCaches._computeExtremaFreak||(this.kernelCaches._computeExtremaFreak=((t,e)=>{const n=PK(t),r=$K(t);return[{variableNames:[...n,"extrema","angles","freakPoints"],outputShape:[e.shape[0],DK.length],userCode:`\n\t  ${r}\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int freakIndex = coords[1];\n\n\t    float freakSigma = getFreakPoints(freakIndex, 0);\n\t    float freakX = getFreakPoints(freakIndex, 1);\n\t    float freakY = getFreakPoints(freakIndex, 2);\n\n\t    int octave = int(getExtrema(featureIndex, 1));\n\t    float inputY = getExtrema(featureIndex, 2);\n\t    float inputX = getExtrema(featureIndex, 3);\n\t    float inputAngle = getAngles(featureIndex);\n            float cos = 7. * cos(inputAngle);\n            float sin = 7. * sin(inputAngle);\n\n\t    float yp = inputY + freakX * sin + freakY * cos;\n\t    float xp = inputX + freakX * cos + freakY * -sin;\n\n\t    int x0 = int(floor(xp));\n\t    int x1 = x0 + 1;\n\t    int y0 = int(floor(yp));\n\t    int y1 = y0 + 1;\n\n\t    float f1 = getPixel(octave, y0, x0);\n\t    float f2 = getPixel(octave, y0, x1);\n\t    float f3 = getPixel(octave, y1, x0);\n\t    float f4 = getPixel(octave, y1, x1);\n\n\t    float x1f = float(x1);\n\t    float y1f = float(y1);\n\t    float x0f = float(x0);\n\t    float y0f = float(y0);\n\n\t    // ratio for interpolation between four neighbouring points\n\t    float value = (x1f - xp) * (y1f - yp) * f1\n\t\t\t+ (xp - x0f) * (y1f - yp) * f2\n\t\t\t+ (x1f - xp) * (yp - y0f) * f3\n\t\t\t+ (xp - x0f) * (yp - y0f) * f4;\n\n\t    setOutput(value);\n\t  }\n\t`}]})(t,e)),uw((()=>{const[t]=this.kernelCaches._computeExtremaFreak;return this._compileAndRun(t,[...s,e,n,r])}))}_computeFreakDescriptors(t){if(!this.tensorCaches.computeFreakDescriptors){const e=[],n=[];for(let r=0;r<t.shape[1];r++)for(let s=r+1;s<t.shape[1];s++)e.push(r),n.push(s);const r=Kv(e,[e.length]).cast("int32"),s=Kv(n,[n.length]).cast("int32");this.tensorCaches.computeFreakDescriptors={positionT:hw(m_([r,s],1))}}const{positionT:e}=this.tensorCaches.computeFreakDescriptors,n=Math.ceil(LK/8);return this.kernelCaches.computeFreakDescriptors||(this.kernelCaches.computeFreakDescriptors=((t,e,n)=>[{variableNames:["freak","p"],outputShape:[t.shape[0],e],userCode:`\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int featureIndex = coords[0];\n\t    int descIndex = coords[1] * 8;\n\n\t    int sum = 0;\n\t    for (int i = 0; i < 8; i++) {\n\t      if (descIndex + i >= ${n}) {\n\t\tcontinue;\n\t      }\n\n\t      int p1 = int(getP(descIndex + i, 0));\n\t      int p2 = int(getP(descIndex + i, 1));\n\n\t      float v1 = getFreak(featureIndex, p1);\n\t      float v2 = getFreak(featureIndex, p2);\n\n\t      if (v1 < v2 + 0.01) {\n\t        sum += int(pow(2.0, float(7 - i)));\n\t      }\n\t    }\n\t    setOutput(float(sum));\n\t  }\n\t`}])(t,n,LK)),uw((()=>{const[n]=this.kernelCaches.computeFreakDescriptors;return this._runWebGLProgram(n,[t,e],"int32")}))}_differenceImageBinomial(t,e){return uw((()=>t.sub(e)))}_upsampleBilinear(t,e){const n="w"+t.shape[1];return this.kernelCaches.upsampleBilinear||(this.kernelCaches.upsampleBilinear={}),this.kernelCaches.upsampleBilinear[n]||(this.kernelCaches.upsampleBilinear[n]=(r=e.shape[0],s=e.shape[1],{variableNames:["p"],outputShape:[r,s],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int j = coords[0];\n\t    int i = coords[1];\n\n\t    float sj = 0.5 * float(j) - 0.25; \n\t    float si = 0.5 * float(i) - 0.25;\n\n\t    float sj0 = floor(sj);\n\t    float sj1 = ceil(sj);\n\t    float si0 = floor(si);\n\t    float si1 = ceil(si);\n\n\t    int sj0I = int(sj0);\n\t    int sj1I = int(sj1);\n\t    int si0I = int(si0);\n\t    int si1I = int(si1);\n\n\t    float sum = 0.0;\n\t    sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);\n\t    sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);\n\t    sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);\n\t    sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);\n\t    setOutput(sum);\n\t  }\n\t"})),uw((()=>{const e=this.kernelCaches.upsampleBilinear[n];return this._compileAndRun(e,[t])}));var r,s}_downsampleBilinear(t){const e=t.shape[0],n=t.shape[1],r="w"+n;return this.kernelCaches.downsampleBilinear||(this.kernelCaches.downsampleBilinear={}),this.kernelCaches.downsampleBilinear[r]||(this.kernelCaches.downsampleBilinear[r]=((t,e)=>({variableNames:["p"],outputShape:[Math.floor(t/2),Math.floor(e/2)],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\t    int y = coords[0] * 2;\n\t    int x = coords[1] * 2;\n\n\t    float sum = getP(y, x) * 0.25;\n\t    sum += getP(y+1,x) * 0.25; \n\t    sum += getP(y, x+1) * 0.25; \n\t    sum += getP(y+1,x+1) * 0.25;\n\t    setOutput(sum);\n\t  }\n\t"}))(e,n)),uw((()=>{const e=this.kernelCaches.downsampleBilinear[r];return this._compileAndRun(e,[t])}))}_smoothHistograms(t){return this.kernelCaches.smoothHistograms||(this.kernelCaches.smoothHistograms=(t=>({variableNames:["histogram"],outputShape:[t.shape[0],36],userCode:"\n\t  void main() {\n\t    ivec2 coords = getOutputCoords();\n\n\t    int featureIndex = coords[0];\n\t    int binIndex = coords[1];\n\n\t    int prevBin = imod(binIndex - 1 + 36, 36);\n\t    int nextBin = imod(binIndex + 1, 36);\n\n            float result = 0.274068619061197 * getHistogram(featureIndex, prevBin) + 0.451862761877606 * getHistogram(featureIndex, binIndex) + 0.274068619061197 * getHistogram(featureIndex, nextBin);\n\n\t    setOutput(result);\n\t  }\n\t"}))(t)),uw((()=>{const e=this.kernelCaches.smoothHistograms;for(let n=0;n<5;n++)t=this._compileAndRun(e,[t]);return t}))}_runWebGLProgram(t,e,n){const r=pw().runWebGLProgram(t,e,n);return ow().makeTensorFromTensorInfo(r)}};var VK,GK,HK,jK=4294967295;function qK(t,e,n){var r=Math.floor(n/4294967296),s=n;t.setUint32(e,r),t.setUint32(e+4,s)}function XK(t,e){return 4294967296*t.getInt32(e)+t.getUint32(e+4)}var KK=("undefined"==typeof process||"never"!==(null===(VK=null===process||void 0===process?void 0:process.env)||void 0===VK?void 0:VK.TEXT_ENCODING))&&"undefined"!=typeof TextEncoder&&"undefined"!=typeof TextDecoder;function YK(t){for(var e=t.length,n=0,r=0;r<e;){var s=t.charCodeAt(r++);if(0!=(4294967168&s))if(0==(4294965248&s))n+=2;else{if(s>=55296&&s<=56319&&r<e){var i=t.charCodeAt(r);56320==(64512&i)&&(++r,s=((1023&s)<<10)+(1023&i)+65536)}n+=0==(4294901760&s)?3:4}else n++}return n}var JK=KK?new TextEncoder:void 0,ZK=KK?"undefined"!=typeof process&&"force"!==(null===(GK=null===process||void 0===process?void 0:process.env)||void 0===GK?void 0:GK.TEXT_ENCODING)?200:0:jK,QK=(null==JK?void 0:JK.encodeInto)?function(t,e,n){JK.encodeInto(t,e.subarray(n))}:function(t,e,n){e.set(JK.encode(t),n)};function tY(t,e,n){for(var r=e,s=r+n,i=[],a="";r<s;){var o=t[r++];if(0==(128&o))i.push(o);else if(192==(224&o)){var l=63&t[r++];i.push((31&o)<<6|l)}else if(224==(240&o)){l=63&t[r++];var u=63&t[r++];i.push((31&o)<<12|l<<6|u)}else if(240==(248&o)){var c=(7&o)<<18|(l=63&t[r++])<<12|(u=63&t[r++])<<6|63&t[r++];c>65535&&(c-=65536,i.push(c>>>10&1023|55296),c=56320|1023&c),i.push(c)}else i.push(o);i.length>=4096&&(a+=String.fromCharCode.apply(String,i),i.length=0)}return i.length>0&&(a+=String.fromCharCode.apply(String,i)),a}var eY,nY=KK?new TextDecoder:null,rY=KK?"undefined"!=typeof process&&"force"!==(null===(HK=null===process||void 0===process?void 0:process.env)||void 0===HK?void 0:HK.TEXT_DECODER)?200:0:jK,sY=function(t,e){this.type=t,this.data=e},iY=(eY=function(t,e){return eY=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n])},eY(t,e)},function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function n(){this.constructor=t}eY(t,e),t.prototype=null===e?Object.create(e):(n.prototype=e.prototype,new n)}),aY=function(t){function e(n){var r=t.call(this,n)||this,s=Object.create(e.prototype);return Object.setPrototypeOf(r,s),Object.defineProperty(r,"name",{configurable:!0,enumerable:!1,value:e.name}),r}return iY(e,t),e}(Error),oY={type:-1,encode:function(t){var e,n,r,s;return t instanceof Date?function(t){var e,n=t.sec,r=t.nsec;if(n>=0&&r>=0&&n<=17179869183){if(0===r&&n<=4294967295){var s=new Uint8Array(4);return(e=new DataView(s.buffer)).setUint32(0,n),s}var i=n/4294967296,a=4294967295&n;return s=new Uint8Array(8),(e=new DataView(s.buffer)).setUint32(0,r<<2|3&i),e.setUint32(4,a),s}return s=new Uint8Array(12),(e=new DataView(s.buffer)).setUint32(0,r),qK(e,4,n),s}((r=1e6*((e=t.getTime())-1e3*(n=Math.floor(e/1e3))),{sec:n+(s=Math.floor(r/1e9)),nsec:r-1e9*s})):null},decode:function(t){var e=function(t){var e=new DataView(t.buffer,t.byteOffset,t.byteLength);switch(t.byteLength){case 4:return{sec:e.getUint32(0),nsec:0};case 8:var n=e.getUint32(0);return{sec:4294967296*(3&n)+e.getUint32(4),nsec:n>>>2};case 12:return{sec:XK(e,4),nsec:e.getUint32(0)};default:throw new aY("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(t.length))}}(t);return new Date(1e3*e.sec+e.nsec/1e6)}},lY=function(){function t(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(oY)}return t.prototype.register=function(t){var e=t.type,n=t.encode,r=t.decode;if(e>=0)this.encoders[e]=n,this.decoders[e]=r;else{var s=1+e;this.builtInEncoders[s]=n,this.builtInDecoders[s]=r}},t.prototype.tryToEncode=function(t,e){for(var n=0;n<this.builtInEncoders.length;n++)if(null!=(r=this.builtInEncoders[n])&&null!=(s=r(t,e)))return new sY(-1-n,s);for(n=0;n<this.encoders.length;n++){var r,s;if(null!=(r=this.encoders[n])&&null!=(s=r(t,e)))return new sY(n,s)}return t instanceof sY?t:null},t.prototype.decode=function(t,e,n){var r=e<0?this.builtInDecoders[-1-e]:this.decoders[e];return r?r(t,e,n):new sY(e,t)},t.defaultCodec=new t,t}();function uY(t){return t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer?new Uint8Array(t):Uint8Array.from(t)}var cY=function(){function t(t,e,n,r,s,i,a,o){void 0===t&&(t=lY.defaultCodec),void 0===e&&(e=void 0),void 0===n&&(n=100),void 0===r&&(r=2048),void 0===s&&(s=!1),void 0===i&&(i=!1),void 0===a&&(a=!1),void 0===o&&(o=!1),this.extensionCodec=t,this.context=e,this.maxDepth=n,this.initialBufferSize=r,this.sortKeys=s,this.forceFloat32=i,this.ignoreUndefined=a,this.forceIntegerToFloat=o,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return t.prototype.getUint8Array=function(){return this.bytes.subarray(0,this.pos)},t.prototype.reinitializeState=function(){this.pos=0},t.prototype.encode=function(t){return this.reinitializeState(),this.doEncode(t,1),this.getUint8Array()},t.prototype.doEncode=function(t,e){if(e>this.maxDepth)throw new Error("Too deep objects in depth ".concat(e));null==t?this.encodeNil():"boolean"==typeof t?this.encodeBoolean(t):"number"==typeof t?this.encodeNumber(t):"string"==typeof t?this.encodeString(t):this.encodeObject(t,e)},t.prototype.ensureBufferSizeToWrite=function(t){var e=this.pos+t;this.view.byteLength<e&&this.resizeBuffer(2*e)},t.prototype.resizeBuffer=function(t){var e=new ArrayBuffer(t),n=new Uint8Array(e),r=new DataView(e);n.set(this.bytes),this.view=r,this.bytes=n},t.prototype.encodeNil=function(){this.writeU8(192)},t.prototype.encodeBoolean=function(t){!1===t?this.writeU8(194):this.writeU8(195)},t.prototype.encodeNumber=function(t){Number.isSafeInteger(t)&&!this.forceIntegerToFloat?t>=0?t<128?this.writeU8(t):t<256?(this.writeU8(204),this.writeU8(t)):t<65536?(this.writeU8(205),this.writeU16(t)):t<4294967296?(this.writeU8(206),this.writeU32(t)):(this.writeU8(207),this.writeU64(t)):t>=-32?this.writeU8(224|t+32):t>=-128?(this.writeU8(208),this.writeI8(t)):t>=-32768?(this.writeU8(209),this.writeI16(t)):t>=-2147483648?(this.writeU8(210),this.writeI32(t)):(this.writeU8(211),this.writeI64(t)):this.forceFloat32?(this.writeU8(202),this.writeF32(t)):(this.writeU8(203),this.writeF64(t))},t.prototype.writeStringHeader=function(t){if(t<32)this.writeU8(160+t);else if(t<256)this.writeU8(217),this.writeU8(t);else if(t<65536)this.writeU8(218),this.writeU16(t);else{if(!(t<4294967296))throw new Error("Too long string: ".concat(t," bytes in UTF-8"));this.writeU8(219),this.writeU32(t)}},t.prototype.encodeString=function(t){if(t.length>ZK){var e=YK(t);this.ensureBufferSizeToWrite(5+e),this.writeStringHeader(e),QK(t,this.bytes,this.pos),this.pos+=e}else e=YK(t),this.ensureBufferSizeToWrite(5+e),this.writeStringHeader(e),function(t,e,n){for(var r=t.length,s=n,i=0;i<r;){var a=t.charCodeAt(i++);if(0!=(4294967168&a)){if(0==(4294965248&a))e[s++]=a>>6&31|192;else{if(a>=55296&&a<=56319&&i<r){var o=t.charCodeAt(i);56320==(64512&o)&&(++i,a=((1023&a)<<10)+(1023&o)+65536)}0==(4294901760&a)?(e[s++]=a>>12&15|224,e[s++]=a>>6&63|128):(e[s++]=a>>18&7|240,e[s++]=a>>12&63|128,e[s++]=a>>6&63|128)}e[s++]=63&a|128}else e[s++]=a}}(t,this.bytes,this.pos),this.pos+=e},t.prototype.encodeObject=function(t,e){var n=this.extensionCodec.tryToEncode(t,this.context);if(null!=n)this.encodeExtension(n);else if(Array.isArray(t))this.encodeArray(t,e);else if(ArrayBuffer.isView(t))this.encodeBinary(t);else{if("object"!=typeof t)throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(t)));this.encodeMap(t,e)}},t.prototype.encodeBinary=function(t){var e=t.byteLength;if(e<256)this.writeU8(196),this.writeU8(e);else if(e<65536)this.writeU8(197),this.writeU16(e);else{if(!(e<4294967296))throw new Error("Too large binary: ".concat(e));this.writeU8(198),this.writeU32(e)}var n=uY(t);this.writeU8a(n)},t.prototype.encodeArray=function(t,e){var n=t.length;if(n<16)this.writeU8(144+n);else if(n<65536)this.writeU8(220),this.writeU16(n);else{if(!(n<4294967296))throw new Error("Too large array: ".concat(n));this.writeU8(221),this.writeU32(n)}for(var r=0,s=t;r<s.length;r++){var i=s[r];this.doEncode(i,e+1)}},t.prototype.countWithoutUndefined=function(t,e){for(var n=0,r=0,s=e;r<s.length;r++)void 0!==t[s[r]]&&n++;return n},t.prototype.encodeMap=function(t,e){var n=Object.keys(t);this.sortKeys&&n.sort();var r=this.ignoreUndefined?this.countWithoutUndefined(t,n):n.length;if(r<16)this.writeU8(128+r);else if(r<65536)this.writeU8(222),this.writeU16(r);else{if(!(r<4294967296))throw new Error("Too large map object: ".concat(r));this.writeU8(223),this.writeU32(r)}for(var s=0,i=n;s<i.length;s++){var a=i[s],o=t[a];this.ignoreUndefined&&void 0===o||(this.encodeString(a),this.doEncode(o,e+1))}},t.prototype.encodeExtension=function(t){var e=t.data.length;if(1===e)this.writeU8(212);else if(2===e)this.writeU8(213);else if(4===e)this.writeU8(214);else if(8===e)this.writeU8(215);else if(16===e)this.writeU8(216);else if(e<256)this.writeU8(199),this.writeU8(e);else if(e<65536)this.writeU8(200),this.writeU16(e);else{if(!(e<4294967296))throw new Error("Too large extension object: ".concat(e));this.writeU8(201),this.writeU32(e)}this.writeI8(t.type),this.writeU8a(t.data)},t.prototype.writeU8=function(t){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,t),this.pos++},t.prototype.writeU8a=function(t){var e=t.length;this.ensureBufferSizeToWrite(e),this.bytes.set(t,this.pos),this.pos+=e},t.prototype.writeI8=function(t){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,t),this.pos++},t.prototype.writeU16=function(t){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,t),this.pos+=2},t.prototype.writeI16=function(t){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,t),this.pos+=2},t.prototype.writeU32=function(t){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,t),this.pos+=4},t.prototype.writeI32=function(t){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,t),this.pos+=4},t.prototype.writeF32=function(t){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,t),this.pos+=4},t.prototype.writeF64=function(t){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,t),this.pos+=8},t.prototype.writeU64=function(t){this.ensureBufferSizeToWrite(8),function(t,e,n){var r=n/4294967296,s=n;t.setUint32(e,r),t.setUint32(e+4,s)}(this.view,this.pos,t),this.pos+=8},t.prototype.writeI64=function(t){this.ensureBufferSizeToWrite(8),qK(this.view,this.pos,t),this.pos+=8},t}(),hY={};function dY(t){return"".concat(t<0?"-":"","0x").concat(Math.abs(t).toString(16).padStart(2,"0"))}var pY=function(){function t(t,e){void 0===t&&(t=16),void 0===e&&(e=16),this.maxKeyLength=t,this.maxLengthPerKey=e,this.hit=0,this.miss=0,this.caches=[];for(var n=0;n<this.maxKeyLength;n++)this.caches.push([])}return t.prototype.canBeCached=function(t){return t>0&&t<=this.maxKeyLength},t.prototype.find=function(t,e,n){t:for(var r=0,s=this.caches[n-1];r<s.length;r++){for(var i=s[r],a=i.bytes,o=0;o<n;o++)if(a[o]!==t[e+o])continue t;return i.str}return null},t.prototype.store=function(t,e){var n=this.caches[t.length-1],r={bytes:t,str:e};n.length>=this.maxLengthPerKey?n[Math.random()*n.length|0]=r:n.push(r)},t.prototype.decode=function(t,e,n){var r=this.find(t,e,n);if(null!=r)return this.hit++,r;this.miss++;var s=tY(t,e,n),i=Uint8Array.prototype.slice.call(t,e,e+n);return this.store(i,s),s},t}(),fY=function(t,e){var n,r,s,i,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function o(i){return function(o){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(s=2&i[0]?r.return:i[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,i[1])).done)return s;switch(r=0,s&&(i=[2&i[0],s.value]),i[0]){case 0:case 1:s=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,r=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!((s=(s=a.trys).length>0&&s[s.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!s||i[1]>s[0]&&i[1]<s[3])){a.label=i[1];break}if(6===i[0]&&a.label<s[1]){a.label=s[1],s=i;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(i);break}s[2]&&a.ops.pop(),a.trys.pop();continue}i=e.call(t,a)}catch(t){i=[6,t],r=0}finally{n=s=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,o])}}},mY=function(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t="function"==typeof __values?__values(t):t[Symbol.iterator](),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(n){e[n]=t[n]&&function(e){return new Promise((function(r,s){!function(t,e,n,r){Promise.resolve(r).then((function(e){t({value:e,done:n})}),e)}(r,s,(e=t[n](e)).done,e.value)}))}}},gY=function(t){return this instanceof gY?(this.v=t,this):new gY(t)},xY=function(t,e,n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,s=n.apply(t,e||[]),i=[];return r={},a("next"),a("throw"),a("return"),r[Symbol.asyncIterator]=function(){return this},r;function a(t){s[t]&&(r[t]=function(e){return new Promise((function(n,r){i.push([t,e,n,r])>1||o(t,e)}))})}function o(t,e){try{(n=s[t](e)).value instanceof gY?Promise.resolve(n.value.v).then(l,u):c(i[0][2],n)}catch(t){c(i[0][3],t)}var n}function l(t){o("next",t)}function u(t){o("throw",t)}function c(t,e){t(e),i.shift(),i.length&&o(i[0][0],i[0][1])}},yY=new DataView(new ArrayBuffer(0)),vY=new Uint8Array(yY.buffer),bY=function(){try{yY.getInt8(0)}catch(t){return t.constructor}throw new Error("never reached")}(),wY=new bY("Insufficient data"),SY=new pY,_Y=function(){function t(t,e,n,r,s,i,a,o){void 0===t&&(t=lY.defaultCodec),void 0===e&&(e=void 0),void 0===n&&(n=jK),void 0===r&&(r=jK),void 0===s&&(s=jK),void 0===i&&(i=jK),void 0===a&&(a=jK),void 0===o&&(o=SY),this.extensionCodec=t,this.context=e,this.maxStrLength=n,this.maxBinLength=r,this.maxArrayLength=s,this.maxMapLength=i,this.maxExtLength=a,this.keyDecoder=o,this.totalPos=0,this.pos=0,this.view=yY,this.bytes=vY,this.headByte=-1,this.stack=[]}return t.prototype.reinitializeState=function(){this.totalPos=0,this.headByte=-1,this.stack.length=0},t.prototype.setBuffer=function(t){this.bytes=uY(t),this.view=function(t){if(t instanceof ArrayBuffer)return new DataView(t);var e=uY(t);return new DataView(e.buffer,e.byteOffset,e.byteLength)}(this.bytes),this.pos=0},t.prototype.appendBuffer=function(t){if(-1!==this.headByte||this.hasRemaining(1)){var e=this.bytes.subarray(this.pos),n=uY(t),r=new Uint8Array(e.length+n.length);r.set(e),r.set(n,e.length),this.setBuffer(r)}else this.setBuffer(t)},t.prototype.hasRemaining=function(t){return this.view.byteLength-this.pos>=t},t.prototype.createExtraByteError=function(t){var e=this.view,n=this.pos;return new RangeError("Extra ".concat(e.byteLength-n," of ").concat(e.byteLength," byte(s) found at buffer[").concat(t,"]"))},t.prototype.decode=function(t){this.reinitializeState(),this.setBuffer(t);var e=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return e},t.prototype.decodeMulti=function(t){return fY(this,(function(e){switch(e.label){case 0:this.reinitializeState(),this.setBuffer(t),e.label=1;case 1:return this.hasRemaining(1)?[4,this.doDecodeSync()]:[3,3];case 2:return e.sent(),[3,1];case 3:return[2]}}))},t.prototype.decodeAsync=function(t){var e,n,r,s,i,a,o,l;return i=this,a=void 0,l=function(){var i,a,o,l,u,c,h,d;return fY(this,(function(p){switch(p.label){case 0:i=!1,p.label=1;case 1:p.trys.push([1,6,7,12]),e=mY(t),p.label=2;case 2:return[4,e.next()];case 3:if((n=p.sent()).done)return[3,5];if(o=n.value,i)throw this.createExtraByteError(this.totalPos);this.appendBuffer(o);try{a=this.doDecodeSync(),i=!0}catch(t){if(!(t instanceof bY))throw t}this.totalPos+=this.pos,p.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return l=p.sent(),r={error:l},[3,12];case 7:return p.trys.push([7,,10,11]),n&&!n.done&&(s=e.return)?[4,s.call(e)]:[3,9];case 8:p.sent(),p.label=9;case 9:return[3,11];case 10:if(r)throw r.error;return[7];case 11:return[7];case 12:if(i){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return[2,a]}throw c=(u=this).headByte,h=u.pos,d=u.totalPos,new RangeError("Insufficient data in parsing ".concat(dY(c)," at ").concat(d," (").concat(h," in the current buffer)"))}}))},new((o=void 0)||(o=Promise))((function(t,e){function n(t){try{s(l.next(t))}catch(t){e(t)}}function r(t){try{s(l.throw(t))}catch(t){e(t)}}function s(e){var s;e.done?t(e.value):(s=e.value,s instanceof o?s:new o((function(t){t(s)}))).then(n,r)}s((l=l.apply(i,a||[])).next())}))},t.prototype.decodeArrayStream=function(t){return this.decodeMultiAsync(t,!0)},t.prototype.decodeStream=function(t){return this.decodeMultiAsync(t,!1)},t.prototype.decodeMultiAsync=function(t,e){return xY(this,arguments,(function(){var n,r,s,i,a,o,l,u,c;return fY(this,(function(h){switch(h.label){case 0:n=e,r=-1,h.label=1;case 1:h.trys.push([1,13,14,19]),s=mY(t),h.label=2;case 2:return[4,gY(s.next())];case 3:if((i=h.sent()).done)return[3,12];if(a=i.value,e&&0===r)throw this.createExtraByteError(this.totalPos);this.appendBuffer(a),n&&(r=this.readArraySize(),n=!1,this.complete()),h.label=4;case 4:h.trys.push([4,9,,10]),h.label=5;case 5:return[4,gY(this.doDecodeSync())];case 6:return[4,h.sent()];case 7:return h.sent(),0==--r?[3,8]:[3,5];case 8:return[3,10];case 9:if(!((o=h.sent())instanceof bY))throw o;return[3,10];case 10:this.totalPos+=this.pos,h.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return l=h.sent(),u={error:l},[3,19];case 14:return h.trys.push([14,,17,18]),i&&!i.done&&(c=s.return)?[4,gY(c.call(s))]:[3,16];case 15:h.sent(),h.label=16;case 16:return[3,18];case 17:if(u)throw u.error;return[7];case 18:return[7];case 19:return[2]}}))}))},t.prototype.doDecodeSync=function(){t:for(;;){var t=this.readHeadByte(),e=void 0;if(t>=224)e=t-256;else if(t<192)if(t<128)e=t;else if(t<144){if(0!=(r=t-128)){this.pushMapState(r),this.complete();continue t}e={}}else if(t<160){if(0!=(r=t-144)){this.pushArrayState(r),this.complete();continue t}e=[]}else{var n=t-160;e=this.decodeUtf8String(n,0)}else if(192===t)e=null;else if(194===t)e=!1;else if(195===t)e=!0;else if(202===t)e=this.readF32();else if(203===t)e=this.readF64();else if(204===t)e=this.readU8();else if(205===t)e=this.readU16();else if(206===t)e=this.readU32();else if(207===t)e=this.readU64();else if(208===t)e=this.readI8();else if(209===t)e=this.readI16();else if(210===t)e=this.readI32();else if(211===t)e=this.readI64();else if(217===t)n=this.lookU8(),e=this.decodeUtf8String(n,1);else if(218===t)n=this.lookU16(),e=this.decodeUtf8String(n,2);else if(219===t)n=this.lookU32(),e=this.decodeUtf8String(n,4);else if(220===t){if(0!==(r=this.readU16())){this.pushArrayState(r),this.complete();continue t}e=[]}else if(221===t){if(0!==(r=this.readU32())){this.pushArrayState(r),this.complete();continue t}e=[]}else if(222===t){if(0!==(r=this.readU16())){this.pushMapState(r),this.complete();continue t}e={}}else if(223===t){if(0!==(r=this.readU32())){this.pushMapState(r),this.complete();continue t}e={}}else if(196===t){var r=this.lookU8();e=this.decodeBinary(r,1)}else if(197===t)r=this.lookU16(),e=this.decodeBinary(r,2);else if(198===t)r=this.lookU32(),e=this.decodeBinary(r,4);else if(212===t)e=this.decodeExtension(1,0);else if(213===t)e=this.decodeExtension(2,0);else if(214===t)e=this.decodeExtension(4,0);else if(215===t)e=this.decodeExtension(8,0);else if(216===t)e=this.decodeExtension(16,0);else if(199===t)r=this.lookU8(),e=this.decodeExtension(r,1);else if(200===t)r=this.lookU16(),e=this.decodeExtension(r,2);else{if(201!==t)throw new aY("Unrecognized type byte: ".concat(dY(t)));r=this.lookU32(),e=this.decodeExtension(r,4)}this.complete();for(var s=this.stack;s.length>0;){var i=s[s.length-1];if(0===i.type){if(i.array[i.position]=e,i.position++,i.position!==i.size)continue t;s.pop(),e=i.array}else{if(1===i.type){if(void 0,"string"!=(a=typeof e)&&"number"!==a)throw new aY("The type of key must be string or number but "+typeof e);if("__proto__"===e)throw new aY("The key __proto__ is not allowed");i.key=e,i.type=2;continue t}if(i.map[i.key]=e,i.readCount++,i.readCount!==i.size){i.key=null,i.type=1;continue t}s.pop(),e=i.map}}return e}var a},t.prototype.readHeadByte=function(){return-1===this.headByte&&(this.headByte=this.readU8()),this.headByte},t.prototype.complete=function(){this.headByte=-1},t.prototype.readArraySize=function(){var t=this.readHeadByte();switch(t){case 220:return this.readU16();case 221:return this.readU32();default:if(t<160)return t-144;throw new aY("Unrecognized array type byte: ".concat(dY(t)))}},t.prototype.pushMapState=function(t){if(t>this.maxMapLength)throw new aY("Max length exceeded: map length (".concat(t,") > maxMapLengthLength (").concat(this.maxMapLength,")"));this.stack.push({type:1,size:t,key:null,readCount:0,map:{}})},t.prototype.pushArrayState=function(t){if(t>this.maxArrayLength)throw new aY("Max length exceeded: array length (".concat(t,") > maxArrayLength (").concat(this.maxArrayLength,")"));this.stack.push({type:0,size:t,array:new Array(t),position:0})},t.prototype.decodeUtf8String=function(t,e){var n;if(t>this.maxStrLength)throw new aY("Max length exceeded: UTF-8 byte length (".concat(t,") > maxStrLength (").concat(this.maxStrLength,")"));if(this.bytes.byteLength<this.pos+e+t)throw wY;var r,s=this.pos+e;return r=this.stateIsMapKey()&&(null===(n=this.keyDecoder)||void 0===n?void 0:n.canBeCached(t))?this.keyDecoder.decode(this.bytes,s,t):t>rY?function(t,e,n){var r=t.subarray(e,e+n);return nY.decode(r)}(this.bytes,s,t):tY(this.bytes,s,t),this.pos+=e+t,r},t.prototype.stateIsMapKey=function(){return this.stack.length>0&&1===this.stack[this.stack.length-1].type},t.prototype.decodeBinary=function(t,e){if(t>this.maxBinLength)throw new aY("Max length exceeded: bin length (".concat(t,") > maxBinLength (").concat(this.maxBinLength,")"));if(!this.hasRemaining(t+e))throw wY;var n=this.pos+e,r=this.bytes.subarray(n,n+t);return this.pos+=e+t,r},t.prototype.decodeExtension=function(t,e){if(t>this.maxExtLength)throw new aY("Max length exceeded: ext length (".concat(t,") > maxExtLength (").concat(this.maxExtLength,")"));var n=this.view.getInt8(this.pos+e),r=this.decodeBinary(t,e+1);return this.extensionCodec.decode(r,n,this.context)},t.prototype.lookU8=function(){return this.view.getUint8(this.pos)},t.prototype.lookU16=function(){return this.view.getUint16(this.pos)},t.prototype.lookU32=function(){return this.view.getUint32(this.pos)},t.prototype.readU8=function(){var t=this.view.getUint8(this.pos);return this.pos++,t},t.prototype.readI8=function(){var t=this.view.getInt8(this.pos);return this.pos++,t},t.prototype.readU16=function(){var t=this.view.getUint16(this.pos);return this.pos+=2,t},t.prototype.readI16=function(){var t=this.view.getInt16(this.pos);return this.pos+=2,t},t.prototype.readU32=function(){var t=this.view.getUint32(this.pos);return this.pos+=4,t},t.prototype.readI32=function(){var t=this.view.getInt32(this.pos);return this.pos+=4,t},t.prototype.readU64=function(){var t,e,n=(t=this.view,e=this.pos,4294967296*t.getUint32(e)+t.getUint32(e+4));return this.pos+=8,n},t.prototype.readI64=function(){var t=XK(this.view,this.pos);return this.pos+=8,t},t.prototype.readF32=function(){var t=this.view.getFloat32(this.pos);return this.pos+=4,t},t.prototype.readF64=function(){var t=this.view.getFloat64(this.pos);return this.pos+=8,t},t}(),TY={},MY=n(6072),EY=n.n(MY);function kY(){return EY()('(()=>{"use strict";const t=class{cumsum;constructor(t,e,s){this.cumsum=[];for(let t=0;t<s;t++){this.cumsum.push([]);for(let s=0;s<e;s++)this.cumsum[t].push(0)}this.cumsum[0][0]=t[0];for(let s=1;s<e;s++)this.cumsum[0][s]=this.cumsum[0][s-1]+t[s];for(let r=1;r<s;r++)this.cumsum[r][0]=this.cumsum[r-1][0]+t[r*e];for(let r=1;r<s;r++)for(let s=1;s<e;s++)this.cumsum[r][s]=t[r*e+s]+this.cumsum[r-1][s]+this.cumsum[r][s-1]-this.cumsum[r-1][s-1]}query(t,e,s,r){let a=this.cumsum[r][s];return e>0&&(a-=this.cumsum[e-1][s]),t>0&&(a-=this.cumsum[r][t-1]),t>0&&e>0&&(a+=this.cumsum[e-1][t-1]),a}},e=t=>{const{cx:e,cy:s,image:r,imageDataCumsum:a,imageDataSqrCumsum:i,sdThresh:o}=t;if(e-6<0||e+6>=r.width)return null;if(s-6<0||s+6>=r.height)return null;const u=a.query(e-6,s-6,e+6,s+6)/169;let n=i.query(e-6,s-6,e+6,s+6);return n-=2*u*a.query(e-6,s-6,e+6,s+6),n+=169*u**2,n/169<o*o?null:(n=Math.sqrt(n),n)},s=t=>{const{cx:e,cy:s,image:r,imageDataCumsum:a,imageDataSqrCumsum:i,tx:o,ty:u,vlen:n}=t,{data:m,width:h,height:l}=r;if(e-6<0||e+6>=h)return null;if(s-6<0||s+6>=l)return null;const c=a.query(e-6,s-6,e+6,s+6),f=i.query(e-6,s-6,e+6,s+6);let g=0,d=(s-6)*h+(e-6),y=(u-6)*h+(o-6);const M=h-13;for(let t=0;t<13;t++){for(let t=0;t<13;t++)g+=m[d]*m[y],d+=1,y+=1;d+=M,y+=M}g-=a.query(o-6,u-6,o+6,u+6)/169*c;let p=f-c*c/169;return 0==p?null:(p=Math.sqrt(p),1*g/(n*p))},r=r=>{const{data:a,height:i,width:o}=r,u=[o*i];for(let t=0;t<u.length;t++)u[t]=!1;const n=new Float32Array(a.length);for(let t=0;t<o;t++)n[t]=-1,n[o*(i-1)+t]=-1;for(let t=0;t<i;t++)n[t*o]=-1,n[t*o+o-1]=-1;for(let t=1;t<o-1;t++)for(let e=1;e<i-1;e++){const s=t+o*e;let r=0,i=0;for(let t=-1;t<=1;t++)r+=a[s+o*t+1]-a[s+o*t-1],i+=a[s+o+t]-a[s-o+t];r/=768,i/=768,n[s]=Math.sqrt((r*r+i*i)/2)}const m=new Uint32Array(1e3).fill(0),h=[-1,1,-o,o];for(let t=1;t<o-1;t++)for(let e=1;e<i-1;e++){const s=t+o*e;let r=!0;for(let t=0;t<h.length;t++)if(n[s]<=n[s+h[t]]){r=!1;break}if(r){let t=Math.floor(1e3*n[s]);t>999&&(t=999),t<0&&(t=0),m[t]+=1,u[s]=!0}}const l=.02*o*i;let c=999,f=0;for(;c>=0&&(f+=m[c],!(f>l));)c--;for(let t=0;t<u.length;t++)u[t]&&1e3*n[t]<c&&(u[t]=!1);const g=[];for(const[t,e]of a.entries())g[t]=e**2;const d=new t(a,o,i),y=new t(g,o,i),M=new Float32Array(a.length);for(let t=0;t<o;t++)for(let a=0;a<i;a++){const i=a*o+t;if(!u[i]){M[i]=1;continue}const n=e({image:r,cx:t,cy:a,sdThresh:5,imageDataCumsum:d,imageDataSqrCumsum:y});if(null===n){M[i]=1;continue}let m=-1;for(let e=-10;e<=10;e++){for(let i=-10;i<=10;i++){if(i*i+e*e<=4)continue;const o=s({image:r,cx:t+i,cy:a+e,vlen:n,tx:t,ty:a,imageDataCumsum:d,imageDataSqrCumsum:y});if(null!==o&&o>m&&(m=o,m>.95))break}if(m>.95)break}M[i]=m}const p=(t=>{const{image:r,featureMap:a,templateSize:i,searchSize:o,maxSimThresh:u,minSimThresh:n,sdThresh:m,imageDataCumsum:h,imageDataSqrCumsum:l}=t;let{occSize:c}=t;const{data:f,width:g,height:d}=r;c=Math.floor(Math.min(r.width,r.height)/10);const y=3*(2*i+1),M=Math.floor(g/y),p=Math.floor(d/y),w=Math.floor(g/c)*Math.floor(d/c)+M*p,q=[],S=new Float32Array(f.length);for(const[t,e]of a.entries())S[t]=e;let D=0;for(;D<w;){let t=u,a=-1,f=-1;for(let e=0;e<d;e++)for(let s=0;s<g;s++)S[e*g+s]<t&&(t=S[e*g+s],a=s,f=e);if(-1===a)break;const y=e({image:r,cx:a,cy:f,sdThresh:0,imageDataCumsum:h,imageDataSqrCumsum:l});if(null===y){S[f*g+a]=1;continue}if(y/(2*i+1)<m){S[f*g+a]=1;continue}let M=1,p=-1;for(let e=-o;e<=o;e++){for(let i=-o;i<=o;i++){if(i*i+e*e>o*o)continue;if(0===i&&0===e)continue;const u=s({image:r,vlen:y,cx:a+i,cy:f+e,tx:a,ty:f,imageDataCumsum:h,imageDataSqrCumsum:l});if(null!==u){if(u<M&&(M=u,M<n&&M<t))break;if(u>p&&(p=u,p>.99))break}}if(M<n&&M<t||p>.99)break}if(M<n&&M<t||p>.99)S[f*g+a]=1;else{q.push({x:a,y:f}),D+=1;for(let t=-c;t<=c;t++)for(let e=-c;e<=c;e++)f+t<0||f+t>=d||a+e<0||a+e>=g||(S[(f+t)*g+(a+e)]=1)}}return q})({image:r,featureMap:M,templateSize:6,searchSize:2,occSize:16,maxSimThresh:.9,minSimThresh:.2,sdThresh:8,imageDataCumsum:d,imageDataSqrCumsum:y});return p},a=t=>{const e=Math.min(t.width,t.height);return[256/e,128/e].map((e=>Object.assign((({image:t,ratio:e})=>{const s=Math.round(t.width*e),r=Math.round(t.height*e),a=new Uint8Array(s*r);for(let i=0;i<s;i++){const o=Math.round(1*i/e);let u=Math.round(1*(i+1)/e)-1;u>=t.width&&(u=t.width-1);for(let n=0;n<r;n++){const r=Math.round(1*n/e);let m=Math.round(1*(n+1)/e)-1;m>=t.height&&(m=t.height-1);let h=0,l=0;for(let e=o;e<=u;e++)for(let s=r;s<=m;s++)h+=1*t.data[s*t.width+e],l+=1;a[n*s+i]=Math.floor(h/l)}}return{data:a,width:s,height:r}})({image:t,ratio:e}),{scale:e})))},i=(t,e)=>{const s=[];for(const[a,i]of t.entries()){const t=r(i),o={data:i.data,scale:i.scale,width:i.width,height:i.height,points:t};s.push(o),e(a)}return s};onmessage=t=>{const{data:e}=t;if("compile"===e.type){const{targetImages:t}=e,s=50/t.length;let r=0;const o=[];for(const e of t){const t=a(e),u=s/t.length,n=i(t,(()=>{r+=u,postMessage({type:"progress",percent:r})}));o.push(n)}postMessage({type:"compileDone",list:o})}}})();',"Worker",void 0,void 0)}const IY=({image:t,ratio:e})=>{const n=Math.round(t.width*e),r=Math.round(t.height*e),s=new Uint8Array(n*r);for(let i=0;i<n;i++){const a=Math.round(1*i/e);let o=Math.round(1*(i+1)/e)-1;o>=t.width&&(o=t.width-1);for(let l=0;l<r;l++){const r=Math.round(1*l/e);let u=Math.round(1*(l+1)/e)-1;u>=t.height&&(u=t.height-1);let c=0,h=0;for(let e=a;e<=o;e++)for(let n=r;n<=u;n++)c+=1*t.data[n*t.width+e],h+=1;s[l*n+i]=Math.floor(c/h)}}return{data:s,width:n,height:r}},CY=t=>{const e=[];let n=100/Math.min(t.width,t.height);for(;;)if(e.push(n),n*=Math.pow(2,1/3),n>=.95){n=1;break}e.push(n),e.reverse();const r=e.map((e=>Object.assign(IY({image:t,ratio:e}),{scale:e})));return r},AY=t=>{const e=Math.min(t.width,t.height),n=[256/e,128/e].map((e=>Object.assign(IY({image:t,ratio:e}),{scale:e})));return n},RY=t=>{let e=t-(t>>1&1431655765);return e=(e>>2&858993459)+(858993459&e),e=(e>>4)+e&252645135,e=(e>>8)+e&16711935,e=(e>>16)+e&65535,e},NY=t=>{const{v1:e,v2:n}=t;let r=0;for(let t=0;t<e.length;t++){const s=(e[t]^n[t])>>>0;r+=RY(s)}return r},DY=()=>{const t={seed:1234,arrayShuffle(t){const{arr:e,sampleSize:n}=t;for(let t=0;t<n;t++){this.seed=(214013*this.seed+2531011)%(1<<31);let n=this.seed>>16&32767;n%=e.length;const r=e[t];e[t]=e[n],e[n]=r}},nextInt(t){this.seed=(214013*this.seed+2531011)%(1<<31);let e=this.seed>>16&32767;return e%=t,e}};return t},LY=t=>{const{points:e,pointIndexes:n,centerPointIndex:r,randomizer:s}=t;let i=!1;(n.length<=8||n.length<=16)&&(i=!0);const a={};if(!i){const t=(t=>{const{points:e,pointIndexes:n,randomizer:r}=t,s=[];for(let t=0;t<n.length;t++)s.push(t);let i=Number.MAX_SAFE_INTEGER,a=-1;const o=[];for(let t=0;t<128;t++){r.arrayShuffle({arr:s,sampleSize:8});let l=0;const u=[];for(let t=0;t<n.length;t++){let r=Number.MAX_SAFE_INTEGER;for(let i=0;i<8;i++){const a=n[s[i]],o=NY({v1:e[n[t]].descriptors,v2:e[a].descriptors});o<r&&(u[t]=s[i],r=o)}l+=r}o.push(u),l<i&&(i=l,a=t)}return o[a]})({points:e,pointIndexes:n,randomizer:s});for(let e=0;e<t.length;e++)void 0===a[n[t[e]]]&&(a[n[t[e]]]=[]),a[n[t[e]]].push(n[e])}1===Object.keys(a).length&&(i=!0);const o={centerPointIndex:r};if(i){o.leaf=!0,o.pointIndexes=[];for(let t=0;t<n.length;t++)o.pointIndexes.push(n[t]);return o}return o.leaf=!1,o.children=[],Object.keys(a).forEach((t=>{o.children.push(LY({points:e,pointIndexes:a[t],centerPointIndex:+t,randomizer:s}))})),o},FY=({points:t})=>{const e=[];for(let n=0;n<t.length;n++)e.push(n);const n=DY();return{rootNode:LY({points:t,pointIndexes:e,centerPointIndex:null,randomizer:n})}},PY=(t,e)=>{const n=2*Math.PI*e*t;return n/(n+1)},$Y=(t,e,n)=>t*e+(1-t)*n,OY=class{minCutOff;beta;dCutOff;xPrev;dxPrev;tPrev;initialized;constructor({minCutOff:t,beta:e}){this.minCutOff=t,this.beta=e,this.dCutOff=.001,this.xPrev=null,this.dxPrev=null,this.tPrev=null,this.initialized=!1}reset(){this.initialized=!1}filter(t,e){if(!(this.initialized&&this.tPrev&&this.dxPrev&&this.xPrev))return this.initialized=!0,this.xPrev=e,this.dxPrev=e.map((()=>0)),this.tPrev=t,e;const{xPrev:n,tPrev:r,dxPrev:s}=this,i=t-r,a=PY(i,this.dCutOff),o=[],l=[],u=[];for(let t=0;t<e.length;t++){o[t]=(e[t]-n[t])/i,l[t]=$Y(a,o[t],s[t]);const r=this.minCutOff+this.beta*Math.abs(l[t]),c=PY(i,r);u[t]=$Y(c,e[t],n[t])}return this.xPrev=u,this.dxPrev=l,this.tPrev=t,u}};function zY(){return EY()('(()=>{"use strict";class t{constructor(t=[],r=e){if(this.data=t,this.length=this.data.length,this.compare=r,this.length>0)for(let t=(this.length>>1)-1;t>=0;t--)this._down(t)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(0===this.length)return;const t=this.data[0],e=this.data.pop();return this.length--,this.length>0&&(this.data[0]=e,this._down(0)),t}peek(){return this.data[0]}_up(t){const{data:e,compare:r}=this,o=e[t];for(;t>0;){const s=t-1>>1,n=e[s];if(r(o,n)>=0)break;e[t]=n,t=s}e[t]=o}_down(t){const{data:e,compare:r}=this,o=this.length>>1,s=e[t];for(;t<o;){let o=1+(t<<1),n=e[o];const i=o+1;if(i<this.length&&r(e[i],n)<0&&(o=i,n=e[i]),r(n,s)>=0)break;e[t]=n,t=o}e[t]=s}}function e(t,e){return t<e?-1:t>e?1:0}const r=t=>{let e=t-(t>>1&1431655765);return e=(e>>2&858993459)+(858993459&e),e=(e>>4)+e&252645135,e=(e>>8)+e&16711935,e=(e>>16)+e&65535,e},o=t=>{const{v1:e,v2:o}=t;let s=0;for(let t=0;t<e.length;t++){const n=(e[t]^o[t])>>>0;s+=r(n)}return s},s=({querypoint:t,keypoint:e,keycenterX:r,keycenterY:o,scaleOneOverLogK:s})=>{let n=t.angle-e.angle;n<=-Math.PI?n+=2*Math.PI:n>Math.PI&&(n-=2*Math.PI);const i=t.scale/e.scale,h=i*Math.cos(n),l=i*Math.sin(n),u=[h,-l,l,h],a=[u[0]*e.x+u[1]*e.y,u[2]*e.x+u[3]*e.y],c=t.x-a[0],f=t.y-a[1];return{x:u[0]*r+u[1]*o+c,y:u[2]*r+u[3]*o+f,angle:n,scale:Math.log(i)*s}},n=t=>{const{keywidth:e,keyheight:r,querywidth:o,queryheight:n,matches:i}=t,h=1.2*o,l=-h,u=1.2*n,a=-u,c=12,f=1/Math.log(10),m=Math.max(e,r),g=Math.floor(e/2),w=Math.floor(r/2),p=[];for(const t of i){const e=t.querypoint.scale,r=t.keypoint.scale;if(0==r){console.error("ERROR divide zero");continue}const o=e/r;p.push(o*m)}p.sort(((t,e)=>t-e));const d=.25*p[Math.floor(p.length/2)-(p.length%2==0?1:0)-1],y=Math.max(5,Math.ceil((h-l)/d)),M=Math.max(5,Math.ceil((u-a)/d)),b=y*M,x=b*c,E=[],S=[],v={};for(const[t,e]of i.entries()){const{keypoint:r,querypoint:o}=e,{x:n,y:i,scale:m,angle:p}=s({querypoint:o,keypoint:r,keycenterX:g,keycenterY:w,scaleOneOverLogK:f});if(n<l||n>=h||i<a||i>=u||p<=-Math.PI||p>Math.PI||m<-1||m>=1){E[t]=!1;continue}const d=y*(n-l)/(h-l),k=M*(i-a)/(u-a),R=c*(p+Math.PI)/(2*Math.PI),T=10*(m- -1)/2;S[t]={binX:d,binY:k,binAngle:R,binScale:T};const I=Math.floor(d-.5),q=Math.floor(k-.5),N=Math.floor(T-.5),C=(Math.floor(R-.5)+c)%c;if(I<0||I+1>=y||q<0||q+1>=M||N<0||N+1>=10)E[t]=!1;else{for(let t=0;t<2;t++){const e=I+t;for(let t=0;t<2;t++){const r=q+t;for(let t=0;t<2;t++){const o=(C+t)%c;for(let t=0;t<2;t++){const s=e+r*y+o*b+(N+t)*x;void 0===v[s]&&(v[s]=0),v[s]+=1}}}}E[t]=!0}}let k=0,R=-1;if(Object.keys(v).forEach((t=>{const e=+t;v[e]>k&&(k=v[e],R=e)})),k<3)return[];const T=Math.floor(R%x%b%y),I=Math.floor((R-T)%x%b/y),q=Math.floor((R-T-I*y)%x/b),N=Math.floor((R-T-I*y-q*b)/x),C=[];for(let t=0;t<i.length;t++){if(!E[t])continue;const e=S[t];if(Math.abs(e.binX-(T+.5))>=1)continue;if(Math.abs(e.binY-(I+.5))>=1)continue;if(Math.abs(e.binScale-(N+.5))>=1)continue;const r=Math.abs(e.binAngle-(q+.5));Math.min(r,c-r)>=1||C.push(i[t])}return C},i=()=>({seed:1234,arrayShuffle(t){const{arr:e,sampleSize:r}=t;for(let t=0;t<r;t++){this.seed=(214013*this.seed+2531011)%(1<<31);let r=this.seed>>16&32767;r%=e.length;const o=e[t];e[t]=e[r],e[r]=o}},nextInt(t){this.seed=(214013*this.seed+2531011)%(1<<31);let e=this.seed>>16&32767;return e%=t,e}}),h=(t,e)=>[t[0]-e[0],t[1]-e[1]],l=(t,e)=>{const r=t[0]*e[1]-t[1]*e[0];return.5*Math.abs(r)},u=(t,e,r)=>(e[0]-t[0])*(r[1]-t[1])-(e[1]-t[1])*(r[0]-t[0]),a=(t,e)=>{const r=(t=>{const e=t[4]*t[8]-t[5]*t[7],r=t[3]*t[8]-t[5]*t[6],o=t[3]*t[7]-t[4]*t[6];return t[0]*e-t[1]*r+t[2]*o})(t);if(Math.abs(r)<=e)return null;const o=1/r;return[(t[4]*t[8]-t[5]*t[7])*o,(t[2]*t[7]-t[1]*t[8])*o,(t[1]*t[5]-t[2]*t[4])*o,(t[5]*t[6]-t[3]*t[8])*o,(t[0]*t[8]-t[2]*t[6])*o,(t[2]*t[3]-t[0]*t[5])*o,(t[3]*t[7]-t[4]*t[6])*o,(t[1]*t[6]-t[0]*t[7])*o,(t[0]*t[4]-t[1]*t[3])*o]},c=(t,e)=>{const r=e[6]*t[0]+e[7]*t[1]+e[8];return[(e[0]*t[0]+e[1]*t[1]+e[2])/r,(e[3]*t[0]+e[4]*t[1]+e[5])/r]},f=Object.prototype.toString;function m(t){return f.call(t).endsWith("Array]")}function g(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!m(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,o=void 0===r?0:r,s=e.toIndex,n=void 0===s?t.length:s;if(o<0||o>=t.length||!Number.isInteger(o))throw new Error("fromIndex must be a positive integer smaller than length");if(n<=o||n>t.length||!Number.isInteger(n))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var i=t[o],h=o+1;h<n;h++)t[h]>i&&(i=t[h]);return i}function w(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!m(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,o=void 0===r?0:r,s=e.toIndex,n=void 0===s?t.length:s;if(o<0||o>=t.length||!Number.isInteger(o))throw new Error("fromIndex must be a positive integer smaller than length");if(n<=o||n>t.length||!Number.isInteger(n))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var i=t[o],h=o+1;h<n;h++)t[h]<i&&(i=t[h]);return i}function p(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!m(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==r.output){if(!m(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);var o=w(t),s=g(t);if(o===s)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var n=r.min,i=void 0===n?r.autoMinMax?o:0:n,h=r.max,l=void 0===h?r.autoMinMax?s:1:h;if(i>=l)throw new RangeError("min option must be smaller than max option");for(var u=(l-i)/(s-o),a=0;a<t.length;a++)e[a]=(t[a]-o)*u+i;return e}const d=" ".repeat(2),y=" ".repeat(4);function M(t,e={}){const{maxRows:r=15,maxColumns:o=10,maxNumSize:s=8}=e;return`${t.constructor.name} {\\n${d}[\\n${y}${function(t,e,r,o){const{rows:s,columns:n}=t,i=Math.min(s,e),h=Math.min(n,r),l=[];for(let e=0;e<i;e++){let r=[];for(let s=0;s<h;s++)r.push(b(t.get(e,s),o));l.push(`${r.join(" ")}`)}return h!==n&&(l[l.length-1]+=` ... ${n-r} more columns`),i!==s&&l.push(`... ${s-e} more rows`),l.join(`\\n${y}`)}(t,r,o,s)}\\n${d}]\\n${d}rows: ${t.rows}\\n${d}columns: ${t.columns}\\n}`}function b(t,e){const r=String(t);if(r.length<=e)return r.padEnd(e," ");const o=t.toPrecision(e-2);if(o.length<=e)return o;const s=t.toExponential(e-2),n=s.indexOf("e"),i=s.slice(n);return s.slice(0,e-i.length)+i}function x(t,e,r){let o=r?t.rows:t.rows-1;if(e<0||e>o)throw new RangeError("Row index out of range")}function E(t,e,r){let o=r?t.columns:t.columns-1;if(e<0||e>o)throw new RangeError("Column index out of range")}function S(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function v(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function k(t,e,r,o,s){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(T("startRow",e),T("endRow",r),T("startColumn",o),T("endColumn",s),e>r||o>s||e<0||e>=t.rows||r<0||r>=t.rows||o<0||o>=t.columns||s<0||s>=t.columns)throw new RangeError("Submatrix indices are out of range")}function R(t,e=0){let r=[];for(let o=0;o<t;o++)r.push(e);return r}function T(t,e){if("number"!=typeof e)throw new TypeError(`${t} must be a number`)}function I(t){if(t.isEmpty())throw new Error("Empty matrix has no elements to index")}class q{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let o=new C(t,e);for(let s=0;s<t;s++)for(let t=0;t<e;t++)o.set(s,t,r[s*e+t]);return o}static rowVector(t){let e=new C(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new C(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new C(t,e)}static ones(t,e){return new C(t,e).fill(1)}static rand(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{random:o=Math.random}=r;let s=new C(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)s.set(r,t,o());return s}static randInt(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{min:o=0,max:s=1e3,random:n=Math.random}=r;if(!Number.isInteger(o))throw new TypeError("min must be an integer");if(!Number.isInteger(s))throw new TypeError("max must be an integer");if(o>=s)throw new RangeError("min must be smaller than max");let i=s-o,h=new C(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=o+Math.round(n()*i);h.set(r,t,e)}return h}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let o=Math.min(t,e),s=this.zeros(t,e);for(let t=0;t<o;t++)s.set(t,t,r);return s}static diag(t,e,r){let o=t.length;void 0===e&&(e=o),void 0===r&&(r=e);let s=Math.min(o,e,r),n=this.zeros(e,r);for(let e=0;e<s;e++)n.set(e,e,t[e]);return n}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,o=t.columns,s=new C(r,o);for(let n=0;n<r;n++)for(let r=0;r<o;r++)s.set(n,r,Math.min(t.get(n,r),e.get(n,r)));return s}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,o=t.columns,s=new this(r,o);for(let n=0;n<r;n++)for(let r=0;r<o;r++)s.set(n,r,Math.max(t.get(n,r),e.get(n,r)));return s}static checkMatrix(t){return q.isMatrix(t)?t:new C(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isEmpty(){return 0===this.rows||0===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,o=!0,s=!1;for(;t<this.rows&&o;){for(e=0,s=!1;e<this.columns&&!1===s;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(s=!0,r=e):(o=!1,s=!0);t++}return o}isReducedEchelonForm(){let t=0,e=0,r=-1,o=!0,s=!1;for(;t<this.rows&&o;){for(e=0,s=!1;e<this.columns&&!1===s;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(s=!0,r=e):(o=!1,s=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(o=!1);t++}return o}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let o=e;for(let s=e;s<t.rows;s++)t.get(s,r)>t.get(o,r)&&(o=s);if(0===t.get(o,r))r++;else{t.swapRows(e,o);let s=t.get(e,r);for(let o=r;o<t.columns;o++)t.set(e,o,t.get(e,o)/s);for(let o=e+1;o<t.rows;o++){let s=t.get(o,r)/t.get(e,r);t.set(o,r,0);for(let n=r+1;n<t.columns;n++)t.set(o,n,t.get(o,n)-t.get(e,n)*s)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,o=r-1;for(;o>=0;)if(0===t.maxRow(o))o--;else{let s=0,n=!1;for(;s<r&&!1===n;)1===t.get(o,s)?n=!0:s++;for(let r=0;r<o;r++){let n=t.get(r,s);for(let i=s;i<e;i++){let e=t.get(r,i)-n*t.get(o,i);t.set(r,i,e)}}o--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let o=new C(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)o.setSubMatrix(this,this.rows*t,this.columns*e);return o}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){x(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return C.rowVector(this.getRow(t))}setRow(t,e){x(this,t),e=S(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){x(this,t),x(this,e);for(let r=0;r<this.columns;r++){let o=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,o)}return this}getColumn(t){E(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return C.columnVector(this.getColumn(t))}setColumn(t,e){E(this,t),e=v(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){E(this,t),E(this,e);for(let r=0;r<this.rows;r++){let o=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,o)}return this}addRowVector(t){t=S(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=S(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=S(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=S(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=v(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=v(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=v(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=v(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){x(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){E(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t[e]&&(t[e]=this.get(e,r));return t}case"column":{const t=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t[r]&&(t[r]=this.get(e,r));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}default:throw new Error(`invalid option: ${t}`)}}maxIndex(){I(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)>t&&(t=this.get(r,o),e[0]=r,e[1]=o);return e}min(t){if(this.isEmpty())return NaN;switch(t){case"row":{const t=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t[e]&&(t[e]=this.get(e,r));return t}case"column":{const t=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t[r]&&(t[r]=this.get(e,r));return t}case void 0:{let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}default:throw new Error(`invalid option: ${t}`)}}minIndex(){I(this);let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)<t&&(t=this.get(r,o),e[0]=r,e[1]=o);return e}maxRow(t){if(x(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){x(this,t),I(this);let e=this.get(t,0),r=[t,0];for(let o=1;o<this.columns;o++)this.get(t,o)>e&&(e=this.get(t,o),r[1]=o);return r}minRow(t){if(x(this,t),this.isEmpty())return NaN;let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){x(this,t),I(this);let e=this.get(t,0),r=[t,0];for(let o=1;o<this.columns;o++)this.get(t,o)<e&&(e=this.get(t,o),r[1]=o);return r}maxColumn(t){if(E(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){E(this,t),I(this);let e=this.get(0,t),r=[0,t];for(let o=1;o<this.rows;o++)this.get(o,t)>e&&(e=this.get(o,t),r[0]=o);return r}minColumn(t){if(E(this,t),this.isEmpty())return NaN;let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){E(this,t),I(this);let e=this.get(0,t),r=[0,t];for(let o=1;o<this.rows;o++)this.get(o,t)<e&&(e=this.get(o,t),r[0]=o);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(t="frobenius"){let e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r)*this.get(t,r);return Math.sqrt(e)}throw new RangeError(`unknown norm type: ${t}`)}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){q.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let o=0;o<e.length;o++)r+=e[o]*t[o];return r}mmul(t){t=C.checkMatrix(t);let e=this.rows,r=this.columns,o=t.columns,s=new C(e,o),n=new Float64Array(r);for(let i=0;i<o;i++){for(let e=0;e<r;e++)n[e]=t.get(e,i);for(let t=0;t<e;t++){let e=0;for(let o=0;o<r;o++)e+=this.get(t,o)*n[o];s.set(t,i,e)}}return s}strassen2x2(t){t=C.checkMatrix(t);let e=new C(2,2);const r=this.get(0,0),o=t.get(0,0),s=this.get(0,1),n=t.get(0,1),i=this.get(1,0),h=t.get(1,0),l=this.get(1,1),u=t.get(1,1),a=(r+l)*(o+u),c=(i+l)*o,f=r*(n-u),m=l*(h-o),g=(r+s)*u,w=a+m-g+(s-l)*(h+u),p=f+g,d=c+m,y=a-c+f+(i-r)*(o+n);return e.set(0,0,w),e.set(0,1,p),e.set(1,0,d),e.set(1,1,y),e}strassen3x3(t){t=C.checkMatrix(t);let e=new C(3,3);const r=this.get(0,0),o=this.get(0,1),s=this.get(0,2),n=this.get(1,0),i=this.get(1,1),h=this.get(1,2),l=this.get(2,0),u=this.get(2,1),a=this.get(2,2),c=t.get(0,0),f=t.get(0,1),m=t.get(0,2),g=t.get(1,0),w=t.get(1,1),p=t.get(1,2),d=t.get(2,0),y=t.get(2,1),M=t.get(2,2),b=(r-n)*(-f+w),x=(-r+n+i)*(c-f+w),E=(n+i)*(-c+f),S=r*c,v=(-r+l+u)*(c-m+p),k=(-r+l)*(m-p),R=(l+u)*(-c+m),T=(-s+u+a)*(w+d-y),I=(s-a)*(w-y),q=s*d,N=(u+a)*(-d+y),A=(-s+i+h)*(p+d-M),P=(s-h)*(p-M),V=(i+h)*(-d+M),z=S+q+o*g,F=(r+o+s-n-i-u-a)*w+x+E+S+T+q+N,j=S+v+R+(r+o+s-i-h-l-u)*p+q+A+V,_=b+i*(-c+f+g-w-p-d+M)+x+S+q+A+P,$=b+x+E+S+h*y,D=q+A+P+V+n*m,H=S+v+k+u*(-c+m+g-w-p-d+y)+T+I+q,U=T+I+q+N+l*f,L=S+v+k+R+a*M;return e.set(0,0,z),e.set(0,1,F),e.set(0,2,j),e.set(1,0,_),e.set(1,1,$),e.set(1,2,D),e.set(2,0,H),e.set(2,1,U),e.set(2,2,L),e}mmulStrassen(t){t=C.checkMatrix(t);let e=this.clone(),r=e.rows,o=e.columns,s=t.rows,n=t.columns;function i(t,e,r){let o=t.rows,s=t.columns;if(o===e&&s===r)return t;{let o=q.zeros(e,r);return o=o.setSubMatrix(t,0,0),o}}o!==s&&console.warn(`Multiplying ${r} x ${o} and ${s} x ${n} matrix: dimensions do not match.`);let h=Math.max(r,s),l=Math.max(o,n);return e=i(e,h,l),function t(e,r,o,s){if(o<=512||s<=512)return e.mmul(r);o%2==1&&s%2==1?(e=i(e,o+1,s+1),r=i(r,o+1,s+1)):o%2==1?(e=i(e,o+1,s),r=i(r,o+1,s)):s%2==1&&(e=i(e,o,s+1),r=i(r,o,s+1));let n=parseInt(e.rows/2,10),h=parseInt(e.columns/2,10),l=e.subMatrix(0,n-1,0,h-1),u=r.subMatrix(0,n-1,0,h-1),a=e.subMatrix(0,n-1,h,e.columns-1),c=r.subMatrix(0,n-1,h,r.columns-1),f=e.subMatrix(n,e.rows-1,0,h-1),m=r.subMatrix(n,r.rows-1,0,h-1),g=e.subMatrix(n,e.rows-1,h,e.columns-1),w=r.subMatrix(n,r.rows-1,h,r.columns-1),p=t(q.add(l,g),q.add(u,w),n,h),d=t(q.add(f,g),u,n,h),y=t(l,q.sub(c,w),n,h),M=t(g,q.sub(m,u),n,h),b=t(q.add(l,a),w,n,h),x=t(q.sub(f,l),q.add(u,c),n,h),E=t(q.sub(a,g),q.add(m,w),n,h),S=q.add(p,M);S.sub(b),S.add(E);let v=q.add(y,b),k=q.add(d,M),R=q.sub(p,d);R.add(y),R.add(x);let T=q.zeros(2*S.rows,2*S.columns);return T=T.setSubMatrix(S,0,0),T=T.setSubMatrix(v,S.rows,0),T=T.setSubMatrix(k,0,S.columns),T=T.setSubMatrix(R,S.rows,S.columns),T.subMatrix(0,o-1,0,s-1)}(e,t=i(t,h,l),h,l)}scaleRows(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let o=new C(this.rows,this.columns);for(let t=0;t<this.rows;t++){const s=this.getRow(t);s.length>0&&p(s,{min:e,max:r,output:s}),o.setRow(t,s)}return o}scaleColumns(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let o=new C(this.rows,this.columns);for(let t=0;t<this.columns;t++){const s=this.getColumn(t);s.length&&p(s,{min:e,max:r,output:s}),o.setColumn(t,s)}return o}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),o=this.get(e,this.columns-1-r);this.set(e,r,o),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),o=this.get(this.rows-1-r,e);this.set(r,e,o),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=C.checkMatrix(t);let e=this.rows,r=this.columns,o=t.rows,s=t.columns,n=new C(e*o,r*s);for(let i=0;i<e;i++)for(let e=0;e<r;e++)for(let r=0;r<o;r++)for(let h=0;h<s;h++)n.set(o*i+r,s*e+h,this.get(i,e)*t.get(r,h));return n}kroneckerSum(t){if(t=C.checkMatrix(t),!this.isSquare()||!t.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let e=this.rows,r=t.rows,o=this.kroneckerProduct(C.eye(r,r)),s=C.eye(e,e).kroneckerProduct(t);return o.add(s)}transpose(){let t=new C(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(t=N){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=N){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,o){k(this,t,e,r,o);let s=new C(e-t+1,o-r+1);for(let n=t;n<=e;n++)for(let e=r;e<=o;e++)s.set(n-t,e-r,this.get(n,e));return s}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let o=new C(t.length,r-e+1);for(let s=0;s<t.length;s++)for(let n=e;n<=r;n++){if(t[s]<0||t[s]>=this.rows)throw new RangeError(`Row index out of range: ${t[s]}`);o.set(s,n-e,this.get(t[s],n))}return o}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let o=new C(r-e+1,t.length);for(let s=0;s<t.length;s++)for(let n=e;n<=r;n++){if(t[s]<0||t[s]>=this.columns)throw new RangeError(`Column index out of range: ${t[s]}`);o.set(n-e,s,this.get(n,t[s]))}return o}setSubMatrix(t,e,r){if((t=C.checkMatrix(t)).isEmpty())return this;k(this,e,e+t.rows-1,r,r+t.columns-1);for(let o=0;o<t.rows;o++)for(let s=0;s<t.columns;s++)this.set(e+o,r+s,t.get(o,s));return this}selection(t,e){!function(t,e){if(!m(e))throw new TypeError("row indices must be an array");for(let r=0;r<e.length;r++)if(e[r]<0||e[r]>=t.rows)throw new RangeError("row indices are out of range")}(this,t),function(t,e){if(!m(e))throw new TypeError("column indices must be an array");for(let r=0;r<e.length;r++)if(e[r]<0||e[r]>=t.columns)throw new RangeError("column indices are out of range")}(this,e);let r=new C(t.length,e.length);for(let o=0;o<t.length;o++){let s=t[o];for(let t=0;t<e.length;t++){let n=e[t];r.set(o,t,this.get(s,n))}}return r}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){let t=new C(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return function(t){let e=R(t.rows);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[r]+=t.get(r,o);return e}(this);case"column":return function(t){let e=R(t.columns);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[o]+=t.get(r,o);return e}(this);case void 0:return function(t){let e=0;for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)e+=t.get(r,o);return e}(this);default:throw new Error(`invalid option: ${t}`)}}product(t){switch(t){case"row":return function(t){let e=R(t.rows,1);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[r]*=t.get(r,o);return e}(this);case"column":return function(t){let e=R(t.columns,1);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[o]*=t.get(r,o);return e}(this);case void 0:return function(t){let e=1;for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)e*=t.get(r,o);return e}(this);default:throw new Error(`invalid option: ${t}`)}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error(`invalid option: ${t}`)}}variance(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:o=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!m(o))throw new TypeError("mean must be an array");return function(t,e,r){const o=t.rows,s=t.columns,n=[];for(let i=0;i<o;i++){let o=0,h=0,l=0;for(let e=0;e<s;e++)l=t.get(i,e)-r[i],o+=l,h+=l*l;e?n.push((h-o*o/s)/(s-1)):n.push((h-o*o/s)/s)}return n}(this,r,o);case"column":if(!m(o))throw new TypeError("mean must be an array");return function(t,e,r){const o=t.rows,s=t.columns,n=[];for(let i=0;i<s;i++){let s=0,h=0,l=0;for(let e=0;e<o;e++)l=t.get(e,i)-r[i],s+=l,h+=l*l;e?n.push((h-s*s/o)/(o-1)):n.push((h-s*s/o)/o)}return n}(this,r,o);case void 0:if("number"!=typeof o)throw new TypeError("mean must be a number");return function(t,e,r){const o=t.rows,s=t.columns,n=o*s;let i=0,h=0,l=0;for(let e=0;e<o;e++)for(let o=0;o<s;o++)l=t.get(e,o)-r,i+=l,h+=l*l;return e?(h-i*i/n)/(n-1):(h-i*i/n)/n}(this,r,o);default:throw new Error(`invalid option: ${t}`)}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!m(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)-e[r])}(this,r),this;case"column":if(!m(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)-e[o])}(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)-e)}(this,r),this;default:throw new Error(`invalid option: ${t}`)}}scale(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.rows;r++){let o=0;for(let e=0;e<t.columns;e++)o+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(o))}return e}(this);else if(!m(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)/e[r])}(this,r),this;case"column":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.columns;r++){let o=0;for(let e=0;e<t.rows;e++)o+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(o))}return e}(this);else if(!m(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)/e[o])}(this,r),this;case void 0:if(void 0===r)r=function(t){const e=t.size-1;let r=0;for(let o=0;o<t.columns;o++)for(let s=0;s<t.rows;s++)r+=Math.pow(t.get(s,o),2)/e;return Math.sqrt(r)}(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)/e)}(this,r),this;default:throw new Error(`invalid option: ${t}`)}}toString(t){return M(this,t)}}function N(t,e){return t-e}q.prototype.klass="Matrix","undefined"!=typeof Symbol&&(q.prototype[Symbol.for("nodejs.util.inspect.custom")]=function(){return M(this)}),q.random=q.rand,q.randomInt=q.randInt,q.diagonal=q.diag,q.prototype.diagonal=q.prototype.diag,q.identity=q.eye,q.prototype.negate=q.prototype.neg,q.prototype.tensorProduct=q.prototype.kroneckerProduct;class C extends q{constructor(t,e){if(super(),C.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>=0){if(this.data=[],!(Number.isInteger(e)&&e>=0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!m(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if("number"!=typeof(e=(t=r.length)?r[0].length:0))throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let o=0;o<t;o++){if(r[o].length!==e)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(r[o]))}}}this.rows=t,this.columns=e}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){return x(this,t),this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),x(this,t,!0),e=Float64Array.from(S(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){E(this,t);for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let o=0;o<t;o++)r[o]=this.data[e][o];for(let o=t+1;o<this.columns;o++)r[o-1]=this.data[e][o];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),E(this,t,!0),e=v(this,e);for(let r=0;r<this.rows;r++){const o=new Float64Array(this.columns+1);let s=0;for(;s<t;s++)o[s]=this.data[r][s];for(o[s++]=e[r];s<this.columns+1;s++)o[s]=this.data[r][s-1];this.data[r]=o}return this.columns+=1,this}}!function(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t.get(e,r)));return this}}(q,C);class A extends q{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}class P{constructor(t){let e,r,o,s,n,i,h,l,u,a=(t=A.checkMatrix(t)).clone(),c=a.rows,f=a.columns,m=new Float64Array(c),g=1;for(e=0;e<c;e++)m[e]=e;for(l=new Float64Array(c),r=0;r<f;r++){for(e=0;e<c;e++)l[e]=a.get(e,r);for(e=0;e<c;e++){for(u=Math.min(e,r),n=0,o=0;o<u;o++)n+=a.get(e,o)*l[o];l[e]-=n,a.set(e,r,l[e])}for(s=r,e=r+1;e<c;e++)Math.abs(l[e])>Math.abs(l[s])&&(s=e);if(s!==r){for(o=0;o<f;o++)i=a.get(s,o),a.set(s,o,a.get(r,o)),a.set(r,o,i);h=m[s],m[s]=m[r],m[r]=h,g=-g}if(r<c&&0!==a.get(r,r))for(e=r+1;e<c;e++)a.set(e,r,a.get(e,r)/a.get(r,r))}this.LU=a,this.pivotVector=m,this.pivotSign=g}isSingular(){let t=this.LU,e=t.columns;for(let r=0;r<e;r++)if(0===t.get(r,r))return!0;return!1}solve(t){t=C.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let r,o,s,n=t.columns,i=t.subMatrixRow(this.pivotVector,0,n-1),h=e.columns;for(s=0;s<h;s++)for(r=s+1;r<h;r++)for(o=0;o<n;o++)i.set(r,o,i.get(r,o)-i.get(s,o)*e.get(r,s));for(s=h-1;s>=0;s--){for(o=0;o<n;o++)i.set(s,o,i.get(s,o)/e.get(s,s));for(r=0;r<s;r++)for(o=0;o<n;o++)i.set(r,o,i.get(r,o)-i.get(s,o)*e.get(r,s))}return i}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,r=t.columns;for(let o=0;o<r;o++)e*=t.get(o,o);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,o=new C(e,r);for(let s=0;s<e;s++)for(let e=0;e<r;e++)s>e?o.set(s,e,t.get(s,e)):s===e?o.set(s,e,1):o.set(s,e,0);return o}get upperTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,o=new C(e,r);for(let s=0;s<e;s++)for(let e=0;e<r;e++)s<=e?o.set(s,e,t.get(s,e)):o.set(s,e,0);return o}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function V(t,e){let r=0;return Math.abs(t)>Math.abs(e)?(r=e/t,Math.abs(t)*Math.sqrt(1+r*r)):0!==e?(r=t/e,Math.abs(e)*Math.sqrt(1+r*r)):0}class z{constructor(t){let e,r,o,s,n=(t=A.checkMatrix(t)).clone(),i=t.rows,h=t.columns,l=new Float64Array(h);for(o=0;o<h;o++){let t=0;for(e=o;e<i;e++)t=V(t,n.get(e,o));if(0!==t){for(n.get(o,o)<0&&(t=-t),e=o;e<i;e++)n.set(e,o,n.get(e,o)/t);for(n.set(o,o,n.get(o,o)+1),r=o+1;r<h;r++){for(s=0,e=o;e<i;e++)s+=n.get(e,o)*n.get(e,r);for(s=-s/n.get(o,o),e=o;e<i;e++)n.set(e,r,n.get(e,r)+s*n.get(e,o))}}l[o]=-t}this.QR=n,this.Rdiag=l}solve(t){t=C.checkMatrix(t);let e=this.QR,r=e.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let o,s,n,i,h=t.columns,l=t.clone(),u=e.columns;for(n=0;n<u;n++)for(s=0;s<h;s++){for(i=0,o=n;o<r;o++)i+=e.get(o,n)*l.get(o,s);for(i=-i/e.get(n,n),o=n;o<r;o++)l.set(o,s,l.get(o,s)+i*e.get(o,n))}for(n=u-1;n>=0;n--){for(s=0;s<h;s++)l.set(n,s,l.get(n,s)/this.Rdiag[n]);for(o=0;o<n;o++)for(s=0;s<h;s++)l.set(o,s,l.get(o,s)-l.get(n,s)*e.get(o,n))}return l.subMatrix(0,u-1,0,h-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){let t,e,r=this.QR,o=r.columns,s=new C(o,o);for(t=0;t<o;t++)for(e=0;e<o;e++)t<e?s.set(t,e,r.get(t,e)):t===e?s.set(t,e,this.Rdiag[t]):s.set(t,e,0);return s}get orthogonalMatrix(){let t,e,r,o,s=this.QR,n=s.rows,i=s.columns,h=new C(n,i);for(r=i-1;r>=0;r--){for(t=0;t<n;t++)h.set(t,r,0);for(h.set(r,r,1),e=r;e<i;e++)if(0!==s.get(r,r)){for(o=0,t=r;t<n;t++)o+=s.get(t,r)*h.get(t,e);for(o=-o/s.get(r,r),t=r;t<n;t++)h.set(t,e,h.get(t,e)+o*s.get(t,r))}}return h}}class F{constructor(t,e={}){if((t=A.checkMatrix(t)).isEmpty())throw new Error("Matrix must be non-empty");let r=t.rows,o=t.columns;const{computeLeftSingularVectors:s=!0,computeRightSingularVectors:n=!0,autoTranspose:i=!1}=e;let h,l=Boolean(s),u=Boolean(n),a=!1;if(r<o)if(i){h=t.transpose(),r=h.rows,o=h.columns,a=!0;let e=l;l=u,u=e}else h=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else h=t.clone();let c=Math.min(r,o),f=Math.min(r+1,o),m=new Float64Array(f),g=new C(r,c),w=new C(o,o),p=new Float64Array(o),d=new Float64Array(r),y=new Float64Array(f);for(let t=0;t<f;t++)y[t]=t;let M=Math.min(r-1,o),b=Math.max(0,Math.min(o-2,r)),x=Math.max(M,b);for(let t=0;t<x;t++){if(t<M){m[t]=0;for(let e=t;e<r;e++)m[t]=V(m[t],h.get(e,t));if(0!==m[t]){h.get(t,t)<0&&(m[t]=-m[t]);for(let e=t;e<r;e++)h.set(e,t,h.get(e,t)/m[t]);h.set(t,t,h.get(t,t)+1)}m[t]=-m[t]}for(let e=t+1;e<o;e++){if(t<M&&0!==m[t]){let o=0;for(let s=t;s<r;s++)o+=h.get(s,t)*h.get(s,e);o=-o/h.get(t,t);for(let s=t;s<r;s++)h.set(s,e,h.get(s,e)+o*h.get(s,t))}p[e]=h.get(t,e)}if(l&&t<M)for(let e=t;e<r;e++)g.set(e,t,h.get(e,t));if(t<b){p[t]=0;for(let e=t+1;e<o;e++)p[t]=V(p[t],p[e]);if(0!==p[t]){p[t+1]<0&&(p[t]=0-p[t]);for(let e=t+1;e<o;e++)p[e]/=p[t];p[t+1]+=1}if(p[t]=-p[t],t+1<r&&0!==p[t]){for(let e=t+1;e<r;e++)d[e]=0;for(let e=t+1;e<r;e++)for(let r=t+1;r<o;r++)d[e]+=p[r]*h.get(e,r);for(let e=t+1;e<o;e++){let o=-p[e]/p[t+1];for(let s=t+1;s<r;s++)h.set(s,e,h.get(s,e)+o*d[s])}}if(u)for(let e=t+1;e<o;e++)w.set(e,t,p[e])}}let E=Math.min(o,r+1);if(M<o&&(m[M]=h.get(M,M)),r<E&&(m[E-1]=0),b+1<E&&(p[b]=h.get(b,E-1)),p[E-1]=0,l){for(let t=M;t<c;t++){for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}for(let t=M-1;t>=0;t--)if(0!==m[t]){for(let e=t+1;e<c;e++){let o=0;for(let s=t;s<r;s++)o+=g.get(s,t)*g.get(s,e);o=-o/g.get(t,t);for(let s=t;s<r;s++)g.set(s,e,g.get(s,e)+o*g.get(s,t))}for(let e=t;e<r;e++)g.set(e,t,-g.get(e,t));g.set(t,t,1+g.get(t,t));for(let e=0;e<t-1;e++)g.set(e,t,0)}else{for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}}if(u)for(let t=o-1;t>=0;t--){if(t<b&&0!==p[t])for(let e=t+1;e<o;e++){let r=0;for(let s=t+1;s<o;s++)r+=w.get(s,t)*w.get(s,e);r=-r/w.get(t+1,t);for(let s=t+1;s<o;s++)w.set(s,e,w.get(s,e)+r*w.get(s,t))}for(let e=0;e<o;e++)w.set(e,t,0);w.set(t,t,1)}let S=E-1,v=0,k=Number.EPSILON;for(;E>0;){let t,e;for(t=E-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+k*Math.abs(m[t]+Math.abs(m[t+1]));if(Math.abs(p[t])<=e||Number.isNaN(p[t])){p[t]=0;break}}if(t===E-2)e=4;else{let r;for(r=E-1;r>=t&&r!==t;r--){let e=(r!==E?Math.abs(p[r]):0)+(r!==t+1?Math.abs(p[r-1]):0);if(Math.abs(m[r])<=k*e){m[r]=0;break}}r===t?e=3:r===E-1?e=1:(e=2,t=r)}switch(t++,e){case 1:{let e=p[E-2];p[E-2]=0;for(let r=E-2;r>=t;r--){let s=V(m[r],e),n=m[r]/s,i=e/s;if(m[r]=s,r!==t&&(e=-i*p[r-1],p[r-1]=n*p[r-1]),u)for(let t=0;t<o;t++)s=n*w.get(t,r)+i*w.get(t,E-1),w.set(t,E-1,-i*w.get(t,r)+n*w.get(t,E-1)),w.set(t,r,s)}break}case 2:{let e=p[t-1];p[t-1]=0;for(let o=t;o<E;o++){let s=V(m[o],e),n=m[o]/s,i=e/s;if(m[o]=s,e=-i*p[o],p[o]=n*p[o],l)for(let e=0;e<r;e++)s=n*g.get(e,o)+i*g.get(e,t-1),g.set(e,t-1,-i*g.get(e,o)+n*g.get(e,t-1)),g.set(e,o,s)}break}case 3:{const e=Math.max(Math.abs(m[E-1]),Math.abs(m[E-2]),Math.abs(p[E-2]),Math.abs(m[t]),Math.abs(p[t])),s=m[E-1]/e,n=m[E-2]/e,i=p[E-2]/e,h=m[t]/e,a=p[t]/e,c=((n+s)*(n-s)+i*i)/2,f=s*i*(s*i);let d=0;0===c&&0===f||(d=c<0?0-Math.sqrt(c*c+f):Math.sqrt(c*c+f),d=f/(c+d));let y=(h+s)*(h-s)+d,M=h*a;for(let e=t;e<E-1;e++){let s=V(y,M);0===s&&(s=Number.MIN_VALUE);let n=y/s,i=M/s;if(e!==t&&(p[e-1]=s),y=n*m[e]+i*p[e],p[e]=n*p[e]-i*m[e],M=i*m[e+1],m[e+1]=n*m[e+1],u)for(let t=0;t<o;t++)s=n*w.get(t,e)+i*w.get(t,e+1),w.set(t,e+1,-i*w.get(t,e)+n*w.get(t,e+1)),w.set(t,e,s);if(s=V(y,M),0===s&&(s=Number.MIN_VALUE),n=y/s,i=M/s,m[e]=s,y=n*p[e]+i*m[e+1],m[e+1]=-i*p[e]+n*m[e+1],M=i*p[e+1],p[e+1]=n*p[e+1],l&&e<r-1)for(let t=0;t<r;t++)s=n*g.get(t,e)+i*g.get(t,e+1),g.set(t,e+1,-i*g.get(t,e)+n*g.get(t,e+1)),g.set(t,e,s)}p[E-2]=y,v+=1;break}case 4:if(m[t]<=0&&(m[t]=m[t]<0?-m[t]:0,u))for(let e=0;e<=S;e++)w.set(e,t,-w.get(e,t));for(;t<S&&!(m[t]>=m[t+1]);){let e=m[t];if(m[t]=m[t+1],m[t+1]=e,u&&t<o-1)for(let r=0;r<o;r++)e=w.get(r,t+1),w.set(r,t+1,w.get(r,t)),w.set(r,t,e);if(l&&t<r-1)for(let o=0;o<r;o++)e=g.get(o,t+1),g.set(o,t+1,g.get(o,t)),g.set(o,t,e);t++}v=0,E--}}if(a){let t=w;w=g,g=t}this.m=r,this.n=o,this.s=m,this.U=g,this.V=w}solve(t){let e=t,r=this.threshold,o=this.s.length,s=C.zeros(o,o);for(let t=0;t<o;t++)Math.abs(this.s[t])<=r?s.set(t,t,0):s.set(t,t,1/this.s[t]);let n=this.U,i=this.rightSingularVectors,h=i.mmul(s),l=i.rows,u=n.rows,a=C.zeros(l,u);for(let t=0;t<l;t++)for(let e=0;e<u;e++){let r=0;for(let s=0;s<o;s++)r+=h.get(t,s)*n.get(e,s);a.set(t,e,r)}return a.mmul(e)}solveForDiagonal(t){return this.solve(C.diag(t))}inverse(){let t=this.V,e=this.threshold,r=t.rows,o=t.columns,s=new C(r,this.s.length);for(let n=0;n<r;n++)for(let r=0;r<o;r++)Math.abs(this.s[r])>e&&s.set(n,r,t.get(n,r)/this.s[r]);let n=this.U,i=n.rows,h=n.columns,l=new C(r,i);for(let t=0;t<r;t++)for(let e=0;e<i;e++){let r=0;for(let o=0;o<h;o++)r+=s.get(t,o)*n.get(e,o);l.set(t,e,r)}return l}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,r=this.s;for(let o=0,s=r.length;o<s;o++)r[o]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return C.diag(this.s)}}function j(t,e=!1){return t=A.checkMatrix(t),e?new F(t).inverse():function(t,e,r=!1){return t=A.checkMatrix(t),e=A.checkMatrix(e),r?new F(t).solve(e):t.isSquare()?new P(t).solve(e):new z(t).solve(e)}(t,C.eye(t.rows))}const _=t=>{let e=0,r=0;for(const o of t)e+=o[0],r+=o[1];const o=e/t.length,s=r/t.length;let n=0;for(const e of t){const t=e[0]-o,r=e[1]-s;n+=Math.sqrt(t*t+r*r)}const i=Math.sqrt(2)*t.length/n,h=[];for(const e of t)h.push([(e[0]-o)*i,(e[1]-s)*i]);return{normPoints:h,param:{meanX:o,meanY:s,s:i}}},$=(t,e)=>{const{normPoints:r,param:o}=_(t),{normPoints:s,param:n}=_(e),i=s.length,h=[],l=[];for(let t=0;t<i;t++){const e=[r[t][0],r[t][1],1,0,0,0,-r[t][0]*s[t][0],-r[t][1]*s[t][0]],o=[0,0,0,r[t][0],r[t][1],1,-r[t][0]*s[t][1],-r[t][1]*s[t][1]];h.push(e),h.push(o),l.push([s[t][0]]),l.push([s[t][1]])}try{const t=new C(h),e=new C(l),r=t.transpose(),s=r.mmul(t),i=r.mmul(e),u=((t,e,r)=>{const o=r.s*r.meanX,s=r.s*r.meanY,n=[t[0]+o*t[6],t[1]+o*t[7],(t[0]+o*t[6])*-e.meanX+(t[1]+o*t[7])*-e.meanY+(t[2]+o)/e.s,t[3]+s*t[6],t[4]+s*t[7],(t[3]+s*t[6])*-e.meanX+(t[4]+s*t[7])*-e.meanY+(t[5]+s)/e.s,r.s*t[6],r.s*t[7],r.s*t[6]*-e.meanX+r.s*t[7]*-e.meanY+r.s/e.s];for(let t=0;t<9;t++)n[t]=n[t]/n[8];return n})(j(s).mmul(i).to1DArray(),o,n);return u}catch(t){return null}},D=({H:t,testPoints:e,keyframe:r})=>{const o=a(t,1e-5);if(null===o)return!1;const s=[];for(const t of e)s.push(c(t,o));return!(((t,e,r,o)=>{const s=h(e,t),n=h(r,t),i=h(o,t),u=h(e,r),a=h(o,r),c=l(s,n),f=l(n,i),m=l(s,i),g=l(u,a);return Math.min(c,f,m,g)})(s[0],s[1],s[2],s[3])<r.width*r.height*1e-4||!((t,e,r,o)=>{const s=u(t,e,r)<=0;return u(e,r,o)<=0===s&&u(r,o,t)<=0===s&&u(o,t,e)<=0===s})(s[0],s[1],s[2],s[3]))},H=({inH:t})=>{const e=1/t[8],r=[];for(let o=0;o<8;o++)r[o]=t[o]*e;return r[8]=1,r},U=({H:t,srcPoint:e,dstPoint:r,oneOverScaleSqr:o})=>{const s=c(e,t),n=[s[0]-r[0],s[1]-r[1]];return Math.log(1+(n[0]*n[0]+n[1]*n[1])*o)},L=({H:t,testPoints:e})=>{const r=[];for(const[o,s]of e.entries())r[o]=c(s,t);for(let t=0;t<e.length;t++){const a=t,c=(t+1)%e.length,f=(t+2)%e.length;if(o=e[a],s=e[c],n=e[f],i=r[a],h=r[c],l=r[f],u(o,s,n)>0!=u(i,h,l)>0)return!1}var o,s,n,i,h,l;return!0},O=t=>{const{dstPoints:e,keyframe:r,srcPoints:o,quickMode:s}=t,n=[[0,0],[r.width,0],[r.width,r.height],[0,r.height]];if(o.length<4)return null;const h=Math.min(10,o.length),l=i(),a=o.map(((t,e)=>e));l.arrayShuffle({arr:a,sampleSize:a.length});const c=s?10:20,f=2*c;let m=0;const g=[];for(;m<f&&g.length<c;){if(m+=1,l.arrayShuffle({arr:a,sampleSize:4}),w=o[a[0]],p=o[a[1]],d=o[a[2]],y=o[a[3]],M=e[a[0]],b=e[a[1]],x=e[a[2]],E=e[a[3]],u(w,p,d)>0!=u(M,b,x)>0||u(p,d,y)>0!=u(b,x,E)>0||u(d,y,w)>0!=u(x,E,M)>0||u(y,w,p)>0!=u(E,M,b)>0)continue;const t=$([o[a[0]],o[a[1]],o[a[2]],o[a[3]]],[e[a[0]],e[a[1]],e[a[2]],e[a[3]]]);null!==t&&L({H:t,testPoints:n})&&g.push(t)}var w,p,d,y,M,b,x,E;if(0===g.length)return null;const S=[];for(const t of g)S.push({H:t,cost:0});let v=h;for(let t=0;t<o.length&&S.length>2;t+=v){v=Math.min(h,o.length-t);const r=t+v;for(let s=0;s<S.length;s++)for(let n=t;n<r;n++){const t=U({H:S[s].H,srcPoint:o[n],dstPoint:e[n],oneOverScaleSqr:1e4});S[s].cost+=t}S.sort(((t,e)=>t.cost-e.cost)),S.splice(-Math.floor((S.length+1)/2))}let k=null;for(let t=0;t<S.length;t++){const e=H({inH:S[t].H});if(D({H:e,testPoints:n,keyframe:r})){k=e;break}}return k},X=({node:t,keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i})=>{if(t.leaf){for(const e of t.pointIndexes)n.push(e);return}const h=[];for(const s of t.children){const t=s.centerPointIndex;if(null==t)continue;const n=o({v1:e[t].descriptors,v2:r.descriptors});h.push(n)}const l=Math.min(Number.MAX_SAFE_INTEGER,...h);for(const[e,r]of t.children.entries())h[e]!==l&&s.push({node:r,d:h[e]});for(const[o,u]of t.children.entries())h[o]===l&&X({node:u,keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i});if(i<8&&s.length>0){const t=s.pop();if(t){const{node:o}=t;X({node:o,keypoints:e,querypoint:r,queue:s,keypointIndexes:n,numPop:i+=1})}}},Y=t=>{const{H:e,matches:r,threshold:o}=t,s=o**2,n=[];for(const t of r){const{querypoint:r,keypoint:o}=t,i=c([o.x,o.y],e);(i[0]-r.x)*(i[0]-r.x)+(i[1]-r.y)*(i[1]-r.y)<=s&&n.push(t)}return n},G=e=>{const{keyframe:r,querypoints:s,querywidth:i,queryheight:h,debugMode:l}=e,u={},f=(e=>{const{keyframe:r,querypoints:s}=e,n=[];for(const e of s){const s=e.maxima?r.maximaPoints:r.minimaPoints;if(0===s.length)continue;const i=e.maxima?r.maximaPointsCluster.rootNode:r.minimaPointsCluster.rootNode,h=[],l=new t([],((t,e)=>t.d-e.d));X({node:i,keypoints:s,querypoint:e,queue:l,keypointIndexes:h,numPop:0});let u=-1,a=Number.MAX_SAFE_INTEGER,c=Number.MAX_SAFE_INTEGER;for(let t=0;t<h.length;t++){const r=s[h[t]],n=o({v1:r.descriptors,v2:e.descriptors});n<a?(c=a,a=n,u=h[t]):n<c&&(c=n)}-1!==u&&(c===Number.MAX_SAFE_INTEGER||1*a/c<.7)&&n.push({querypoint:e,keypoint:s[u]})}return n})({keyframe:r,querypoints:s});if(l&&(u.matches=f),f.length<6)return{debugExtra:u};const m=n({keywidth:r.width,keyheight:r.height,querywidth:i,queryheight:h,matches:f});l&&(u.houghMatches=m);const g=O({srcPoints:m.map((t=>[t.keypoint.x,t.keypoint.y])),dstPoints:m.map((t=>[t.querypoint.x,t.querypoint.y])),keyframe:r});if(null===g)return{debugExtra:u};const w=Y({H:g,matches:m,threshold:3});if(l&&(u.inlierMatches=w),w.length<6)return{debugExtra:u};const p=a(g,1e-5);if(!p)return{debugExtra:u};const d=(t=>{const{keyframe:e,querypoints:r,HInv:s}=t,n=[];for(const t of r){const r=c([t.x,t.y],s);let i=-1,h=Number.MAX_SAFE_INTEGER,l=Number.MAX_SAFE_INTEGER;const u=t.maxima?e.maximaPoints:e.minimaPoints;for(const[e,s]of u.entries()){if((s.x-r[0])**2+(s.y-r[1])**2>100)continue;const n=o({v1:s.descriptors,v2:t.descriptors});n<h?(l=h,h=n,i=e):n<l&&(l=n)}-1!==i&&(l===Number.MAX_SAFE_INTEGER||1*h/l<.7)&&n.push({querypoint:t,keypoint:u[i]})}return n})({keyframe:r,querypoints:s,HInv:p});l&&(u.matches2=d);const y=n({keywidth:r.width,keyheight:r.height,querywidth:i,queryheight:h,matches:d});l&&(u.houghMatches2=y);const M=O({srcPoints:y.map((t=>[t.keypoint.x,t.keypoint.y])),dstPoints:y.map((t=>[t.querypoint.x,t.querypoint.y])),keyframe:r});if(null===M)return{debugExtra:u};const b=Y({H:M,matches:y,threshold:3});return l&&(u.inlierMatches2=b),{H:M,matches:b,debugExtra:u}},Q=(t,e)=>[[t[0][0]*e[0][0]+t[0][2]*e[2][0],t[0][0]*e[0][1]+t[0][2]*e[2][1],t[0][0]*e[0][2]+t[0][2]*e[2][2],t[0][0]*e[0][3]+t[0][2]*e[2][3]],[t[1][1]*e[1][0]+t[1][2]*e[2][0],t[1][1]*e[1][1]+t[1][2]*e[2][1],t[1][1]*e[1][2]+t[1][2]*e[2][2],t[1][1]*e[1][3]+t[1][2]*e[2][3]],[e[2][0],e[2][1],e[2][2],e[2][3]]],W=(t,e,r,o=0)=>({x:t[0][0]*e+t[0][1]*r+t[0][3],y:t[1][0]*e+t[1][1]*r+t[1][3],z:t[2][0]*e+t[2][1]*r+t[2][3]}),J=(t,e,r,o=0)=>{const s=W(t,e,r,o),{x:n,y:i,z:h}=s;return{x:n/h,y:i/h}},K=[[],[],[]],B=[[],[]],Z=[[],[],[]],tt=({initialModelViewTransform:t,projectionTransform:e,worldCoords:r,screenCoords:o,inlierProb:s})=>{const n=s<1;let i=t,h=0,l=0;const u=new Array(r.length),a=new Array(r.length),c=new Array(r.length),f=new Array(r.length);for(let t=0;t<=10;t++){const m=Q(e,i);for(let t=0;t<r.length;t++){const e=J(m,r[t].x,r[t].y,r[t].z),s=o[t].x-e.x,n=o[t].y-e.y;c[t]=s,f[t]=n,u[t]=s**2+n**2}let g=0;if(l=0,n){const t=Math.max(3,Math.floor(r.length*s)-1);for(let t=0;t<r.length;t++)a[t]=u[t];a.sort(((t,e)=>t-e)),g=Math.max(4*a[t],16);for(let t=0;t<r.length;t++)a[t]>g?l+=g/6:l+=g/6*(1-(1-a[t]/g)*(1-a[t]/g)*(1-a[t]/g))}else l=u.reduce(((t,e)=>t+e),0);if(l/=r.length,l<.1)break;if(t>0&&l/h>.99)break;if(10===t)break;h=l;const w=[],p=[];for(let t=0;t<r.length;t++){if(n&&u[t]>g)continue;const o=ot({modelViewProjectionTransform:m,modelViewTransform:i,projectionTransform:e,worldCoord:r[t]});if(n){const e=(1-u[t]/g)*(1-u[t]/g);for(let t=0;t<2;t++)for(let r=0;r<6;r++)o[t][r]*=e;w.push([c[t]*e]),w.push([f[t]*e])}else w.push([c[t]]),w.push([f[t]]);for(let t=0;t<o.length;t++)p.push(o[t])}const d=rt({dU:w,J_U_S:p});if(null===d)break;i=et({modelViewTransform:i,dS:d})}return{modelViewTransform:i,err:l}},et=({modelViewTransform:t,dS:e})=>{let r,o,s,n=e[0]**2+e[1]**2+e[2]**2;n<1e-6?(r=1,o=0,s=0,n=0):(n=Math.sqrt(n),r=e[0]/n,o=e[1]/n,s=e[2]/n);const i=Math.cos(n),h=Math.sin(n),l=1-i;K[0][0]=r*r*l+i,K[0][1]=r*o*l-s*h,K[0][2]=r*s*l+o*h,K[0][3]=e[3],K[1][0]=o*r*l+s*h,K[1][1]=o*o*l+i,K[1][2]=o*s*l-r*h,K[1][3]=e[4],K[2][0]=s*r*l-o*h,K[2][1]=s*o*l+r*h,K[2][2]=s*s*l+i,K[2][3]=e[5];const u=[[],[],[]];for(let e=0;e<3;e++){for(let r=0;r<4;r++)u[e][r]=t[e][0]*K[0][r]+t[e][1]*K[1][r]+t[e][2]*K[2][r];u[e][3]+=t[e][3]}return u},rt=({dU:t,J_U_S:e})=>{const r=new C(e),o=new C(t),s=r.transpose(),n=s.mmul(r),i=s.mmul(o);let h;try{h=j(n)}catch(t){return null}return h.mmul(i).to1DArray()},ot=({modelViewProjectionTransform:t,modelViewTransform:e,projectionTransform:r,worldCoord:o})=>{const s=e,{x:n,y:i,z:h}=o,l=W(t,n,i,h),u=l.z*l.z;B[0][0]=r[0][0]*l.z/u,B[0][1]=r[0][1]*l.z/u,B[0][2]=(r[0][2]*l.z-r[2][2]*l.x)/u,B[1][0]=r[1][0]*l.z/u,B[1][1]=r[1][1]*l.z/u,B[1][2]=(r[1][2]*l.z-r[2][2]*l.y)/u,Z[0][0]=s[0][2]*i,Z[0][1]=-s[0][2]*n,Z[0][2]=s[0][1]*n-s[0][0]*i,Z[0][3]=s[0][0],Z[0][4]=s[0][1],Z[0][5]=s[0][2],Z[1][0]=s[1][2]*i,Z[1][1]=-s[1][2]*n,Z[1][2]=s[1][1]*n-s[1][0]*i,Z[1][3]=s[1][0],Z[1][4]=s[1][1],Z[1][5]=s[1][2],Z[2][0]=s[2][2]*i,Z[2][1]=-s[2][2]*n,Z[2][2]=s[2][1]*n-s[2][0]*i,Z[2][3]=s[2][0],Z[2][4]=s[2][1],Z[2][5]=s[2][2];const a=[[],[]];for(let t=0;t<2;t++)for(let e=0;e<6;e++){a[t][e]=0;for(let r=0;r<3;r++)a[t][e]+=B[t][r]*Z[r][e]}return a};let st,nt,it=[],ht=!1;onmessage=t=>{const{data:e}=t;switch(e.type){case"setup":(t=>{it=t.matchingDataList,ht=t.debugMode,st=new class{queryWidth;queryHeight;debugMode;constructor(t,e,r=!1){this.queryWidth=t,this.queryHeight=e,this.debugMode=r}matchDetection(t,e){const r={frames:[]};let o=null;for(const[s,n]of t.entries()){const t=G({keyframe:n,querypoints:e,querywidth:this.queryWidth,queryheight:this.queryHeight,debugMode:this.debugMode});if(!t)continue;const{H:i,matches:h,debugExtra:l}=t;r.frames.push(l),i&&(null===o||(o?.matches?.length??0<h.length))&&(o={keyframeIndex:s,matches:h,H:i})}if(null===o||!o.matches)return{keyframeIndex:-1,debugExtra:r};const s=[],n=[],i=t[o.keyframeIndex];for(const t of o.matches){const e=t.querypoint,r=t.keypoint;s.push({x:e.x,y:e.y}),n.push({x:(r.x+.5)/i.scale,y:(r.y+.5)/i.scale,z:0})}return{keyframeIndex:o.keyframeIndex,screenCoords:s,worldCoords:n,debugExtra:r}}}(t.inputWidth,t.inputHeight,ht),nt=new class{projectionTransform;constructor(t){this.projectionTransform=t}estimate({screenCoords:t,worldCoords:e}){return(t=>{const{projectionTransform:e,screenCoords:r,worldCoords:o}=t,s=$(o.map((t=>[t.x,t.y])),r.map((t=>[t.x,t.y])));if(!s)return null;const n=new C([[s[0],s[1],s[2]],[s[3],s[4],s[5]],[s[6],s[7],s[8]]]),i=j(new C(e)).mmul(n).to1DArray(),h=Math.sqrt(i[0]*i[0]+i[3]*i[3]+i[6]*i[6]),l=Math.sqrt(i[1]*i[1]+i[4]*i[4]+i[7]*i[7]),u=(h+l)/2,a=[];a[0]=i[0]/h,a[3]=i[3]/h,a[6]=i[6]/h,a[1]=i[1]/l,a[4]=i[4]/l,a[7]=i[7]/l,a[2]=a[3]*a[7]-a[6]*a[4],a[5]=a[6]*a[1]-a[0]*a[7],a[8]=a[0]*a[4]-a[1]*a[3];const c=Math.sqrt(a[2]*a[2]+a[5]*a[5]+a[8]*a[8]);a[2]/=c,a[5]/=c,a[8]/=c;const f=[];return f[0]=i[2]/u,f[1]=i[5]/u,f[2]=i[8]/u,[[a[0],a[1],a[2],f[0]],[a[3],a[4],a[5],f[1]],[a[6],a[7],a[8],f[2]]]})({screenCoords:t,worldCoords:e,projectionTransform:this.projectionTransform})}refineEstimate({initialModelViewTransform:t,worldCoords:e,screenCoords:r}){return(({initialModelViewTransform:t,projectionTransform:e,worldCoords:r,screenCoords:o})=>{const s=r.reduce(((t,e)=>t+e.x),0)/r.length,n=r.reduce(((t,e)=>t+e.y),0)/r.length,i=[];for(const t of r)i.push({x:t.x-s,y:t.y-n,z:t.z});const h=[[],[],[]];for(let e=0;e<3;e++)for(let r=0;r<3;r++)h[e][r]=t[e][r];h[0][3]=t[0][0]*s+t[0][1]*n+t[0][3],h[1][3]=t[1][0]*s+t[1][1]*n+t[1][3],h[2][3]=t[2][0]*s+t[2][1]*n+t[2][3];const l=[1,.8,.6,.4,0];let u=h,a=null;for(const t of l){const r=tt({initialModelViewTransform:u,projectionTransform:e,worldCoords:i,screenCoords:o,inlierProb:t});if(u=r.modelViewTransform,r.err<5){a=u;break}}return null===a?null:(a[0][3]=a[0][3]-a[0][0]*s-a[0][1]*n,a[1][3]=a[1][3]-a[1][0]*s-a[1][1]*n,a[2][3]=a[2][3]-a[2][0]*s-a[2][1]*n,a)})({initialModelViewTransform:t,worldCoords:e,screenCoords:r,projectionTransform:this.projectionTransform})}}(t.projectionTransform)})(e);break;case"match":(t=>{const e=t.targetIndexes;let r=-1,o=null,s=null;for(const n of e){const{keyframeIndex:e,screenCoords:i,worldCoords:h,debugExtra:l}=st.matchDetection(it[n],t.featurePoints);if(s=l,-1!==e){const t=nt.estimate({screenCoords:i,worldCoords:h});t&&(r=n,o=t);break}}postMessage({type:"matchDone",targetIndex:r,modelViewTransform:o,debugExtra:s})})(e);break;case"trackUpdate":(t=>{const{modelViewTransform:e,worldCoords:r,screenCoords:o}=t,s=nt.refineEstimate({initialModelViewTransform:e,screenCoords:o,worldCoords:r});postMessage({type:"trackUpdateDone",modelViewTransform:s})})(e)}}})();',"Worker",void 0,void 0)}const BY="updateMatrix";var UY=n(3379),WY=n.n(UY),VY=n(7795),GY=n.n(VY),HY=n(569),jY=n.n(HY),qY=n(3565),XY=n.n(qY),KY=n(9216),YY=n.n(KY),JY=n(4589),ZY=n.n(JY),QY=n(8485),tJ={};tJ.styleTagTransform=ZY(),tJ.setAttributes=XY(),tJ.insert=jY().bind(null,"head"),tJ.domAPI=GY(),tJ.insertStyleElement=YY(),WY()(QY.Z,tJ),QY.Z&&QY.Z.locals&&QY.Z.locals;const eJ="yes",nJ="hidden",rJ=new Br;rJ.compose(new ur,new lr,new ur(.001,.001,.001));window.MINDAR.IMAGE.MindARThree||(window.MINDAR.IMAGE.MindARThree=class{container;imageTargetSrc;maxTrack;filterMinCF;filterBeta;warmupTolerance;missTolerance;ui;scene;cssScene;renderer;cssRenderer;camera;anchors;controller;video;postMatrixs;constructor({container:t,imageTargetSrc:e,maxTrack:n,uiLoading:r="yes",uiScanning:s="yes",uiError:i="yes",filterMinCF:a=null,filterBeta:o=null,warmupTolerance:l=null,missTolerance:u=null}){this.container=t,this.imageTargetSrc=e,this.maxTrack=n,this.filterMinCF=a,this.filterBeta=o,this.warmupTolerance=l,this.missTolerance=u,this.ui=new class{loadingModal;compatibilityModal;scanningMask;constructor({uiLoading:t,uiScanning:e,uiError:n}){this.loadingModal=t===eJ?this._loadHTML('<div class="mindar-ui-overlay mindar-ui-loading"> <div class="loader"/> </div> '):document.querySelector(t),this.compatibilityModal=n===eJ?this._loadHTML('<div class="mindar-ui-overlay mindar-ui-compatibility"> <div class="content"> <h1>Failed to launch :(</h1> <p> Looks like your device/browser is not compatible. </p> <br/> <br/> <p> Please try the following recommended browsers: </p> <p> For Android device - Chrome </p> <p> For iOS device - Safari </p> </div> </div> '):document.querySelector(n),this.scanningMask=e===eJ?this._loadHTML('<div class="mindar-ui-overlay mindar-ui-scanning"> <div class="scanning"> <div class="inner"> <div class="scanline"/> </div> </div> </div> '):document.querySelector(e),this.hideLoading(),this.hideCompatibility(),this.hideScanning()}showLoading(){this.loadingModal&&this.loadingModal.classList.remove(nJ)}hideLoading(){this.loadingModal&&this.loadingModal.classList.add(nJ)}showCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.remove(nJ)}hideCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.add(nJ)}showScanning(){this.scanningMask&&this.scanningMask.classList.remove(nJ)}hideScanning(){this.scanningMask&&this.scanningMask.classList.add(nJ)}_loadHTML(t){const e=document.createElement("template");e.innerHTML=t.trim();const n=e.content.firstChild;return document.getElementsByTagName("body")[0].appendChild(n),n}}({uiLoading:r,uiScanning:s,uiError:i}),this.scene=new dl,this.cssScene=new dl,this.renderer=new ll({antialias:!0,alpha:!0}),this.cssRenderer=new Df,this.renderer.outputEncoding=Pe,this.renderer.setPixelRatio(window.devicePixelRatio),this.camera=new yi,this.anchors=[],this.renderer.domElement.style.position="absolute",this.cssRenderer.domElement.style.position="absolute",this.container.appendChild(this.renderer.domElement),this.container.appendChild(this.cssRenderer.domElement),window.addEventListener("resize",this.resize.bind(this))}async start(){this.ui.showLoading(),await this._startVideo(),await this._startAR()}stop(){this.controller.stopProcessVideo();const{srcObject:t}=this.video;t&&(t.getTracks().forEach((t=>{t.stop()})),this.video.remove())}addAnchor(t){const e=new nl;e.visible=!1,e.matrixAutoUpdate=!1;const n={group:e,targetIndex:t,onTargetFound:null,onTargetLost:null,css:!1,visible:!1};return this.anchors.push(n),this.scene.add(e),n}addCSSAnchor(t){const e=new nl;e.visible=!1,e.matrixAutoUpdate=!1;const n={group:e,targetIndex:t,onTargetFound:null,onTargetLost:null,css:!0,visible:!1};return this.anchors.push(n),this.cssScene.add(e),n}_startVideo(){return new Promise((async(t,e)=>{if(this.video=document.createElement("video"),this.video.setAttribute("autoplay",""),this.video.setAttribute("muted",""),this.video.setAttribute("playsinline",""),this.video.style.position="absolute",this.video.style.top="0px",this.video.style.left="0px",this.video.style.zIndex="-2",this.container.appendChild(this.video),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)return this.ui.showCompatibility(),void e();try{const e=await navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:"environment"}});this.video.addEventListener("loadedmetadata",(()=>{this.video.setAttribute("width",this.video.videoWidth.toString()),this.video.setAttribute("height",this.video.videoHeight.toString()),t()})),this.video.srcObject=e}catch(t){console.log("getUserMedia error",t),e()}}))}_startAR(){return new Promise((async t=>{this.controller=new class{inputWidth;inputHeight;maxTrack;filterMinCF;filterBeta;warmupTolerance;missTolerance;cropDetector;inputLoader;markerDimensions;onUpdate;debugMode;processingVideo;interestedTargetIndex;projectionTransform;projectionMatrix;worker;workerMatchDone;workerTrackDone;trackingStates;tracker;constructor({inputWidth:t,inputHeight:e,onUpdate:n=null,debugMode:r=!1,maxTrack:s=1,warmupTolerance:i=null,missTolerance:a=null,filterMinCF:o=null,filterBeta:l=null}){this.inputHeight=e,this.inputWidth=t,this.maxTrack=s,this.filterMinCF=BK(o)?.001:o,this.filterBeta=BK(l)?1e3:l,this.warmupTolerance=BK(i)?5:i,this.missTolerance=BK(a)?5:a,this.cropDetector=new class{width;height;debugMode;cropSize;lastRandomIndex;detector;constructor(t,e,n=!1){this.width=t,this.height=e,this.debugMode=n,this.cropSize=this._getCropSize(t,e),this.detector=new WK(t,e,n),this.lastRandomIndex=4}_getCropSize(t,e){const n=Math.min(t,e)/2;return Math.pow(2,Math.round(Math.log(n)/Math.log(2)))}async detect(t){const e=Math.floor(this.height/2-this.cropSize/2),n=Math.floor(this.width/2-this.cropSize/2),r=await this._detect(t,n,e);return this.debugMode&&(r.debugExtra.crop={startX:n,startY:e,cropSize:this.cropSize}),r}detectMoving(t){const e=this.lastRandomIndex%3,n=Math.floor(this.lastRandomIndex/3);let r=Math.floor(this.height/2-this.cropSize+n*this.cropSize/2),s=Math.floor(this.width/2-this.cropSize+e*this.cropSize/2);return s<0&&(s=0),r<0&&(r=0),s>=this.width-this.cropSize&&(s=this.width-this.cropSize-1),r>=this.height-this.cropSize&&(r=this.height-this.cropSize-1),this.lastRandomIndex=(this.lastRandomIndex+1)%9,this._detect(t,s,r)}_detect(t,e,n){const r=t.slice([n,e],[this.cropSize,this.cropSize]),{featurePoints:s,debugExtra:i}=this.detector.detect(r);return s.forEach((t=>{t.x+=e,t.y+=n})),this.debugMode&&(i.projectedImage=r.arraySync()),r.dispose(),{featurePoints:s,debugExtra:i}}}(this.inputWidth,this.inputHeight,r),this.inputLoader=new class{width;height;texShape;context;program;tempPixelHandle;constructor(t,e){this.width=t,this.height=e,this.texShape=[e,t];const n=document.createElement("canvas").getContext("2d");n.canvas.width=t,n.canvas.height=e,this.context=n,this.program=this.buildProgram(t,e);const r=pw();this.tempPixelHandle=r.makeTensorInfo(this.texShape,"float32"),r.texData.get(this.tempPixelHandle.dataId).usage=FB.PIXELS}loadInput(t){this.context.drawImage(t,0,0,this.width,this.height);const e=pw();return e.gpgpu.uploadPixelDataToTexture(e.getTexture(this.tempPixelHandle.dataId),this.context.canvas),this._compileAndRun(this.program,[this.tempPixelHandle])}buildProgram(t,e){const n=2===Sm().getNumber("WEBGL_VERSION")?"texture":"texture2D";return{variableNames:["A"],outputShape:this.texShape,userCode:`\n\tvoid main() {\n\t  ivec2 coords = getOutputCoords();\n\t  int texR = coords[0];\n\t  int texC = coords[1];\n\t  vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${t}.0, ${e}.0);\n\n\t  vec4 values = ${n}(A, uv);\n\t  setOutput((0.299 * values.r + 0.587 * values.g + 0.114 * values.b) * 255.0);\n\t}\n      `}}_compileAndRun(t,e){const n=pw().compileAndRun(t,e);return ow().makeTensorFromTensorInfo(n)}}(this.inputWidth,this.inputHeight),this.markerDimensions=[],this.onUpdate=n,this.debugMode=r,this.processingVideo=!1,this.interestedTargetIndex=-1,this.trackingStates=[];const u=45*Math.PI/180,c=this.inputHeight/2/Math.tan(u/2);this.projectionTransform=[[c,0,this.inputWidth/2],[0,c,this.inputHeight/2],[0,0,1]],this.projectionMatrix=this._glProjectionMatrix({projectionTransform:this.projectionTransform,width:this.inputWidth,height:this.inputHeight,near:10,far:1e5}),this.worker=new zY,this.workerMatchDone=null,this.workerTrackDone=null,this.worker.onmessage=t=>{switch(t.data.type){case"matchDone":this.workerMatchDone?.(t.data);break;case"trackUpdateDone":this.workerTrackDone?.(t.data)}}}showTFStats(){console.log(lw().numTensors),console.table(lw())}addImageTargets(t){return new Promise((async e=>{const n=await fetch(t),r=await n.arrayBuffer();e(this.addImageTargetsFromBuffer(r))}))}addImageTargetsFromBuffer(t){const e=(new class{data;constructor(){this.data=[]}compileImageTargets(t,e){return new Promise((async n=>{const r=[];for(const e of t){const t=document.createElement("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const s=n.getImageData(0,0,e.width,e.height),i=new Uint8Array(e.width*e.height);for(let t=0;t<i.length;t++){const e=4*t;i[t]=Math.floor((s.data[e]+s.data[e+1]+s.data[e+2])/3)}r.push({data:i,width:e.width,height:e.height})}const s=50/r.length;let i=0;this.data=[];for(let t=0;t<r.length;t++){const n=r[t],a=CY(n),o=s/a.length,l={targetImage:n,imageList:a,matchingData:await this._extractMatchingFeatures(a,(()=>{i+=o,e(i)}))};this.data.push(l)}for(const[t,e]of r.entries()){const n=AY(e);this.data[t].trackingImageList=n}const a=await new Promise((t=>{const n=new kY;n.onmessage=n=>{switch(n.data.type){case"progress":e(50+n.data.percent);break;case"compileDone":t(n.data.list)}},n.postMessage({type:"compile",targetImages:r})}));for(const[t,e]of a.entries())this.data[t].trackingData=e;n(this.data)}))}exportData(){const t=[];for(const e of this.data)t.push({targetImage:{width:e.targetImage.width,height:e.targetImage.height},trackingData:e.trackingData,matchingData:e.matchingData});const e=function(t,e){return void 0===e&&(e=hY),new cY(e.extensionCodec,e.context,e.maxDepth,e.initialBufferSize,e.sortKeys,e.forceFloat32,e.ignoreUndefined,e.forceIntegerToFloat).encode(t)}({v:2,dataList:t});return e}importData(t){const e=function(t,e){return void 0===e&&(e=TY),new _Y(e.extensionCodec,e.context,e.maxStrLength,e.maxBinLength,e.maxArrayLength,e.maxMapLength,e.maxExtLength).decode(t)}(new Uint8Array(t));if(!e.v||2!==e.v)return console.error("Your compiled .mind might be outdated. Please recompile"),[];const{dataList:n}=e;this.data=[];for(const t of n)this.data.push({targetImage:t.targetImage,trackingData:t.trackingData,matchingData:t.matchingData});return this.data}async _extractMatchingFeatures(t,e){const n=[];for(const[r,s]of t.entries()){const t=new WK(s.width,s.height);await UT(),uw((()=>{const i=Kv(s.data,[s.data.length],"float32").reshape([s.height,s.width]),{featurePoints:a}=t.detect(i),o=a.filter((t=>t.maxima)),l=a.filter((t=>!t.maxima)),u=FY({points:o}),c=FY({points:l});n.push({maximaPoints:o,minimaPoints:l,maximaPointsCluster:u,minimaPointsCluster:c,width:s.width,height:s.height,scale:s.scale}),e(r)}))}return n}}).importData(t),n=[],r=[],s=[];for(const t of e)r.push(t.matchingData),n.push(t.trackingData),s.push([t.targetImage.width,t.targetImage.height]);return this.tracker=new class{projectionTransform;trackingKeyframeList;debugMode;kernelCaches;featurePointsListT;imagePixelsListT;imagePropertiesListT;constructor(t,e,n,r,s,i=!1){this.projectionTransform=n,this.debugMode=i,this.trackingKeyframeList=e.map((t=>t[0]));const a=Math.max(...this.trackingKeyframeList.map((({points:t})=>t.length)));this.featurePointsListT=[],this.imagePixelsListT=[],this.imagePropertiesListT=[];for(const[t,e]of this.trackingKeyframeList.entries()){const{featurePoints:n,imagePixels:r,imageProperties:s}=this._prebuild(e,a);this.featurePointsListT[t]=n,this.imagePixelsListT[t]=r,this.imagePropertiesListT[t]=s}this.kernelCaches={}}dummyRun(t){const e=[[1,1,1,1],[1,1,1,1],[1,1,1,1]];for(let n=0;n<this.featurePointsListT.length;n++)this.track(t,e,n)}track(t,e,n){let r={};const s=(a=e,[[(i=this.projectionTransform)[0][0]*a[0][0]+i[0][2]*a[2][0],i[0][0]*a[0][1]+i[0][2]*a[2][1],i[0][0]*a[0][2]+i[0][2]*a[2][2],i[0][0]*a[0][3]+i[0][2]*a[2][3]],[i[1][1]*a[1][0]+i[1][2]*a[2][0],i[1][1]*a[1][1]+i[1][2]*a[2][1],i[1][1]*a[1][2]+i[1][2]*a[2][2],i[1][1]*a[1][3]+i[1][2]*a[2][3]],[a[2][0],a[2][1],a[2][2],a[2][3]]]);var i,a;const o=this._buildAdjustedModelViewTransform(s),l=this.featurePointsListT[n],u=this.imagePixelsListT[n],c=this.imagePropertiesListT[n],h=this._computeProjection(o,t,n),{matchingPointsT:d,simT:p}=this._computeMatching(l,u,c,h),f=d.arraySync(),m=p.arraySync(),g=this.trackingKeyframeList[n],x=[],y=[],v=[];for(const[t,e]of f.entries())if(m[t]>.8&&t<g.points.length){v.push(t);const n=MK(s,e[0],e[1]);y.push(n),x.push({x:g.points[t].x/g.scale,y:g.points[t].y/g.scale,z:0})}return this.debugMode&&(r={projectedImage:h.arraySync(),matchingPoints:f,trackedPoints:y,goodTrack:v}),o.dispose(),h.dispose(),d.dispose(),p.dispose(),{worldCoords:x,screenCoords:y,debugExtra:r}}_prebuild(t,e){return uw((()=>{const n=t.scale,r=[];for(let s=0;s<e;s++)s<t.points.length?r.push([t.points[s].x/n,t.points[s].y/n]):r.push([-1,-1]);const s=Kv(t.data,[t.width*t.height]),i=Kv([t.width,t.height,t.scale],[3]);return{featurePoints:Kv(r,[r.length,2],"float32"),imagePixels:s,imageProperties:i}}))}_computeMatching(t,e,n,r){const s=r.shape[0],i=r.shape[1],a=t.shape[0];return this.kernelCaches.computeMatching||(this.kernelCaches.computeMatching=((t,e,n,r,s,i,a,o)=>[EK(6,13,n,r,s,i,a,o),kK(n,r,s,o),IK(o)])(0,0,10,1,21,s,i,a)),uw((()=>{const s=this.kernelCaches.computeMatching,i=this._compileAndRun(s[0],[t,e,n,r]),a=i.argMax(1);return{matchingPointsT:this._compileAndRun(s[1],[t,n,a]),simT:this._compileAndRun(s[2],[i,a])}}))}_computeProjection(t,e,n){const r=this.trackingKeyframeList[n].width,s=this.trackingKeyframeList[n].height,i=this.trackingKeyframeList[n].scale,a=r+"-"+s+"-"+i;return this.kernelCaches.computeProjection||(this.kernelCaches.computeProjection={}),this.kernelCaches.computeProjection[a]||(this.kernelCaches.computeProjection[a]=((t,e,n)=>({variableNames:["M","pixel"],outputShape:[t,e],userCode:`\n\t  void main() {\n\t      ivec2 coords = getOutputCoords();\n\n\t      float m00 = getM(0, 0) * 1000.;\n\t      float m01 = getM(0, 1) * 1000.;\n\t      float m03 = getM(0, 3) * 1000.;\n\t      float m10 = getM(1, 0) * 1000.;\n\t      float m11 = getM(1, 1) * 1000.;\n\t      float m13 = getM(1, 3) * 1000.;\n\t      float m20 = getM(2, 0) * 1000.;\n\t      float m21 = getM(2, 1) * 1000.;\n\t      float m23 = getM(2, 3) * 1000.;\n\n\t      float y = float(coords[0]) / float(${n});\n\t      float x = float(coords[1]) / float(${n});\n\t      float uz = (x * m20) + (y * m21) + m23;\n\t      float oneOverUz = 1. / uz;\n\n\t      float ux = (x * m00) + (y * m01) + m03;\n\t      float uy = (x * m10) + (y * m11) + m13;\n\n\t      ux = floor(ux * oneOverUz + 0.5);\n\t      uy = floor(uy * oneOverUz + 0.5);\n\t      setOutput(getPixel(int(uy), int(ux)));\n\t    }\n\t`}))(s,r,i)),uw((()=>{const n=this.kernelCaches.computeProjection[a];return this._compileAndRun(n,[t,e])}))}_buildAdjustedModelViewTransform(t){return uw((()=>Kv(t.map((t=>t.map((t=>t/1e3)))),[3,4])))}_compileAndRun(t,e){const n=pw().compileAndRun(t,e);return ow().makeTensorFromTensorInfo(n)}}(s,n,this.projectionTransform,this.inputWidth,this.inputHeight,this.debugMode),this.worker.postMessage({type:"setup",inputWidth:this.inputWidth,inputHeight:this.inputHeight,projectionTransform:this.projectionTransform,debugMode:this.debugMode,matchingDataList:r}),this.markerDimensions=s,{dimensions:s,matchingDataList:r,trackingDataList:n}}dummyRun(t){const e=this.inputLoader.loadInput(t);this.cropDetector.detect(e),this.tracker.dummyRun(e),e.dispose()}getProjectionMatrix(){return this.projectionMatrix}getWorldMatrix(t,e){return this._glModelViewMatrix(t,e)}async _detectAndMatch(t,e){const{featurePoints:n}=this.cropDetector.detectMoving(t),{targetIndex:r,modelViewTransform:s}=await this._workerMatch(n,e);return{targetIndex:r,modelViewTransform:s}}async _trackAndUpdate(t,e,n){const{worldCoords:r,screenCoords:s}=await this.tracker.track(t,e,n);return r.length<4?null:await this._workerTrackUpdate(e,{worldCoords:r,screenCoords:s})}_glProjectionMatrix(t){const{projectionTransform:e,width:n,height:r,near:s,far:i}=t,a=[[2*e[0][0]/n,0,-(2*e[0][2]/n-1),0],[0,2*e[1][1]/r,-(2*e[1][2]/r-1),0],[0,0,-(i+s)/(i-s),-2*i*s/(i-s)],[0,0,-1,0]],o=[];for(let t=0;t<4;t++)for(let e=0;e<4;e++)o.push(a[e][t]);return o}_glModelViewMatrix(t,e){const n=this.markerDimensions[e][1];return[t[0][0],-t[1][0],-t[2][0],0,-t[0][1],t[1][1],t[2][1],0,-t[0][2],t[1][2],t[2][2],0,t[0][1]*n+t[0][3],-(t[1][1]*n+t[1][3]),-(t[2][1]*n+t[2][3]),1]}async _matchImageTarget(t,e){if(t>=this.maxTrack)return;const n=[];for(const[t,e]of this.trackingStates.entries())e.isTracking||-1!==this.interestedTargetIndex&&this.interestedTargetIndex!==t||n.push(t);const{targetIndex:r,modelViewTransform:s}=await this._detectAndMatch(e,n);-1!==r&&(this.trackingStates[r].isTracking=!0,this.trackingStates[r].currentModelViewTransform=s)}async _updateTrackingState(t,e){const n=this.trackingStates[e];if(!n.isTracking||!n.currentModelViewTransform)return;const r=await this._trackAndUpdate(t,n.currentModelViewTransform,e);null!==r?n.currentModelViewTransform=r:n.isTracking=!1}_showAfterWarmup(t){const e=this.trackingStates[t];!e.showing&&e.isTracking&&(e.trackMiss=0,e.trackCount++,e.trackCount<=this.warmupTolerance||(e.showing=!0,e.trackingMatrix=null,e.filter.reset()))}_hideAfterMiss(t){const e=this.trackingStates[t];e.showing&&(e.isTracking?e.trackMiss=0:(e.trackCount=0,e.trackMiss++,e.trackMiss<this.missTolerance||(e.showing=!1,e.trackingMatrix=null,this.onUpdate?.({type:BY,targetIndex:t,worldMatrix:null}))))}_onTrackShow(t){const e=this.trackingStates[t];if(!e.showing||!e.currentModelViewTransform)return;const n=this._glModelViewMatrix(e.currentModelViewTransform,t);e.trackingMatrix=e.filter.filter(Date.now(),n),this.onUpdate?.({type:BY,worldMatrix:UK(e.trackingMatrix),targetIndex:t})}async _doVideoProcessing(t){for(;this.processingVideo;){const e=this.inputLoader.loadInput(t),n=this.trackingStates.reduce(((t,e)=>t+(e.isTracking?1:0)),0);await this._matchImageTarget(n,e);for(const[t]of this.trackingStates.entries())await this._updateTrackingState(e,t),this._showAfterWarmup(t),this._hideAfterMiss(t),this._onTrackShow(t);e.dispose(),this.onUpdate?.({type:"processDone"}),await UT()}}processVideo(t){if(!this.processingVideo){this.processingVideo=!0,this.trackingStates=[];for(let t=0;t<this.maxTrack;t++)this.trackingStates.push({showing:!1,isTracking:!1,currentModelViewTransform:null,trackCount:0,trackMiss:0,filter:new OY({minCutOff:this.filterMinCF,beta:this.filterBeta})});this._doVideoProcessing(t)}}stopProcessVideo(){this.processingVideo=!1}async detect(t){const e=this.inputLoader.loadInput(t),{featurePoints:n,debugExtra:r}=await this.cropDetector.detect(e);return e.dispose(),{featurePoints:n,debugExtra:r}}async match(t,e){const{modelViewTransform:n,debugExtra:r}=await this._workerMatch(t,[e]);return{modelViewTransform:n,debugExtra:r}}async _workerMatch(t,e){return new Promise((async n=>{this.workerMatchDone=t=>{n({targetIndex:t.targetIndex,modelViewTransform:t.modelViewTransform,debugExtra:t.debugExtra})},this.worker.postMessage({type:"match",featurePoints:t,targetIndexes:e})}))}async track(t,e,n){const r=this.inputLoader.loadInput(t),s=this.tracker.track(r,e,n);return r.dispose(),s}async trackUpdate(t,e){return e.worldCoords.length<4?null:await this._workerTrackUpdate(t,e)}async _workerTrackUpdate(t,e){return new Promise((async n=>{this.workerTrackDone=t=>{n(t.modelViewTransform)};const{worldCoords:r,screenCoords:s}=e;this.worker.postMessage({type:"trackUpdate",modelViewTransform:t,screenCoords:s,worldCoords:r})}))}}({inputWidth:this.video.videoWidth,inputHeight:this.video.videoHeight,filterMinCF:this.filterMinCF,filterBeta:this.filterBeta,warmupTolerance:this.warmupTolerance,missTolerance:this.missTolerance,maxTrack:this.maxTrack,onUpdate:t=>{if(t.type===BY){const{targetIndex:e,worldMatrix:n}=t;for(let t=0;t<this.anchors.length;t++)if(this.anchors[t].targetIndex===e){if(this.anchors[t].css?this.anchors[t].group.children.forEach((t=>{t.element.style.visibility=n?"visible":"hidden"})):this.anchors[t].group.visible=!!n,n){const r=new Br;r.elements=[...n],r.multiply(this.postMatrixs[e]),this.anchors[t].css&&r.multiply(rJ),this.anchors[t].group.matrix=r}this.anchors[t].visible&&!n&&(this.anchors[t].visible=!1,this.anchors[t].onTargetLost?.()),!this.anchors[t].visible&&n&&(this.anchors[t].visible=!0,this.anchors[t].onTargetFound?.()),n&&this.ui.hideScanning()}}}}),this.resize();const{dimensions:e}=await this.controller.addImageTargets(this.imageTargetSrc);this.postMatrixs=[];for(let t=0;t<e.length;t++){const n=new ur,r=new lr,s=new ur,[i,a]=e[t];n.x=i/2,n.y=i/2+(a-i)/2,s.x=i,s.y=i,s.z=i;const o=new Br;o.compose(n,r,s),this.postMatrixs.push(o)}await this.controller.dummyRun(this.video),this.ui.hideLoading(),this.ui.showScanning(),this.controller.processVideo(this.video),t()}))}resize(){const{renderer:t,cssRenderer:e,camera:n,container:r,video:s,controller:i}=this;if(!s||!i)return;let a,o;const l=s.videoWidth/s.videoHeight;l>r.clientWidth/r.clientHeight?(o=r.clientHeight,a=o*l):(a=r.clientWidth,o=a/l);const u=i.getProjectionMatrix(),c=2*Math.atan(1/u[5]/o*r.clientHeight)*180/Math.PI,h=u[14]/(u[10]-1),d=u[14]/(u[10]+1);n.fov=c,n.near=h,n.far=d,n.aspect=r.clientWidth/r.clientHeight,n.updateProjectionMatrix(),s.style.top=-(o-r.clientHeight)/2+"px",s.style.left=-(a-r.clientWidth)/2+"px",s.style.width=a+"px",s.style.height=o+"px";const p=t.domElement,f=e.domElement;p.style.position="absolute",p.style.left="0",p.style.top="0",p.style.width=r.clientWidth+"px",p.style.height=r.clientHeight+"px",f.style.position="absolute",f.style.left="0",f.style.top="0",f.style.width=r.clientWidth+"px",f.style.height=r.clientHeight+"px",t.setSize(r.clientWidth,r.clientHeight),e.setSize(r.clientWidth,r.clientHeight)}}),window.MINDAR.IMAGE.THREE||(window.MINDAR.IMAGE.THREE=t)})()})();